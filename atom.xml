<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笔记仓库</title>
  
  <subtitle>知道为什么比知道怎么做更重要</subtitle>
  <link href="https://chenyuanzhen.github.io/atom.xml" rel="self"/>
  
  <link href="https://chenyuanzhen.github.io/"/>
  <updated>2022-04-14T03:20:32.494Z</updated>
  <id>https://chenyuanzhen.github.io/</id>
  
  <author>
    <name>镇远</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker</title>
    <link href="https://chenyuanzhen.github.io/2022/04/14/uploadMd/Docker%E7%AC%94%E8%AE%B0/"/>
    <id>https://chenyuanzhen.github.io/2022/04/14/uploadMd/Docker%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-14T02:18:51.000Z</published>
    <updated>2022-04-14T03:20:32.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h2><p>使用您提供的应用程序或服务的本地容器在标准化环境中工作.</p><blockquote><p>我的理解是为每一个应用程序或服务单独配置环境</p></blockquote><h2 id="基于技术"><a class="markdownIt-Anchor" href="#基于技术"></a> 基于技术</h2><p>基于 <strong>Linux 内核</strong> 提供的 CGroup 功能和 namespace 来实现的</p><h2 id="container"><a class="markdownIt-Anchor" href="#container"></a> Container</h2><p>包括以下的东西</p><ul><li><p>Cgroup</p><p>限制container所用的资源</p></li><li><p>namespace</p><p>限制container所能看到的文件, 如PID, 文件都是新的, container无法看见本机的进程PID</p><p>目的是隔离内核资源</p></li><li><p><a href="https://stackoverflow.com/questions/32775594/why-does-docker-need-a-union-file-system">Union File System</a></p><p>可以把多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的。UnionFS允许只读和可读写目录并存. 具有写时复制功能</p><p>docker采用的是 AUFS, 即Another UFS.  AUFS 里有分层的概念, 对只读权限的分支修改, 仅会记录其中不同的部分.</p></li></ul><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20220330095852699.png?raw=true" alt="image-20220330095852699" style="zoom:50%;"><blockquote><p>batch目录下存储一个个cgroup</p><ul><li>bitcoins是一个cgroup</li><li>hadoop也是一个cgroup</li></ul><p>cgroup = 进程组</p><p>进程组内只能看到组内的情况, 有命名空间的限制</p></blockquote><h4 id="cgroup"><a class="markdownIt-Anchor" href="#cgroup"></a> cgroup</h4><p>cgroup 是绑定到一组进程的集合, 通过 cgroup 文件系统定义的限制或参数</p><h4 id="cgroups"><a class="markdownIt-Anchor" href="#cgroups"></a> cgroups</h4><p>cgroups 全称<code>control groups</code>, Linux内核功能，允许将<mark>进程资源</mark>组织成分层组，然后可以限制和监视各种资源的使用。</p><h4 id="子系统subsystem"><a class="markdownIt-Anchor" href="#子系统subsystem"></a> 子系统subsystem</h4><p>子系统<code>subsystem</code> 一个内核组件</p><blockquote><p><code>subsystem</code>又被成为资源控制器, 简称控制器</p></blockquote><p>为每种可控制的资源定义一个子系统</p><p>已有的子系统</p><ul><li>cpu子系统 限制进程CPU使用率</li><li>memory子系统 限制进程memory使用量</li><li>net_cls子系统 标记cgroups中进程的网络数据包, 用tc模块对数据包控制</li><li>freezer子系统 挂起或恢复cgroups中的进程</li></ul><p>cgroup需要与子系统支持才能获得资源, (如CPU或内存等),</p><blockquote><p>由子系统实现对cgroup中进程资源的限制和跟踪</p></blockquote><h4 id="层级-hierarchy"><a class="markdownIt-Anchor" href="#层级-hierarchy"></a> 层级 hierarchy</h4><p>每一个子系统都可被分为多个层级, 层级的节点表示占用该子系统的资源配额</p><p>层次结构中可以定义所使用的资源限制</p><p>可以将子系统的资源分成多个层次. 子节点的资源配额, 限制, 监控 继承父节点</p><p>一个进程可以从CPU资源层级中挑选一个节点, 获得CPU配额和监控, 同时也可以从memory资源层级中挑选一个, 获得内存配额.</p><h4 id="cgroups文件系统"><a class="markdownIt-Anchor" href="#cgroups文件系统"></a> cgroups文件系统</h4><p>Linux通过文件的方式，将cgroups的功能和配置暴露给用户，这得益于Linux的虚拟文件系统（VFS）。VFS将具体文件系统的细节隐藏起来，给用户态提供一个统一的文件系统API接口，cgroups和VFS之间的链接部分，称之为cgroups文件系统。</p><p>比如挂在 cpu、cpuset、memory 三个子系统到 /cgroups/cpu_mem 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t cgroup -o cpu,cpuset,memory cpu_mem /cgroups/cpu_mem</span><br></pre></td></tr></table></figure><h2 id="与虚拟机的区别"><a class="markdownIt-Anchor" href="#与虚拟机的区别"></a> 与虚拟机的区别</h2><ul><li><p>Docker中的容器, 是共享一套操作系统资源的.</p></li><li><p>虚拟机是虚拟一套硬件, 并在其之上运行一个完整的操作系统.</p></li></ul><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><h3 id="镜像image"><a class="markdownIt-Anchor" href="#镜像image"></a> 镜像Image</h3><p>一个特殊的文件系统. <strong>供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）</strong>. <mark>不包括任何动态数据</mark></p><blockquote><p>分层存储架构, 由多层文件系统联合</p><p><strong>每一层构建后不会有改变</strong></p></blockquote><h3 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h3><p>镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p><blockquote><p>理解为镜像是类, 而容器是实例</p></blockquote><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间</p><h3 id="与虚拟机的差别"><a class="markdownIt-Anchor" href="#与虚拟机的差别"></a> 与虚拟机的差别</h3><p>虚拟机占用巨量内存, 完全的模拟一台计算机, 从硬件到软件.</p><p>而Docker是共享操作系统内核, 有更少的抽象层</p><p><mark>docker容器, 在使用层面可视为一个独立的linux (或其他)的系统, (虽然实现不是)</mark>, 有自己的防火墙等</p><h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h3><p>Docker守护进程: 管理所有的docker容器, 可直接与主操作系统进行通信</p><p>docker容器: 由docker镜像创建的一个实例</p><p>docker常用于隔离不同的应用, 能充分的发挥硬件的性能.</p><h4 id="dockerhub"><a class="markdownIt-Anchor" href="#dockerhub"></a> dockerHub</h4><p>与github类似, 用户可以将镜像放置到dockerHub, 供大家下载. 可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从dockerHub, 默认是官网,下载镜像名</span></span><br><span class="line">docker pull [OPTION] imageName</span><br></pre></td></tr></table></figure><h2 id="镜像常用命令"><a class="markdownIt-Anchor" href="#镜像常用命令"></a> 镜像常用命令</h2><h3 id="信息查看"><a class="markdownIt-Anchor" href="#信息查看"></a> 信息查看</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 详细信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一个命令的详细说明</span></span><br><span class="line">docker 命令 --help</span><br></pre></td></tr></table></figure><h2 id="容器命令"><a class="markdownIt-Anchor" href="#容器命令"></a> 容器命令</h2><h4 id="启动命令"><a class="markdownIt-Anchor" href="#启动命令"></a> 启动命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run imageName[:tags (版本, 默认为latest)]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 可后台运行 但需要注意 image 要有前台进程执行, 一定要有对外服务, 不然会自动杀死</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -it 使用交互方式运行,进入容器并查看内容</span></span><br></pre></td></tr></table></figure><h4 id="查看运行中的容器"><a class="markdownIt-Anchor" href="#查看运行中的容器"></a> 查看运行中的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a 历史运行的容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n=? 最近创建的容器</span></span><br></pre></td></tr></table></figure><h4 id="进入当前运行的容器"><a class="markdownIt-Anchor" href="#进入当前运行的容器"></a> 进入当前运行的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式一 /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器开启一个新的终端, 并执行命令</span></span><br><span class="line">docker exec -it 容器ID 执行命令的path</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器正在运行的终端, 不会启动新的进程</span></span><br><span class="line">docker attach 容器id</span><br></pre></td></tr></table></figure><blockquote><p>很多容器连bash都没有, 可以用</p><p>docker exec -ti containerId ls -al</p><p>执行命令</p></blockquote><h4 id="退出容器"><a class="markdownIt-Anchor" href="#退出容器"></a> 退出容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit # 直接推出容器, 并终止容器运行</span><br><span class="line">ctrl + P + Q #仅退出, 不终止</span><br></pre></td></tr></table></figure><h4 id="删除容器"><a class="markdownIt-Anchor" href="#删除容器"></a> 删除容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除指定容器, 容器正在运行不能删除, -f 可无视</span></span><br><span class="line">docker rm 容器id</span><br></pre></td></tr></table></figure><h4 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h4><p>查看容器到底做了什么</p><p>可用 --help 查看用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br></pre></td></tr></table></figure><h4 id="容器进程信息"><a class="markdownIt-Anchor" href="#容器进程信息"></a> 容器进程信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top  id</span><br></pre></td></tr></table></figure><h4 id="元数据"><a class="markdownIt-Anchor" href="#元数据"></a> 元数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect id</span><br></pre></td></tr></table></figure><p>详细描述容器的信息</p><h4 id="从容器内拷贝文件到主机上"><a class="markdownIt-Anchor" href="#从容器内拷贝文件到主机上"></a> 从容器内拷贝文件到主机上</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp</span><br></pre></td></tr></table></figure><h4 id="端口暴露"><a class="markdownIt-Anchor" href="#端口暴露"></a> 端口暴露</h4><p>主机本身有端口, 其次是容器自己也有端口. 若要从外网访问主机中容器的服务, 需进行端口暴露</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 3344:80 3344指的是主机开启的端口, 而80指的是容器自己的端口</span></span><br><span class="line">docker run -d --name name -p 3344:80 命令</span><br></pre></td></tr></table></figure><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210729162845231.png?raw=true" alt="image-20210729162845231" style="zoom:50%;"><h4 id="查看状态"><a class="markdownIt-Anchor" href="#查看状态"></a> 查看状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器占用内存, CPU等数据, 防止因为容器占用的容量越大, 导致系统卡顿</span></span><br><span class="line">docker stats</span><br></pre></td></tr></table></figure><h3 id="联合文件系统"><a class="markdownIt-Anchor" href="#联合文件系统"></a> 联合文件系统</h3><p>镜像的文件组成系统</p><p>一种分层, 轻量级且高性能的文件系统, 对文件系统的修改作为一次提交来一层层叠加. 可以将不同目录挂载到同一个虚拟文件系统下.</p><blockquote><p>同时加载多个文件系统, 但联合加载会将各层的文件系统统一为一个文件系统</p></blockquote><h4 id="bootfs"><a class="markdownIt-Anchor" href="#bootfs"></a> bootfs</h4><p>Docker镜像的最底底层, 大部分的Linux系统(发行版)都是一致的, 包含boot加载器和内核. 所有镜像共用的</p><h4 id="rootfs"><a class="markdownIt-Anchor" href="#rootfs"></a> rootfs</h4><p>在bootfs之上, 包含Linux系统中的 /dev, /proc, /bin, /etc 等标准目录和文件. 不同的发行版有不同</p><p>镜像的组成为什么那么小,  是因为bootfs是共用的, 而rootfs只需要包含基本的命令, 工具和程序库即可.</p><blockquote><p>如在安装 tomcat镜像时, 会执行分层下载.</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210731093301824.png?raw=true" alt="image-20210731093301824" style="zoom:50%;"><p>左边为层号. 若docker中已经下载过的层号, 会直接复用, 不会重复下载.</p><p>在tomcat镜像上的操作, 会被认为是新的一层. 可以将操作完的镜像重新打包</p></blockquote><h3 id="docker-commit"><a class="markdownIt-Anchor" href="#docker-commit"></a> docker commit</h3><p>将新的容器变为 一个新的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker commit [OPTIONS] CONTAINER_ID [REPOSITORY[:TAG]]</span></span><br><span class="line">docker commit -m 'message' -a 'authorName' </span><br></pre></td></tr></table></figure><h3 id="容器数据卷"><a class="markdownIt-Anchor" href="#容器数据卷"></a> 容器数据卷</h3><p>镜像技术实现开发环境的独立, 但是也意味着数据也是独立的. 但我们不希望, 镜像被删除时, 数据也被删除. 且容器间数据共用, 可减少占用空间. 因此, 容器数据卷诞生.</p><p><mark>不同的容器可以共用一个容器数据卷</mark> 当容器被删除时, 容器数据卷不会随之删除</p><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4><p>将容器的某一个目录同步( 挂载 )到本地主机上的一个目录. 实现容器数据放置到主机上.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v 挂载配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -e 环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name 容器名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意 这个为指定路径挂载, 除此之外还有 具名挂载, 匿名挂载</span></span><br><span class="line">docker run -it -v 本机目录path:容器目录 -v 第二个目录 imageName</span><br><span class="line">docker run -it imagesName /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看信息 <span class="string">"Mounts"</span></span></span><br><span class="line">docker inspect containerID;</span><br><span class="line"><span class="meta">#</span><span class="bash"> -v 本机目录path:容器目录</span></span><br></pre></td></tr></table></figure><p>是双向绑定, 即任何一方有变化, 另一方也有同样的变化</p><h3 id="具名挂载与匿名挂载"><a class="markdownIt-Anchor" href="#具名挂载与匿名挂载"></a> 具名挂载与匿名挂载</h3><p>在进行容器数据卷挂载时, 可以指定本机目录path, 也可不指定. 不指定则会创建一个新的数据卷, 匿名数据卷位于/var/lib/docker/volumes/xxxx/_data</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v [卷名(若卷名不存在,则自动创建)|本机的绝对路径:]容器目录 imageName</span><br></pre></td></tr></table></figure><h4 id="docker-volume"><a class="markdownIt-Anchor" href="#docker-volume"></a> docker volume</h4><p>查看目前docker容器所有的容器数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect 容器数据卷名</span><br></pre></td></tr></table></figure><h3 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> Dockerfile</h3><p>构建镜像的配置文件.  定义构建镜像的文件</p><p>由命令 + 参数  组成</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="keyword">FROM</span> imageNAME</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'something'</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">'volume1'</span>, <span class="string">'volume2'</span>]</span></span><br></pre></td></tr></table></figure><p>执行 docker bulid 命令即可创建</p><h4 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h4><ol><li>编写dockerFile</li><li>通过dockerFile构建镜像 docker image</li><li>根据镜像启动docker容器</li></ol><h4 id="常用dockerfile指令"><a class="markdownIt-Anchor" href="#常用dockerfile指令"></a> 常用dockerFile指令</h4><ul><li><p>FROM                   基于的基础镜像</p></li><li><p>MAINTAIER          镜像作者</p></li><li><p>RUN                      镜像构建时需要运行的命令</p></li><li><p>ADD                      需添加的内容</p></li><li><p>WORKDIR             工作目录</p></li><li><p>VOLUME               挂载的目录</p></li><li><p>EXPOSE                 暴露端口配置</p></li><li><p>CMD                      指定容器启动时, 需要执行的命令, 仅最后一个生效</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMD ["ls", "-a"]</span><br><span class="line">CMD commandPath1 &amp;&amp; commandPath2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会自动执行 ls -a, 目录是设定的工作目录</span></span><br><span class="line">docker run imagesName</span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是 会出错, 因为 -l 代替 ls -a</span></span><br><span class="line">docker run imagesName -l</span><br></pre></td></tr></table></figure></li><li><p>ENTRYPOINT       指定容器启动时, 需执行的命令, 可以追加命令</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT["ls", "-a"]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会执行 ls -l -a</span></span><br><span class="line">docker run iamgesName -l</span><br></pre></td></tr></table></figure></li><li><p>COPY                    与ADD相似, 将文件进行拷贝</p></li><li><p>ENV                       构建时, 设定环境变量</p></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> name&lt;email&gt;</span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WORKPATH /usr/local</span><br><span class="line"><span class="comment"># 终端打开时默认的目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">  <span class="variable">$WORKPATH</span></span></span><br><span class="line"><span class="comment"># 指定的命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install net-tools</span></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># 执行的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$WORKPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"....."</span></span></span><br><span class="line"><span class="comment"># 默认bash的路径, 运行bash</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><h4 id="docker-build"><a class="markdownIt-Anchor" href="#docker-build"></a> docker build</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Usage:  docker build [OPTIONS] PATH | URL | -</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker build -f dockerFile路径 -t 镜像名:[tag] .(在表示当前目录)</span></span><br><span class="line">docker build -f mydockerfile -t image:0.1(版本号) .</span><br></pre></td></tr></table></figure><p>build完后, 会生成一个镜像.</p><p><code>docker history imageName</code> 可查看镜像的构建过程</p><h3 id="数据卷容器"><a class="markdownIt-Anchor" href="#数据卷容器"></a> 数据卷容器</h3><p>若数据卷间, 需要共享数据卷, 则可利用docker run的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker02与docker01共用docker01的数据卷.</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 两者在数据卷中修改, 两者都可见</span></span><br><span class="line">docker run -it --name dcoker02 --volumes-from docker01 imagesName</span><br></pre></td></tr></table></figure><p>只要仍有容器使用数据卷, 那么数据卷不会消失. 与C++中的 shared_ptr的规则相同.</p><h2 id="总结图"><a class="markdownIt-Anchor" href="#总结图"></a> 总结图</h2><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210803171519038.png?raw=true" alt="image-20210803171519038"></p><p>tarfile: 镜像打包文件</p><ul><li>docker ps 查看当前容器</li><li>docker top 查看当前执行的容器</li><li>docker attach 进入当前容器的执行命令 (可能是终端)</li><li>docker exec 在该容器, 另其执行一个命令</li></ul><h2 id="docker-网络"><a class="markdownIt-Anchor" href="#docker-网络"></a> Docker 网络</h2><h3 id="信息交互原理"><a class="markdownIt-Anchor" href="#信息交互原理"></a> 信息交互原理</h3><p>docker是基于 client - serve. 即客户端 与 服务器.</p><p>Docker的守护进程运行在主机上, 通过Socket从客户端访问. 然后Docker守护进程将信息发送给特定的容器</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210729120543992.png?raw=true" alt="image-20210729120543992"></p><h3 id="docker-网卡"><a class="markdownIt-Anchor" href="#docker-网卡"></a> Docker 网卡</h3><p>docker安装时, 会默认安装一个网桥 <code>docker0</code> , 这个网桥是负责所有容器的信息交互.  同时 Docker 会随机分配一个本地未占用的私有网络段给 docker0. 用于为容器分配 IP 地址.</p><p>容器视 <code>docker0</code> 为路由器, <mark>由路由器负责转发给本机, 或者其他容器</mark></p><blockquote><p>macOS 和 Windows 没有 docker0, 但有其他的解决办法</p></blockquote><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210810102737175.png?raw=true" alt="image-20210810102737175" style="zoom: 33%;"><blockquote><p>Docker网络连接原理示意图</p></blockquote><p>采用 <code>evth-pair</code> 技术</p><p>每注册一个容器, 会创建一个 <code>veth pair</code> 互联接口, 其中</p><ul><li><p>veth 挂载在宿主主机中</p></li><li><p>eth0 则是挂载在容器内</p><blockquote><p>eth0 是第一个以太网接口, 这种类型的接口通常是通过5类电缆连接到网络的<code>网卡</code>。</p><p>eth0 无论在容器还是宿主内, 都应该存在, 不然无法与外网通信 (网卡都没了, 你还能上百度?)</p></blockquote></li></ul><p>veth 向 etho0 发送数据时, eth0 会自动收到相同的包. 而 eth0 向 veth 发送也是同理. 用上述技术实现容器和宿主通信.</p><h4 id="实际体验"><a class="markdownIt-Anchor" href="#实际体验"></a> 实际体验</h4><p>Linux 系统, 在运行 3 个容器</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20220414095510004.png?raw=true" alt="image-20220414095510004"></p><p>在宿主机中调用 ifconfig 命令</p><blockquote><p>ifconfig 命令 <a href="https://man7.org/linux/man-pages/man8/ifconfig.8.html">官方文档</a> 给出是列出所有与内核关联的 网络接口</p><p>而<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BB%8B%E9%9D%A2">网络接口</a>可以是</p><ul><li>网卡</li><li>一个网络与另一个网络间的互接点</li></ul></blockquote><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20220414095547656.png?raw=true" alt="image-20220414095547656" style="zoom:50%;"><p>可以发现真的有三个 veth 虚拟网络设备</p><h4 id="实际运用"><a class="markdownIt-Anchor" href="#实际运用"></a> 实际运用</h4><p>Linux环境下, 假设有一个 <code>Java</code> 环境容器, 以 <code>bridge</code> 方式运行. 但 <code>Java</code> 环境中的 <code>Spring Boot</code>  服务想访问宿主 <code>MySQL</code> 服务, 那要怎么做呢?</p><ol><li><p>查看 docker0 网卡地址</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shell中输入 ifconfig命令, 搜索docker0虚拟网卡的信息</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20220414094156126.png?raw=true" alt="image-20220414094156126"></p><ul><li>inet是 docker0 的网卡地址 172.17.0.1</li></ul></li><li><p>在 SpringBoot 服务中配置 MySQL地址</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://172.17.0.1:3306</span><br></pre></td></tr></table></figure><p>此时 Java 容器便可访问宿主的MySQL服务</p><blockquote><p>如果还不行, 建议检查 MySQL 是否开启远端服务, 要开启远端服务, 容器才能访问宿主.</p><p>因为容器与宿主, <mark>在网络上, 可视为两个独立的主机</mark>. 可以尝试用自己的电脑, 使用 MySQL连接工具, 对服务器上的 MySQL 进行连接, 若能连接成功, 那也意味着容器也能正常访问宿主(服务器)的 MySQL.</p></blockquote></li></ol><h3 id="模式"><a class="markdownIt-Anchor" href="#模式"></a> 模式</h3><ul><li>host</li></ul><p>容器的网络栈<mark>不会与本机的网络栈隔离</mark>, 容器不会有自己的IP地址. 容器与本机共用网络.</p><blockquote><p>对应的 -p 选项会被忽视, -p是将容器的端口映射到主机上. 容器用命名空间技术, 将自己的网络栈与主机的网络栈隔离</p></blockquote><p><code>host</code>网络驱动仅适用于Linux, 其余系统不支持</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx镜像, 用host模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保 Docker可以使用相应端口</span></span><br><span class="line">docker run -rm -d --network host --name my_nginx nginx</span><br></pre></td></tr></table></figure><ul><li>bridge</li></ul><blockquote><p>桥接网络</p><p><mark>本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接</mark>, 虚拟网卡与物理网卡<mark>位于同一网段</mark>.</p><p>对外看IP地址, 是有两台计算机(主机IP地址 + 虚拟机IP地址)</p><p>需手动配置虚拟机的IP地址, 应位于同一网段. docker有默认配置</p></blockquote><blockquote><p>补充NAT模式, 网络地址转换   (与主机访问网关的原理一样. 服务器是无法使用NAT模式, 不然客户端无法找到服务器)</p><p>虚拟机的网卡和物理网卡的网络，不在同一个网络.</p><p>虚拟机访问网站时, 是用本地主机的IP地址进行访问的, 而收到回复后, 本地网卡根据映射表 + 目的IP地址 + 端口号, 判断该回复是属于本地主机还是虚拟机.</p><p>缺点: 只有本地主机能访问到虚拟机, 局域网中其他主机, 无法访问虚拟机. 因为其他主机发送数据包给主机, 主机无法判断要发给主机还是虚拟机. 因为映射表中没有记录.</p><p>优点: 无需手动配置IP地址</p><p>其他主机认为虚拟机IP地址就是主机的IP地址, 没有办法区别虚拟机与主机的区别</p><p>而如果虚拟机先向其他主机发送信息, 虚拟机发送信息时, 主机中网卡将虚拟机的IP地址和端口映射为主机IP地址 + 随机端口号, 并将该映射记录在表中. 主机收到其他主机回复时, 看端口号就可区别是发送给主机还是虚拟机.</p></blockquote><p>容器的网络栈会被命名空间隔离, 需要通过bridge才能与主机的网络栈信息交互</p><blockquote><p>没有配置DNS, 除非使用–link选项, 只能使用IP地址沟通</p><p>其中bridge便是虚拟网卡. 即docker安装时, 额外安装的一个虚拟网卡.</p></blockquote><p>打开docker时, 默认的桥接网络会被自动的创建. 新开启的容器会默认自动与其连接</p><blockquote><p>可以自定义桥接网络, 自定义的桥接优先与默认的网络</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 自定义桥接网络</span></span><br><span class="line">docker network create \</span><br><span class="line">  --driver=bridge \</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 确立子网范围, 需确保虚拟机Ip地址与本机IP地址处于同一网段</span></span><br><span class="line">  --subnet=172.28.0.0/16 \</span><br><span class="line">  --ip-range=172.28.5.0/24 \</span><br><span class="line">  --gateway=172.28.5.254 \</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 该桥接网络名字叫br0</span></span><br><span class="line">  br0</span><br></pre></td></tr></table></figure><p>要是采用 docker-compose, 无需配置 link. 默认可以将服务名当成域名, 并进行容器间的访问</p><h4 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h4><p>有如下 docker-compose.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">nginx:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:80"</span></span><br><span class="line">    <span class="attr">java:</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9000:9000"</span></span><br></pre></td></tr></table></figure><blockquote><p>省略许多信息</p></blockquote><p>若想用 nginx 反向代理给 java 容器</p><p>nginx的配置文件可以是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http{</span><br><span class="line">    index    index.html index.htm index.php;</span><br><span class="line">    server {</span><br><span class="line">include /etc/nginx/mime.types;</span><br><span class="line">        # 设立监听端口</span><br><span class="line">        listen 80;</span><br><span class="line">        root /data/www;</span><br><span class="line"></span><br><span class="line">        location / {</span><br><span class="line">            try_files $uri $uri/ /index.html;       </span><br><span class="line">        }</span><br><span class="line">        location ^~ /api/ {</span><br><span class="line">            client_max_body_size 100m;</span><br><span class="line">            # 直接用 java 服务名, 作为域名, 对java容器进行访问</span><br><span class="line">            proxy_pass http://java:9000;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="docker-compose"><a class="markdownIt-Anchor" href="#docker-compose"></a> docker-compose</h2><h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4><p><mark>高效管理多个容器, 定义并运行多个容器.</mark></p><p>service: 容器</p><p>project: 一个对外服务的网页或者博客等</p><h4 id="步骤-2"><a class="markdownIt-Anchor" href="#步骤-2"></a> 步骤</h4><ol><li>定义用 dockerfile 定义项目环境, 如环境变量等. 将应用打包为镜像</li><li>用 yaml 文件描述需要打开的容器与关联情况等, 定义整个服务, 需要的环境</li><li>执行 docker-compose up 命令      需要在目录下有 docker-compose.yml 文件</li></ol><blockquote><p>注意: docker compose 是开源项目, 需要先安装</p></blockquote><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><ol><li><p>下载</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载是国内源 + --output是指定下载地址</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` --output /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><p>授权<br>+x权限</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker-compose地址</span></span><br><span class="line">chomd u+x chmod u+x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li></ol><h3 id="例子-2"><a class="markdownIt-Anchor" href="#例子-2"></a> 例子</h3><p>利用flask + redis创建一个网页, 显示网页打开的次数, 并利用docker部署</p><ol><li>编写flask的dockerfile</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP=app.py</span><br><span class="line"><span class="keyword">ENV</span> FLASK_RUN_HOST=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"flask"</span>, <span class="string">"run"</span>]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写docker-compose.yml</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体可以写的在命令可 参考官网https://docs.docker.com/compose/compose-file/compose-file-v3/</span></span><br><span class="line"><span class="comment"># docker compose的版本</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3.9"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="comment"># 等同于build命令构建镜像, 由于命名为Dockerfile, 可省略名字</span></span><br><span class="line">    <span class="comment"># 会扫描当前目录下的Dockerfile文件, 并调用docker build 命令</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">    <span class="comment"># 需要注意volumes的目录要支持文件共享 File sharing</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">   <span class="comment"># 可用image命令构建镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>执行命令 注意当前工作目录需要有docker-compose.yml文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当docker-compose.yml发生变动, 再次执行会更新</span></span><br></pre></td></tr></table></figure><p>关闭 docker-compose down  (要在docker-compose.yml的文件夹里)</p><h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4><p>若dockerfile或docker-compose.yml更新, 需要清除缓存与清除现有镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Build images before starting containers.</span></span><br><span class="line">docker-compose up --build</span><br><span class="line"><span class="meta">#</span><span class="bash"> Recreate containers even <span class="keyword">if</span> configuration/image hasn<span class="string">'t changed.</span></span></span><br><span class="line">docker-compose up --force-recreate</span><br><span class="line">docker-compose rm -f</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="自动默认操作"><a class="markdownIt-Anchor" href="#自动默认操作"></a> 自动默认操作</h4><p>执行完docker-compose.yml后, 会先执行build命令, 根据dockerfile创建或者网上拉取镜像</p><ul><li><p>默认的服务名 文件名_服务名_nums</p></li><li><p>镜像名: 文件名_服务名</p></li></ul><p>nums表示的是副本数量</p><h4 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h4><p>利用docker compose构建的容器, 都会位于同一子网, 可用域名访问. 而不是IP地址</p><h2 id="压缩镜像空间"><a class="markdownIt-Anchor" href="#压缩镜像空间"></a> 压缩镜像空间</h2><h3 id="将镜像底层-更换为-alpine"><a class="markdownIt-Anchor" href="#将镜像底层-更换为-alpine"></a> 将镜像底层 更换为 alpine</h3><p><code>Alpine</code> 操作系统是一个面向安全的轻型 <code>Linux</code> 发行版。它不同于通常 <code>Linux</code> 发行版, 很小</p><blockquote><p>代价是缺失很多命令, 出错调试非常难受</p></blockquote><p>常用于docker底层的镜像系统中</p><p>常用底层镜像一览</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG           IMAGE ID          VIRTUAL SIZE</span><br><span class="line">alpine              latest        4e38e38c8ce0      4.799 MB</span><br><span class="line">debian              latest        4d6ce913b130      84.98 MB</span><br><span class="line">ubuntu              latest        b39b81afc8ca      188.3 MB</span><br><span class="line">centos              latest        8efe422e6104      210 MB</span><br></pre></td></tr></table></figure><h4 id="alpine镜像-注意点"><a class="markdownIt-Anchor" href="#alpine镜像-注意点"></a> alpine镜像 注意点</h4><p>docker alpine镜像执行linux的可执行程序时, 会出现not found报错,</p><p>由于alpine镜像使用的是musl libc而不是gnu libc. 这种情况是因为<strong>动态链接库位置错误导致</strong></p><h4 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h4><ol><li><p>不用 Alpine，选择和编译环境一致的发行版；或者干脆在 Alpine 下编译运行。</p></li><li><p>给 Alpine 安装一个轻量的 glibc 兼容层 <a href="https://pkgs.alpinelinux.org/package/edge/main/x86_64/libc6-compat">libc6 compatibility package</a>: <code>apk add libc6-compat</code>。（对于简单的程序，兼容层足够解决问题，但是复杂的程序可能仍然无法正常运行）</p></li><li><p>给 Alpine 安装真正的 glibc。(网上嫖来的 <code>dockerfile</code> 写法)</p><blockquote><p>Linux系统接口有效</p></blockquote></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> GLIBC_REPO=https://github.com/sgerrand/alpine-pkg-glibc</span><br><span class="line"><span class="keyword">ENV</span> GLIBC_VERSION=<span class="number">2.30</span>-r0</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk --update add libstdc++ curl ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="keyword">for</span> pkg <span class="keyword">in</span> glibc-<span class="variable">${GLIBC_VERSION}</span> glibc-bin-<span class="variable">${GLIBC_VERSION}</span>; \</span></span><br><span class="line"><span class="bash">        <span class="keyword">do</span> curl -sSL <span class="variable">${GLIBC_REPO}</span>/releases/download/<span class="variable">${GLIBC_VERSION}</span>/<span class="variable">${pkg}</span>.apk -o /tmp/<span class="variable">${pkg}</span>.apk; <span class="keyword">done</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --allow-untrusted /tmp/*.apk &amp;&amp; \</span></span><br><span class="line"><span class="bash">    rm -v /tmp/*.apk &amp;&amp; \</span></span><br><span class="line"><span class="bash">    /usr/glibc-compat/sbin/ldconfig /lib /usr/glibc-compat/lib</span></span><br></pre></td></tr></table></figure><h2 id="docker出错查看原因"><a class="markdownIt-Anchor" href="#docker出错查看原因"></a> Docker出错查看原因</h2><p>docker容器启动秒挂, 咋整 ?</p><ol><li>利用docker ps -al 命令查看退出code.</li><li><mark>利用docker logs + 容器ID查看退出错误日志</mark></li></ol><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li>Docker技术入门与实战  第3版</li><li><a href="https://www.bilibili.com/video/BV1og4y1q7M4?spm_id_from=333.337.search-card.all.click">狂神说Java Docker最新超详细版教程通俗易懂</a></li><li><a href="https://docs.docker.com/network/">Docker Network官方文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker&quot;&gt;&lt;/a&gt; Docker&lt;/h2&gt;
&lt;p&gt;使用您提供的应用程序或服务的本地容器在标准化环境中工作.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我的理解是为每一个应用</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://chenyuanzhen.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP笔记</title>
    <link href="https://chenyuanzhen.github.io/2022/04/08/uploadMd/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/"/>
    <id>https://chenyuanzhen.github.io/2022/04/08/uploadMd/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-08T07:45:56.000Z</published>
    <updated>2022-04-13T02:11:43.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常识"><a class="markdownIt-Anchor" href="#常识"></a> 常识</h2><ul><li>URL 统一资源定位符</li><li>HTTP协议属于TCP/IP的应用层</li><li>RFC HTTP协议技术标准文档</li></ul><h2 id="uri-统一资源标识符"><a class="markdownIt-Anchor" href="#uri-统一资源标识符"></a> URI 统一资源标识符</h2><p>与URL很相似</p><h3 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h3><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105111858461.png?raw=true" alt="image-20220105111858461" style="zoom:80%;" /><p>常用协议有</p><ul><li>http / https</li><li>ftp</li></ul><p>查询字符串与片段标识符都为可选</p><h2 id="http协议"><a class="markdownIt-Anchor" href="#http协议"></a> HTTP协议</h2><p>用于客户端和服务器间通信.</p><p>HTTP协议, <mark>必须由客户端开始建立通信</mark></p><p>HTTP是无状态协议, 发送过的请求或响应, HTTP协议自身不要求做持久化处理</p><blockquote><p>使用Cookie可以管理状态</p></blockquote><h3 id="请求报文"><a class="markdownIt-Anchor" href="#请求报文"></a> 请求报文</h3><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105112339951.png?raw=true" alt="image-20220105112339951" style="zoom:50%;" /><blockquote><p><mark>首部 + 空行(\r\n) + 报文主体</mark></p><p>URI可以写完整的</p><p>可以写成简写 + Host:  上述为简写</p><p>request通常不含报文主体</p></blockquote><p>如果不是访问特定资源而是对服务器本身发起请求. 可用 * 代替请求URI</p><h4 id="可使用的方法"><a class="markdownIt-Anchor" href="#可使用的方法"></a> 可使用的方法</h4><ul><li><p>GET  获取资源</p></li><li><p>POST 传输实体主体</p></li><li><p>PUT 传输文件</p><blockquote><p>如FTP协议文件上传一样.</p><p>但PUT自身不带验证机制, 所有人都可上传文件, 一般Web网站不用或自带验证</p></blockquote></li><li><p>HEAD 获得报文首部</p><blockquote><p>GET请求, 但不返回报文主体</p></blockquote></li><li><p>DELETE 删除文件</p><blockquote><p>存在问题与PUT类似, 所以不常用</p></blockquote></li></ul><p>还有其他方法</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105143004032.png?raw=true" alt="image-20220105143004032" /></p><h3 id="响应报文"><a class="markdownIt-Anchor" href="#响应报文"></a> 响应报文</h3><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105112453911.png?raw=true" alt="image-20220105112453911" style="zoom:50%;" /><blockquote><p><mark>首部 + 空行(\r\n) + 报文主体</mark></p></blockquote><h3 id="持久连接"><a class="markdownIt-Anchor" href="#持久连接"></a> 持久连接</h3><p>只要任意一端, 没有明确提出断开连接，则保持 TCP 连接状态。</p><blockquote><p>HTTP keep-alive 或 HTTP connection reuse</p></blockquote><p>可以减少TCP连接的重复建立和断开时的额外开销.</p><h4 id="管线化"><a class="markdownIt-Anchor" href="#管线化"></a> 管线化</h4><p>用户不用等待响应也可直接发送下一个请求</p><h3 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h3><p>HTTP是无状态的, 但服务器可通过在请求和响应报文写入Cookie控制客户端状态</p><h4 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h4><ol><li>客户端发送请求, 服务器生成一个Cookie并返回给客户端.</li><li>客户端再请求时, 添加Cookie发送给服务器, 服务器根据Cookie判断客户端身份</li></ol><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105143620977.png?raw=true" alt="image-20220105143620977" style="zoom:50%;" /><blockquote><p>expires 过期时间</p></blockquote><h2 id="编码提升传输效率"><a class="markdownIt-Anchor" href="#编码提升传输效率"></a> 编码提升传输效率</h2><p>HTTP传送时, 服务器会将发送的内容进行压缩.</p><p>通用格式有</p><ul><li><p><strong>gzip</strong>（<strong>GNU zip</strong>）</p></li><li><p><strong>compress</strong>（<strong>UNIX</strong> 系统的标准压缩）</p></li><li><p><strong>deflate</strong>（<strong>zlib</strong>）</p></li><li><p><strong>identity</strong>（不进行编码）</p></li></ul><h3 id="分割发送的分块传输编码"><a class="markdownIt-Anchor" href="#分割发送的分块传输编码"></a> 分割发送的分块传输编码</h3><p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p><p>每一块都会有十六进制标记块大小, 实体主体最后一块使用 \r\n标记</p><h2 id="发送多种数据的多部分对象集合"><a class="markdownIt-Anchor" href="#发送多种数据的多部分对象集合"></a> 发送多种数据的多部分对象集合</h2><p>Content-Type: 允许</p><ul><li><p><strong>multipart/form-data</strong></p><blockquote><p>Web表单</p></blockquote></li><li><p><strong>multipart/byteranges</strong></p><blockquote><p>报文包含多个范围的内容</p><p>状态码为 206 Partial Content  表示响应报文的内容需要分段发送.</p></blockquote></li></ul><p>等其他内容</p><h2 id="http状态码"><a class="markdownIt-Anchor" href="#http状态码"></a> HTTP状态码</h2><p>告知从服务器返回的请求结果</p><ul><li><p>2开头表示正常</p></li><li><p>3开头表示网址转移,</p></li><li><p>4开头表示客户端错误</p><ul><li><strong>400 Bad Request</strong> 请求报文存在语法错误</li></ul></li><li><p>5开头表示服务器错误</p></li></ul><h2 id="http首部"><a class="markdownIt-Anchor" href="#http首部"></a> HTTP首部</h2><p>请求和响应报文一定包含HTTP首部</p><p>首部字段分为</p><blockquote><p>结构为</p><p>首部字段名: 字段值, 另一个值</p></blockquote><ul><li><p>通用首部</p>  <img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105151355727.png?raw=true" alt="image-20220105151355727" style="zoom:50%;" /></li><li><p>请求首部</p>  <img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105151411546.png?raw=true" alt="image-20220105151411546" style="zoom:50%;" /></li><li><p>响应首部</p>  <img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105151423987.png?raw=true" alt="image-20220105151423987" style="zoom:50%;" /></li><li><p>实体首部</p>  <img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105151437467.png?raw=true" alt="image-20220105151437467" style="zoom:50%;" /><blockquote><p>用于补充资料内容更新时间, 与实体相关的信息</p></blockquote></li></ul><h3 id="常用请求首部字段"><a class="markdownIt-Anchor" href="#常用请求首部字段"></a> 常用请求首部字段</h3><ul><li><p>Connection</p><ul><li>控制不再转发给代理的首部字段  Connection: 不再转发的首部字段名</li></ul><blockquote><p>代理: 客户端会将请求发送给服务器A(代理), 由服务器A发起请求, 并将结果返回给客户端</p></blockquote><ul><li><p>管理持久连接</p><p>Connection: close</p><blockquote><p>明确表示断开连接</p></blockquote><p>Connection: Keep-Alive</p><blockquote><p>HTTP/1.1之前的版本需显式指明, 维持持续连接</p></blockquote></li></ul></li><li><p>Via</p><p>用于跟踪客户端与服务器之间的请求和响应报文的传输路径</p><p>在经过代理时, 代理服务器应附加该首部字段的内容</p>  <img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105152336519.png?raw=true" alt="image-20220105152336519" style="zoom:50%;" /></li><li><p>Warning首部</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105152456429.png?raw=true" alt="image-20220105152456429" /></p></li><li><p>Accept</p><p>用户能够处理的媒体类型与优先级</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml;</span><br></pre></td></tr></table></figure><p>常见的选项</p>  <img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105152614174.png?raw=true" alt="image-20220105152614174" style="zoom:50%;" /></li><li><p>Accept-Encoding</p><p>客户端支持的内容编码</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><blockquote><p><strong>deflate</strong></p><p>组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法</p><p>（RFC1951）生成的编码格式。</p></blockquote></li><li><p><strong>Authorization</strong></p><p>用于告知服务器, 用户代理的认证信息</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dWVub3NlbjpwYXNzd29yZA==</span><br></pre></td></tr></table></figure></li><li><p><strong>Proxy-Authorization</strong></p><p>用于客户端与代理的验证</p></li><li><p>Host</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure><p>告知服务器，请求的资源所处的互联网主机名和端口号</p><blockquote><p><mark>HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段</mark></p></blockquote></li></ul><h3 id="常用实体首部字段"><a class="markdownIt-Anchor" href="#常用实体首部字段"></a> 常用实体首部字段</h3><ul><li><p>Content-Range</p><p>范围请求</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105153651775.png?raw=true" alt="image-20220105153651775" /></p><blockquote><p>仅发送字节 第5001到10000字节的内容</p></blockquote></li><li><p>Content-Type 实体主体内对象的媒体类型</p></li></ul><h3 id="请求报文-request"><a class="markdownIt-Anchor" href="#请求报文-request"></a> 请求报文 request</h3><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105150943642.png?raw=true" alt="image-20220105150943642" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为请求行 方法 + URI + HTTP版本</span></span><br><span class="line">GET / HTTP/1.1</span><br></pre></td></tr></table></figure><h3 id="响应报文-response"><a class="markdownIt-Anchor" href="#响应报文-response"></a> 响应报文 response</h3><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:25-image-20220105151106756.png?raw=true" alt="image-20220105151106756" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HTTP版本 状态</span></span><br><span class="line">HTTP/1.1 404 Not Found</span><br></pre></td></tr></table></figure><h2 id="https"><a class="markdownIt-Anchor" href="#https"></a> HTTPS</h2><p>HTTP存在以下问题</p><ul><li>使用明文传输, 内容可能被窃听</li><li>不验证通信方身份, 可能遭遇伪装</li><li>无法验证报文是否被篡改</li></ul><p>可以采用</p><p>SSL 安全套接层 或 TLS 安全层传输协议 加密HTTP通信内容 解决</p><p><mark><strong>HTTP+</strong> 加密 <strong>+</strong> 认证(证书) <strong>+</strong> 完整性保护 <strong>= HTTPS</strong></mark></p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220105155725316.png?raw=true" alt="image-20220105155725316" style="zoom:50%;" /><blockquote><p>HTTPS是身披 <strong>SSL</strong> 或 TLS 外壳的 <strong>HTTP</strong></p></blockquote><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220105155824298.png?raw=true" alt="image-20220105155824298" style="zoom:50%;" /><p>要求客户端和服务器同时具备加密和解密机制</p><h3 id="ssl"><a class="markdownIt-Anchor" href="#ssl"></a> SSL</h3><p>独立于HTTP协议, 可用于其他协议确保网络安全</p><p>通过证书手段确定通信方身份.</p><blockquote><p>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。</p></blockquote><p>客户端访问服务器时, 会向第三方公司确认服务器的证书. 客户端持有证书完成个人身份确认.</p><h4 id="加密方法-公开密匙加密"><a class="markdownIt-Anchor" href="#加密方法-公开密匙加密"></a> 加密方法   公开密匙加密</h4><p>公开密钥加密使用一对非对称的密钥。</p><ul><li><p>一把叫做私有密钥 （private key）</p><blockquote><p>私钥不能被其他人知道</p></blockquote></li><li><p>另一把叫做公开密钥（public key）</p></li></ul><p>公钥用于加密, 私钥用于解密.</p><h4 id="步骤-2"><a class="markdownIt-Anchor" href="#步骤-2"></a> 步骤</h4><ol><li>服务器将自己公开密钥登录到数字证书认证机构</li><li>数字证书认证机构用自己的密钥署数字签名并颁发公钥证书</li><li>服务器将证书与服务器的公钥发给客户端</li><li>客户端拿到证书后, 向数字证书认证数字签名, 确定公开密钥是真实的</li><li>客户端利用服务器公开密钥对报文加密</li><li>服务器再利用自己私有密钥解密客户端发来的信息</li></ol><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220105160827915.png?raw=true" alt="image-20220105160827915" style="zoom:50%;" /><p>核心</p><p>只有私密能解密, 私钥只有自己知道</p><p>公钥只能加密, 公钥随便给人看</p><ul><li>服务器将自己公钥上传给第三方数字证书机构, 获得证书</li><li>服务器将公钥和证书发给客户</li><li>客户拿着证书和公钥, 用浏览器内置数字证书的公钥, 与数字证书机构加密通信. 确认服务器公钥是ok的</li><li>客户端随机生成一段字符串, 用公钥机密传输给服务器,</li><li>服务器接受后, 与客户端通信改为用该字符串加密解密通信</li></ul><h2 id="tls"><a class="markdownIt-Anchor" href="#tls"></a> TLS</h2><p>前身是SSL, 是SSL的升级版. 步骤和上述SSL差不多</p><p>SSL是需要双方已经确定下公钥, 一方有私钥, (公钥需要自己确保正确性)</p><p>而TLS则是引入第三方, 确保公钥是正确的, 而不是被修改的</p><h3 id="https的缺陷"><a class="markdownIt-Anchor" href="#https的缺陷"></a> HTTPS的缺陷</h3><p>使用SSL, 需要不断的加密解密, 自然与HTTP相比, 速度会慢, 网络负载可能会变慢 2 到 100 倍, 但能保证信息是安全的,</p><p>另外, 配置HTTPS是需要向认证机构购买证书的</p><h3 id="中间人攻击-mitm"><a class="markdownIt-Anchor" href="#中间人攻击-mitm"></a> 中间人攻击 MITM</h3><p>请求或响应在传输涂中, 遭到攻击者拦截并篡改内容</p><p>可以通过MD5和SHA-1等散列值校验方法, 验证报文是未经修改的</p><h2 id="确认访问用户身份的认证"><a class="markdownIt-Anchor" href="#确认访问用户身份的认证"></a> 确认访问用户身份的认证</h2><p>需要知晓客户端是否为本人操作</p><p>HTTP/1.1提供的认证方式有</p><ul><li><p>BASIC认证</p><blockquote><p>密码验证</p></blockquote></li><li><p>DIGEST认证</p></li><li><p>SSL客户端认证</p><blockquote><p>利用客户端证书,</p><p>不常用, 需要客户自行安装证书.</p><p>客户端证书也要钱!!!</p></blockquote></li><li><p>FormBase认证</p><blockquote><p><strong>由服务器自行验证</strong></p></blockquote></li></ul><h2 id="session与cookie"><a class="markdownIt-Anchor" href="#session与cookie"></a> Session与Cookie</h2><p>一般会使用Cookie来管理Session</p><blockquote><p>Cookie中放置SessionID.</p></blockquote><p>需要注意, SessionID若被第三方盗走, 那么对方可以伪装身份, 进行恶意操作.</p><ul><li><p>Cookie是存储在浏览器中, 可以理解为页面或response要求浏览器存储一些信息</p></li><li><p>SessionID则是存储在后端服务器的, 但由于HTTP协议是无状态的, 所以后端服务器依靠浏览器提供身份信息(即Cookie中的sessionID信息)</p><blockquote><p>无状态, 这次请求与之前的请求是没有关系的</p></blockquote></li></ul><p>若禁用cookie, 那么可以要求浏览器每次访问时, 带着sessionID. 通过URL带参的方式, 将sessionID传给后端.</p><blockquote><p>sessionId可理解为是token</p></blockquote><p>使用cookie步骤</p><ol><li><p>客户端发送request给服务端</p></li><li><p>服务端为该客户端建立一个session, 并在Response中包含<code>set-Cookie</code>头部, 该头部的值包含<code>token</code></p></li><li><p>浏览器接受后该Response后, 后续浏览器对该服务器的访问都会携带cookie</p><blockquote><p>cookie中包含<code>token</code>, 浏览器通过识别该<code>token</code>, 找到客户端对应的session</p></blockquote></li></ol><h2 id="dns劫持"><a class="markdownIt-Anchor" href="#dns劫持"></a> DNS劫持</h2><p>DNS是域名解析系统, 域名解析将DNS改为IP地址.</p><p>DNS劫持则是通过模拟虚假的DNS服务器, 将域名转化为错误的IP地址. 从而用户用正确的域名却访问的错误的网页.</p><h4 id="识别方法"><a class="markdownIt-Anchor" href="#识别方法"></a> 识别方法</h4><ul><li>手机的DNS地址</li><li>路由器的DNS地址</li></ul><ol><li>DNS劫持得到的IP地址跟源IP地址一定是不同的</li><li>DNS劫持的网站, 通常会有多次跳转</li></ol><p>安全管家事先内置一个IP地址,用加密通信的方式, 请求外部服务器访问DNS服务器, 那么能得到正确的IP地址, 并和现在浏览器访问的IP地址进行校. 若无法外部服务器无法连接或IP地址不正确, 则有问题, 提出警告.</p><h4 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h4><ul><li><p>既然DNS有误, 那直接用IP地址上网即可</p></li><li><p>只使用HTTPS协议进行连接, HTTPS协议会向第三方证书机构认证信息, 服务器身份会被识破</p></li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li>图解HTTP</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#常识&quot;&gt;&lt;/a&gt; 常识&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;URL 统一资源定位符&lt;/li&gt;
&lt;li&gt;HTTP协议属于TCP/IP的应用层&lt;/li&gt;
&lt;li&gt;RFC HTTP协议技术标准文档&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leetCode刷题笔记-2</title>
    <link href="https://chenyuanzhen.github.io/2022/04/08/uploadMd/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://chenyuanzhen.github.io/2022/04/08/uploadMd/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2/</id>
    <published>2022-04-08T03:28:30.000Z</published>
    <updated>2022-04-13T02:11:43.437Z</updated>
    
    <content type="html"><![CDATA[<h4 id="287-寻找重复数"><a class="markdownIt-Anchor" href="#287-寻找重复数"></a> <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><p>该题取值范围已经确定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 若采用枚举的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> target <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">  <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">   <span class="comment"># 检查target是否出现在num中, 并且出现次数 &gt;=2 </span></span><br></pre></td></tr></table></figure><p>该题可以考虑二分搜索, 因为取值范围已经确定.</p><p>要依据什么条件将取值范围分为两半呢?</p><p><mark>即有什么条件可以让我们选择另一边而抛弃另一边呢?</mark></p><blockquote><p>这是二分搜索的核心.</p></blockquote><p>切入角度可以尝试看看枚举时, 是怎么判断当前枚举值是否为答案</p><p>题目要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>空间, 是不可能统计每一个数字的出现次数,</p><p>但我们可以统计 &lt; 枚举值的数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>有多少, 以及 &gt; 枚举值的数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>i</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">big</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>有多少.</p><p>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>+</mo><mi>b</mi><mi>i</mi><mi>g</mi><mo>+</mo><mn>1</mn><mo>=</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">low + big + 1 == nums.length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>, 说明枚举值不重复, 若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">!</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">!=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>则说明是可能是重复的, 还要检查枚举值是否出现在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>中.</p><p>若数组中不含重复的数字, 那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">定</mi><mo>=</mo><mo>=</mo><mi mathvariant="normal">枚</mi><mi mathvariant="normal">举</mi><mi mathvariant="normal">值</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">low 是一定 == 枚举值 - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">定</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">枚</span><span class="mord cjk_fallback">举</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>. 但若$low &gt;= 枚举值 $, 说明重复的数字小于枚举值.</p><p>可以根据这个条件, 每次将答案范围缩小一半.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> big = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> isExist = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// nums[mid], 检查 &lt; nums[mid]的数字, 若小于的数字 &gt;= mid, 说明mid是重复的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt; mid) &#123;</span><br><span class="line">                    ++low;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; mid) &#123;</span><br><span class="line">                    ++big;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    isExist = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">if</span>(low + big + <span class="number">1</span> != nums.length &amp;&amp; isExist) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(low &gt;= mid) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="另一种作法"><a class="markdownIt-Anchor" href="#另一种作法"></a> 另一种作法</h5><p>需要用到Floyed判圈法. 可以将数组元素视为节点. 节点的val = 索引, 而next = [索引].</p><p>那么从0号节点开始遍历, 由于存在重复的元素, 意味着, 该链是有环的. 而环进入节点的next就是重复值</p><p>Floyed算法步骤</p><p>设立慢, 快指针</p><ul><li>快指针一次走两个节点</li><li>慢指针一次走一个节点</li></ul><p>两者相遇时, 快慢指针合为为一, 另设一个指针A从起始点出发.</p><p>指针A与快慢指针每次只走一步, 当两者碰面时, 为环的进入点.</p><h4 id="1182-与目标颜色间的最短距离"><a class="markdownIt-Anchor" href="#1182-与目标颜色间的最短距离"></a> <a href="https://leetcode-cn.com/problems/shortest-distance-to-target-color/">1182. 与目标颜色间的最短距离</a></h4><p>该题一开始很容易能想到用动态规划做</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo stretchy="false">]</mo><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">引</mi><mi>i</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">达</mi><mi mathvariant="normal">左</mi><mi mathvariant="normal">边</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">短</mi><mi mathvariant="normal">距</mi><mi mathvariant="normal">离</mi><mspace linebreak="newline"></mspace><mi mathvariant="normal">若</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo separator="true">,</mo><mi mathvariant="normal">则</mi><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn><mspace linebreak="newline"></mspace><mi mathvariant="normal">若</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">于</mi><mo separator="true">,</mo><mi mathvariant="normal">则</mi><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[i][color]表示索引i到达左边color的最短距离 \\若colors[i] == color, 则dp[i][color] = 0 \\若不等于, 则dp[i][color] = dp[i - 1][color] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">引</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">达</span><span class="mord cjk_fallback">左</span><span class="mord cjk_fallback">边</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">短</span><span class="mord cjk_fallback">距</span><span class="mord cjk_fallback">离</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">若</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">若</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>但是<mark>只能解决左边,</mark> 右边该怎么办呢?</p><p>如</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi mathvariant="normal">若</mi><mi mathvariant="normal">出</mi><mi mathvariant="normal">现</mi><mi mathvariant="normal">询</mi><mi mathvariant="normal">问</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">引</mi><mn>4</mn><mi mathvariant="normal">出</mi><mi mathvariant="normal">发</mi><mo separator="true">,</mo><mi mathvariant="normal">离</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">近</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mn>3</mn><mi mathvariant="normal">的</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">短</mi><mi mathvariant="normal">距</mi><mi mathvariant="normal">离</mi><mi mathvariant="normal">是</mi><mo stretchy="false">?</mo></mrow><annotation encoding="application/x-tex">colors = [1, 1, 2, 1, 3, 2, 2, 3, 3] \\若出现询问索引4出发, 离最近color3的最短距离是?</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">若</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">询</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">引</span><span class="mord">4</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">发</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">离</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">近</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">3</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">短</span><span class="mord cjk_fallback">距</span><span class="mord cjk_fallback">离</span><span class="mord cjk_fallback">是</span><span class="mclose">?</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[4][3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span></span></span></span>只会考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span>, 而不会考虑后面的3.</p><p><mark>若一个dp数组无法解决, 那就两个</mark></p><p>增加一个dp数组, 从右往左遍历</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo stretchy="false">]</mo><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">引</mi><mi>i</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">达</mi><mi mathvariant="normal">右</mi><mi mathvariant="normal">边</mi><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">短</mi><mi mathvariant="normal">距</mi><mi mathvariant="normal">离</mi></mrow><annotation encoding="application/x-tex">dpRight[i][color]表示索引i到达右边color的最短距离</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">引</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">达</span><span class="mord cjk_fallback">右</span><span class="mord cjk_fallback">边</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">短</span><span class="mord cjk_fallback">距</span><span class="mord cjk_fallback">离</span></span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">shortestDistanceColor</span><span class="params">(<span class="keyword">int</span>[] colors, <span class="keyword">int</span>[][] queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dpLeft = <span class="keyword">new</span> <span class="keyword">int</span>[colors.length][<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] dpRight = <span class="keyword">new</span> <span class="keyword">int</span>[colors.length][<span class="number">4</span>];</span><br><span class="line">      <span class="comment">// 细节点, 若是将不可达视为-1, 由于最后是利用Math.min求左右两边的最短距离, -1表示不可达, 是不能选的, 只有当两边同时是-1, 答案才会是-1, 但Math.min却会优先选择-1. </span></span><br><span class="line">        <span class="keyword">int</span> MAXVALUE = <span class="number">10000000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> color = <span class="number">1</span>; color &lt;= <span class="number">3</span>; ++color) &#123;</span><br><span class="line">            dpLeft[<span class="number">0</span>][color] = MAXVALUE;</span><br><span class="line">            dpRight[colors.length - <span class="number">1</span>][color] = MAXVALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        dpLeft[<span class="number">0</span>][colors[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        dpRight[colors.length - <span class="number">1</span>][colors[colors.length - <span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> color = <span class="number">1</span>; color &lt;= <span class="number">3</span>; ++color) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; colors.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[i] == color) &#123;</span><br><span class="line">                    dpLeft[i][color] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dpLeft[i][color] = dpLeft[i - <span class="number">1</span>][color] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = colors.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[i] == color) &#123;</span><br><span class="line">                    dpRight[i][color] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dpRight[i][color] = dpRight[i + <span class="number">1</span>][color] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = Math.min(dpLeft[queries[i][<span class="number">0</span>]][queries[i][<span class="number">1</span>]], dpRight[queries[i][<span class="number">0</span>]][queries[i][<span class="number">1</span>]]); </span><br><span class="line">          <span class="comment">// 判断是否可达</span></span><br><span class="line">            output.add(value &gt;= MAXVALUE ? -<span class="number">1</span> : value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1901-找出顶峰元素-ii"><a class="markdownIt-Anchor" href="#1901-找出顶峰元素-ii"></a> <a href="https://leetcode-cn.com/problems/find-a-peak-element-ii/">1901. 找出顶峰元素 II</a></h4><p>最为朴素的想法是, 逐个遍历整个网格, 检查每一个网格上下左右, 观察其是否为顶峰. 但时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><p>为什么没有想到二分查找?</p><p>我一直认为二分查找仅适用于<mark>具有单调性</mark>的数列. 而网格中全是乱序的, 而且与位置有关, 不得使用排序. 所以没有考虑用到二分.</p><p>回看问题, 题目仅要求返回<mark>任意一个</mark>顶峰位置.</p><blockquote><p>尝试将数组分为有顶峰部分和无顶峰部分, 由于题目只要求<mark>任意一个</mark>, <mark>所以有顶峰部分若存在多个, 选择一个即可.</mark></p><p>优化穷举的好帮手.</p></blockquote><p>若数组仅有一维.</p><p>如</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 5,2,-2,10,8,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p><p>找出一维数组的峰值</p><p>我们可以先取其中值-2, 可以看见左边是2, 右边是10, 那么峰值在左边和右边都存在. 我们仅用选择一边即可. 选择左边. 数组变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, 5, 2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span>再取其中值, 可以发现5是峰值.</p><p>回到二维数组. 我们可以取中间一列的数组, 取其最大值, 保证上下是符合峰值条件的, 再看起左右两边. 若存在比其大的元素, 将数组缩小为左边或右边. 不断重复步骤</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220406202409912.png?raw=true" alt="image-20220406202409912" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">        Pair(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        Pair() &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findPeakGrid(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line">        <span class="comment">// left, right维护两列, 取中间一列, 找到该列元素最大值, 检查该列元素左右两边</span></span><br><span class="line">        <span class="comment">// 若左或右边, 有比该元素大的, 则right = mid或 left = mid. 说明[left, mid - 1]中的列, 一定存在顶峰元素</span></span><br><span class="line">        <span class="comment">// 重复如此</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, mid&#125;;</span><br><span class="line">            <span class="comment">// 取出mid列的最大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(maxVal &lt; mat[i][mid]) &#123;</span><br><span class="line">                    maxVal = mat[i][mid];</span><br><span class="line">                    pos[<span class="number">0</span>] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查左右两边</span></span><br><span class="line">            <span class="keyword">int</span> leftVal = mid - <span class="number">1</span> &gt;= <span class="number">0</span> ? mat[pos[<span class="number">0</span>]][mid - <span class="number">1</span>] : -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> rightVal = mid + <span class="number">1</span> &lt; mat[<span class="number">0</span>].length ? mat[pos[<span class="number">0</span>]][mid+ <span class="number">1</span>] : -<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(leftVal &lt; mat[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]] &amp;&amp; rightVal &lt; mat[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (leftVal &gt; mat[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="310-最小高度树"><a class="markdownIt-Anchor" href="#310-最小高度树"></a> <a href="https://leetcode-cn.com/problems/minimum-height-trees/">310. 最小高度树</a></h4><p>该题可以转换为给一无向图, 找出从某些节点, 从这些节点出发, 到达其余所有节点需要的广搜次数是最少的.</p><p>高度要最小, 意味着每一层都要容纳尽量多的节点. 最小高度树已经在图中, 我们可以不断剥去图中的叶子, 当最后剥无可剥, 在剥去叶子则无节点的情况下, 为所求.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] isVisit = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] du = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            map.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建无向图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; ++i) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = map.get(edges[i][<span class="number">0</span>]);</span><br><span class="line">            list.add(edges[i][<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">            list = map.get(edges[i][<span class="number">1</span>]);</span><br><span class="line">            list.add(edges[i][<span class="number">0</span>]);</span><br><span class="line">            ++du[edges[i][<span class="number">0</span>]];</span><br><span class="line">            ++du[edges[i][<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lave = n;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 收集入度为1的节点, 即叶子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(du[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                isVisit[i] = <span class="keyword">true</span>;</span><br><span class="line">                --lave;</span><br><span class="line">                queue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) &#123;</span><br><span class="line">            queue.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> queue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lave == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> queue;</span><br><span class="line">        <span class="keyword">int</span> tail = queue.getLast();</span><br><span class="line">        <span class="comment">// 开始往内遍历</span></span><br><span class="line">        <span class="comment">// 当所有节点已经进入过队列时, 弹出</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> front = queue.getFirst();</span><br><span class="line">            queue.removeFirst();</span><br><span class="line">            <span class="keyword">for</span>(Integer neighbor : map.get(front)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!isVisit[neighbor]) &#123;</span><br><span class="line">                    --du[neighbor];</span><br><span class="line">                    <span class="keyword">if</span>(du[neighbor] == <span class="number">1</span>) &#123;</span><br><span class="line">                        --lave;</span><br><span class="line">                        isVisit[neighbor] = <span class="keyword">true</span>;</span><br><span class="line">                        queue.add(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tail == front) &#123;</span><br><span class="line">                tail = queue.getLast();</span><br><span class="line">                <span class="keyword">if</span>(lave &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5219-每个小孩最多能分到多少糖果"><a class="markdownIt-Anchor" href="#5219-每个小孩最多能分到多少糖果"></a> <a href="https://leetcode-cn.com/problems/maximum-candies-allocated-to-k-children/">5219. 每个小孩最多能分到多少糖果</a></h4><p>解题一般有两种思路</p><ol><li><p>构建, 通过推导得到答案, 通常</p><ul><li>时间复杂度低</li><li>难想</li></ul></li><li><p>枚举搜索, 通过排除得到答案, 通常</p><ul><li><p>时间复杂度高</p><blockquote><p>不过可通过剪枝或二分搜索降低枚举搜索</p></blockquote></li><li><p>比较容易想到</p></li></ul></li></ol><p>该题采用枚举搜索 + 二分查找</p><p>观察最大糖果数目的取值范围</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">output \in [1, sum(candies)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p><blockquote><p>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">(</mo><mi>c</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k &gt; sum(candies)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span>, 那么output只能为0.</p></blockquote><p>求的是最大糖果数目, 且题目条件是满足单调性, 所以可以尝试使用二分</p><blockquote><p>不会存在有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a &gt; b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>., 每个小朋友可以分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>颗, 而不可以分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>颗的情况</p></blockquote><ol><li>枚举每个小朋友分的糖果数</li><li>遍历<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">candies</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span>, 判断可以做到<ul><li>若可以分, 则扩大每个小朋友分的糖果数</li><li>不可, 则缩小</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumCandies</span><span class="params">(<span class="keyword">int</span>[] candies, <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> candie:candies) &#123;</span><br><span class="line">            right += candie;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 右边界是不可到达的</span></span><br><span class="line">        right += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 此处[left, right)</span></span><br><span class="line">        <span class="keyword">while</span>(right - left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 去中间</span></span><br><span class="line">            <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">long</span> tmpK = k; </span><br><span class="line">            <span class="comment">// 检查每个小孩能否被分mid个糖果</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candies.length; ++i) &#123; </span><br><span class="line">                tmpK -= candies[i] / mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmpK &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1606-找到处理最多请求的服务器"><a class="markdownIt-Anchor" href="#1606-找到处理最多请求的服务器"></a> <a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/">1606. 找到处理最多请求的服务器</a></h4><p>该题基本步骤如下</p><ol><li>找到当前空闲的服务器, 并组成列表<code>freelist</code></li><li>在<code>freelist</code>寻找第一个大于等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mi mathvariant="normal">%</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i\%k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>的服务器Id<ul><li>若<code>freelist</code>为空, 该任务被抛弃</li></ul></li></ol><p>遍历所有任务, 并对其执行上述步骤</p><p>完成第一步, 采用遍历方法时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>但可以采用优先队列, 即堆优化. , 时间复杂度变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><blockquote><p>根据服务器的结束任务时间进行排序, 堆顶是最先结束的服务器Id</p></blockquote><p>完成第二步, 可以用二分搜索优化, 用TreeSet维护空闲服务器Id,  总时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pair</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> endTime;</span><br><span class="line">        Pair(<span class="keyword">int</span> id, <span class="keyword">int</span> endTime) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.endTime = endTime;</span><br><span class="line">        &#125;</span><br><span class="line">        Pair() &#123;&#125;;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pair o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.endTime - o.endTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">busiestServers</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] arrival, <span class="keyword">int</span>[] load)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用优先队列, 即堆, 维护【服务器，结束时间】</span></span><br><span class="line">        <span class="comment">// 每次处理一个请求, 现从堆中弹出, 结束时间小于请求开始时间的服务器列表list. 若堆顶大于,则表示无</span></span><br><span class="line">        <span class="comment">// 查看(i%k),是否能在list中找到, 找第一个大于等于(i%k), 若不存在,则返回第0个</span></span><br><span class="line">        <span class="comment">// 更新堆信息,</span></span><br><span class="line">        PriorityQueue&lt;Pair&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i &lt; k; ++i) &#123;</span><br><span class="line">            heap.add(<span class="keyword">new</span> Pair(i, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxCounter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] counters = <span class="keyword">new</span> <span class="keyword">int</span>[arrival.length];</span><br><span class="line">        TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrival.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!heap.isEmpty() &amp;&amp; heap.peek().endTime &lt;= arrival[i]) &#123;</span><br><span class="line">                treeSet.add(heap.poll().id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!treeSet.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> find = i % k;</span><br><span class="line">                Integer runId = treeSet.ceiling(find);</span><br><span class="line">                <span class="keyword">if</span>(runId == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runId = treeSet.first();</span><br><span class="line">                &#125;</span><br><span class="line">                treeSet.remove(runId);</span><br><span class="line">                counters[runId] += <span class="number">1</span>;</span><br><span class="line">                maxCounter = Math.max(maxCounter, counters[runId]);</span><br><span class="line">                heap.add(<span class="keyword">new</span> Pair(runId, arrival[i] + load[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counters.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(counters[i] == maxCounter) &#123;</span><br><span class="line">                lists.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="560-和为-k-的子数组"><a class="markdownIt-Anchor" href="#560-和为-k-的子数组"></a> <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h4><p>该题本以为可用双指针作法, 但不行. 因为数组的数字允许为负数.</p><p>若是仅为正数的情况下</p><p>左指针左移, sum一定减小或不变</p><p>右指针右移, sum一定增加或不变</p><p>所以当</p><ul><li><p>sum &gt; k时, 移动左指针</p></li><li><p>sum &lt; k时, 移动右指针</p></li></ul><p>但有负数</p><p>左指针左移, 如果移出</p><ul><li>负数, sum会增加,</li><li>正数, sum会减少</li></ul><p>右指针右移, 移入同理, 不知道未来sum会增加或减少</p><blockquote><p>移出或移入0不变.</p></blockquote><p>不满足单调性, 所以不能采用双指针.</p><p>而见到 <code>子数组</code>, <code>和为k</code>. 可以联想到前缀和</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>s</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo><mspace width="1em"/><mo stretchy="false">(</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sums[i] = sum[i-1]+nums[i] \\sums[i] = nums[0,j] + nums[j, i]\quad(其中 0 \leq j \leq i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></span></p><p>根据上述式子, 我们要求和为k的子数组, 可以转化为求</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">设</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>k</mi><mspace linebreak="newline"></mspace><mi mathvariant="normal">有</mi><mi>s</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>k</mi><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">设nums[j, i] =k\\有sums[i] - k = nums[0,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">设</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">有</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p><p>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[0, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashmap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="comment">// 前缀和为0的数组个数有1个</span></span><br><span class="line">        hashmap.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// preSum = sums[i]</span></span><br><span class="line">        <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            preSum += nums[i];</span><br><span class="line">          <span class="comment">// 查询是否有前缀和为sums[0, j] = sums[i] - k</span></span><br><span class="line">            <span class="keyword">if</span>(hashmap.containsKey(preSum - k)) &#123;</span><br><span class="line">                counter += hashmap.get(preSum - k);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 维护前缀和Map, 将当前前缀和结果记录</span></span><br><span class="line">            hashmap.put(preSum, hashmap.getOrDefault(preSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="995-k-连续位的最小翻转次数"><a class="markdownIt-Anchor" href="#995-k-连续位的最小翻转次数"></a> <a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数</a></h4><p>该题有一个贪心解法,</p><p>即从左往右遍历, 不断翻转数组, 若其中出现0, 则对其以它位置为开头, k连续位翻转.</p><p>如果模拟, 那么时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p><blockquote><p>假设数据变态, 每翻转一次后一位都变0</p></blockquote><p>数据量是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>. 复杂度最高只能是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>. 而该题可以采用差分的方法, 将翻转操作变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><p>差分数组</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi mathvariant="normal">已</mi><mi mathvariant="normal">经</mi><mi mathvariant="normal">修</mi><mi mathvariant="normal">改</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">的</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d[i] = nums[i] - nums[i - 1] \\nums[i] = d[i] + nums[i - 1] (已经修改过的)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">经</span><span class="mord cjk_fallback">修</span><span class="mord cjk_fallback">改</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">的</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 步骤如下</span></span><br><span class="line">    <span class="comment">// 计算的到差分数组d</span></span><br><span class="line">    <span class="comment">// 遍历数组元素i， 先将i复原， 若i为0，则对差分数组区间修改，最后检查一次数组是否全1</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 差分数组</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">d</span> (nums.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        d[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            d[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> origin;</span><br><span class="line">            <span class="comment">// 尝试复原</span></span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                origin = d[i] + nums[i <span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                origin = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试翻转</span></span><br><span class="line">            <span class="keyword">if</span>(origin % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; i + k &lt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ++step;</span><br><span class="line">                d[i] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i + k &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">                    d[i + k] -= <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> isAllOne = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 验证无法翻转的位数是否为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> origin = d[i] + nums[i <span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(origin % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                isAllOne = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isAllOne ? step : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;287-寻找重复数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#287-寻找重复数&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/find-the-duplicate-number/&quot;</summary>
      
    
    
    
    
    <category term="算法" scheme="https://chenyuanzhen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetCode刷题笔记-1</title>
    <link href="https://chenyuanzhen.github.io/2022/04/08/uploadMd/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://chenyuanzhen.github.io/2022/04/08/uploadMd/leetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-1/</id>
    <published>2022-04-08T02:31:54.000Z</published>
    <updated>2022-04-13T02:11:43.440Z</updated>
    
    <content type="html"><![CDATA[<h4 id="41-缺失的第一个正数"><a class="markdownIt-Anchor" href="#41-缺失的第一个正数"></a> 41. <a href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></h4><p>该题难在限制条件, 空间复杂度O(1). 时间复杂度是O(n)</p><p>首先时间复杂度是无法再下降, 因无论如何都要遍历一次数组, 才能确定答案. 但前提是需要记录信息, 才能保证时间复杂度是O(n).</p><ul><li><p>若能知道某个数字是否在该数组中出现, 那只要遍历一次数组不断询问, 在不考虑是如何实现知道的情况下, 时间复杂度能达到O(n)</p><blockquote><p>利用哈希表, 能在时间复杂度O(n)情况下, 知道某个数字在数组中出现. 但空间复杂度自然也是O(n).</p></blockquote></li></ul><p>再观察答案的输出范围</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, nums.length+ 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><p>为什么? 考虑极端情况, 当输出答案是nums.length + 1时, 意味着nums数组一定包含[1, nums.length]中所有数字. 不然输出答案不可能是这个.</p><p>基于上述情况, 可以将原数组作为哈希需要的空间. 哈希函数也很简单, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[nums[i] - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>, 即将数字对应的索引上的数字置为负数. 需要处理以下情况</p><ul><li><p>abs(数字) &gt; nums.length</p><p>那么该数字不会影响到答案, 直接无视</p></li><li><p>abs(数字) &lt; nums.length</p><p>将数字对应的索引上的数字置为负数</p></li></ul><blockquote><p>利用abs函数, 可以无视哈希函数对原数组的修改.</p><p>负数和0, 不会影响到答案, 先将其置为无穷大, 再考虑即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                nums[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(nums[i]) &lt;= nums.length) &#123;</span><br><span class="line">              <span class="comment">// 只打一次标记即可</span></span><br><span class="line">                <span class="keyword">if</span>(nums[Math.abs(nums[i]) - <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">                    nums[Math.abs(nums[i]) - <span class="number">1</span>] *= -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出答案, 那么原数组中只要数字&gt;0, 说明索引对应的数字没有出现过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="76-最小覆盖子串"><a class="markdownIt-Anchor" href="#76-最小覆盖子串"></a> <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>该题属于滑动窗口.</p><p>利用左指针和右指针确定一个子串.</p><ol><li><p>先将右指针移动到涵盖t所有字符的位置.</p></li><li><p>再移动左指针, 直到不符合条件.</p><blockquote><p>那么就能得到一个符合要求的子串的长度, 在比较其长度即可</p></blockquote></li></ol><h4 id="51-n-皇后"><a class="markdownIt-Anchor" href="#51-n-皇后"></a> <a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h4><p>每一行必须要有一个皇后, 所以遍历每一行,并在其中选定一个位置.</p><p>时间复杂度计算: 第一行有n个选择, 而第二行有n-1个选择(当然要少于n-1), 第三行有n-2个选择…</p><p>使用的是回溯法, 那么遍历时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>=</mo><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n*(n-1)*(n-2)... =n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span></p><p>优化的步骤是:</p><p>利用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的时间知晓该格子能否放置.</p><p>左斜线可用row - col确定唯一一条左斜线</p><p>右斜线可用row + col确定唯一一条右斜线</p><p>遍历时维护左斜线和右斜线即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] map;</span><br><span class="line">    Set&lt;Integer&gt; colLine= <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; leftLine = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; rightLine = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !leftLine.contains(row - col) &amp;&amp; !colLine.contains(col) &amp;&amp; !rightLine.contains(row + col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; possible = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; ++i) &#123;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map[i].length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(map[i][j])</span><br><span class="line">                    builder.append(<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    builder.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            possible.add(builder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        output.add(possible);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == map.length) &#123;</span><br><span class="line">            addOutput();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(row, j)) &#123;</span><br><span class="line">                map[row][j] = <span class="keyword">true</span>;</span><br><span class="line">                leftLine.add(row - j);</span><br><span class="line">                rightLine.add(row + j);</span><br><span class="line">                colLine.add(j);</span><br><span class="line">                find(row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                map[row][j] = <span class="keyword">false</span>;</span><br><span class="line">                leftLine.remove(row - j);</span><br><span class="line">                rightLine.remove(row + j);</span><br><span class="line">                colLine.remove(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        find(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="253-会议室-ii"><a class="markdownIt-Anchor" href="#253-会议室-ii"></a> <a href="https://leetcode-cn.com/problems/meeting-rooms-ii/">253. 会议室 II</a></h4><h5 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h5><p>问题可<mark>转为同一时刻中, 有多少个会议在进行</mark>, 求其最值为所求.</p><h5 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h5><p>模拟,</p><p>每遇见一个会议, 先检查有无空闲的会议室</p><ul><li>无, 则需要创建一间</li><li>有, 直接使用空闲的会议室</li></ul><p>可花费<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>时间寻找空闲会议室</p><blockquote><p>k为会议室个数. 最多为n</p><p>n为会议个数</p></blockquote><p>但可用优先队列(即最小堆), 维护最先被使用完的会议室.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        queue.add(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.peek() &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-四数之和"><a class="markdownIt-Anchor" href="#18-四数之和"></a> <a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4><p>解法很简单</p><p>枚举两个数, 然后剩余两个数用双指针完成.</p><p>但这道题要命的是, <mark>不重复的四元祖</mark>.</p><blockquote><p>而且与顺序无关!</p></blockquote><p>一般解决不重复的问题</p><ol><li><p>用set去重</p><blockquote><p>但该题与顺序无关 答案[0, 0, -1, 1] 与 [-1, 1, 0,0]放入set中不会去重. 而且set也不能放入数组!</p></blockquote></li><li><p>自定枚举顺序</p><p>该题只有四个位置可以枚举, 所以要求<mark>每一个位置每一种数字只能出现一次. 而且要从小到大枚举</mark></p><blockquote><p>0, 1, 2, 3</p><p>不能是</p><p>2, 1, 0, 3 (乱序)</p></blockquote> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">  <span class="comment">// 排序也是为去重</span></span><br><span class="line">        Arrays.sort(nums, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 双指针解决后两个</span></span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">                LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">                <span class="keyword">long</span> tmp = target - nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[left] + (<span class="keyword">long</span>) nums[right] &gt; tmp) &#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[left] + (<span class="keyword">long</span>) nums[right] &lt; tmp) &#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        list.add(nums[left]);</span><br><span class="line">                        list.add(nums[right]);</span><br><span class="line">                        output.add((List&lt;Integer&gt;) list.clone());</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                      <span class="comment">// 去重</span></span><br><span class="line">                        <span class="keyword">int</span> val = nums[left];</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == val)</span><br><span class="line">                            ++left;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="31-下一个排列"><a class="markdownIt-Anchor" href="#31-下一个排列"></a> <a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><p>该题是求全排列的下一个.</p><p>要求是恰巧是下一个字典序更大的排列.  即求比该排序字典序中更大中的最小排列.</p><h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4><p>基于给定的排列出发, 构建一个字典序更大的且最小的. 尽可能的修改后面的, 而不是前面</p><blockquote><p>如 1 3 2 4, 若修改首位, 虽然满足字典序更大, 但并不是其中最小的.</p></blockquote><p>从后面出发. 找到第一个可以被修改的数字.</p><p>可以修改的条件是</p><ul><li><p>只要后面存在一个比当前数字大的元素就可修改</p><blockquote><p>如 1 3 2 4中的 2, 由于后面存在4, 所以2可以被修改, 具体操作是跟4换位.</p><p>1 3 4 2.</p><p>是从右往左找第一个大于当前元素的位置, 若存在, 则可进行交换</p></blockquote></li></ul><p>当修改完后, 只要将修改位置的后面的元素进行升序排序, 就可得到所求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">          <span class="comment">// 从后往前, 尝试寻找可以被修改的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; i; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt;= nums[i] + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = tmp;</span><br><span class="line">                    pos = i + <span class="number">1</span>;</span><br><span class="line">                  <span class="comment">// 进行升序排序</span></span><br><span class="line">                    Arrays.sort(nums, pos, nums.length);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums, pos, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步观察, <code>只要后面存在一个比当前数字大的元素就可修改</code>这个条件,  也意味着该位置到数组末尾的元素排列, 可看作是一座山.</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220408103732224.png?raw=true" alt="image-20220408103732224" style="zoom:50%;" /><blockquote><p>其中5是可修改的元素. 其位置一定是山下降左边的第一个位置.</p><p>5要和6进行交换</p></blockquote><p>那么可修改的元素的位置和其要交换的位置可通过遍历两次山得到</p><p>而且, 该位置到数组末尾的元素. 除去该位置外, 一定是一个降序数组. 那么排序可以变为reverse操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = start;</span><br><span class="line">       <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">           <span class="keyword">int</span> tmp = nums[left];</span><br><span class="line">           nums[left] = nums[right];</span><br><span class="line">           nums[right] = tmp;</span><br><span class="line">           ++left;</span><br><span class="line">           --right;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> left = nums.length - <span class="number">2</span>;</span><br><span class="line">     <span class="comment">// 找到山下降左边的第一个位置. 即可修改元素的位置, =是因为若山峰是一块平地不是尖的, 我们需要看山的边缘, 若不然, 得到的排列跟原来排列一样</span></span><br><span class="line">       <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; nums[left] &gt;= nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">           --left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">     <span class="comment">// 找到要交换的元素位置, 刚好大于可修改元素</span></span><br><span class="line">       <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] &gt;= nums[right]) &#123;</span><br><span class="line">           --right;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="comment">// 交换</span></span><br><span class="line">       <span class="keyword">int</span> tmp = nums[left];</span><br><span class="line">       nums[left] = nums[right];</span><br><span class="line">       nums[right] = tmp;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">if</span>(left == right)</span><br><span class="line">           reverse(nums, left);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           reverse(nums, left + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="836-矩形重叠"><a class="markdownIt-Anchor" href="#836-矩形重叠"></a> <a href="https://leetcode-cn.com/problems/rectangle-overlap/">836. 矩形重叠</a></h4><p>逆反思维的体现</p><p>只要一个矩形在另一个矩形的 左 或 上, 右, 下 方, 那么两个矩形一定是不重叠, 反之, 两个矩形一定重叠</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">Point</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y):<span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;;</span><br><span class="line">    &#125;Point;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; rec1, vector&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 防止rec1与rec2矩形面积为0</span></span><br><span class="line">        <span class="keyword">if</span>(rec1[<span class="number">0</span>] == rec1[<span class="number">2</span>] &amp;&amp; rec1[<span class="number">1</span>] == rec1[<span class="number">3</span>] || rec2[<span class="number">0</span>] == rec2[<span class="number">2</span>] &amp;&amp; rec2[<span class="number">1</span>] == rec2[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 只要rec2在rec1的右下左上, 就不会重叠, 反之, 一定重叠</span></span><br><span class="line">        <span class="keyword">if</span>(rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>] || rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] || rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>] || rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;41-缺失的第一个正数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#41-缺失的第一个正数&quot;&gt;&lt;/a&gt; 41. &lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-posit</summary>
      
    
    
    
    
    <category term="算法" scheme="https://chenyuanzhen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程</title>
    <link href="https://chenyuanzhen.github.io/2022/04/07/uploadMd/Shell%E7%BC%96%E7%A8%8B/"/>
    <id>https://chenyuanzhen.github.io/2022/04/07/uploadMd/Shell%E7%BC%96%E7%A8%8B/</id>
    <published>2022-04-07T14:06:44.000Z</published>
    <updated>2022-04-13T02:08:13.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shell概述"><a class="markdownIt-Anchor" href="#shell概述"></a> Shell概述</h2><p>Shell是指一个可执行程序, 为用户提供界面访问操作系统内核服务.</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20220407222359742.png?raw=true" alt="image-20220407222359742" /></p><blockquote><p>一般购买服务器, 都会采用Shell与Linux操作系统内核交互</p></blockquote><p>Shell编程</p><h2 id="shell脚本"><a class="markdownIt-Anchor" href="#shell脚本"></a> Shell脚本</h2><p>Shell脚本, 是指运行在shell上的脚本程序. 而平常使用的Shell, 本质也是一个脚本, 写一句执行一句, 而若写成文件 (即脚本), 可理解为在命令行逐行输入命令语句.</p><p>例子</p><p>编写一个Shell脚本 <a href="http://helloShell.sh">helloShell.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd public</span><br><span class="line">ls -al</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p>将其放到blog目录下, 执行</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20220407222717209.png?raw=true" alt="image-20220407222717209" /></p><blockquote><p>记得用<code>chmod +x helloShell.sh</code>命令, 追加执行权限</p></blockquote><h4 id="为什么要用shell"><a class="markdownIt-Anchor" href="#为什么要用shell"></a> 为什么要用Shell?</h4><p>主流操作系统支持shell编程</p><blockquote><p>Mac OS, Linux默认安装Shell解释器</p><p>Windows要安装cygwin或mingw模拟Linux环境</p><p><code>sh</code> 标准shell解释器.</p><p>bash是<code>sh</code>的替代品</p></blockquote><h4 id="与python的差别"><a class="markdownIt-Anchor" href="#与python的差别"></a> 与python的差别</h4><p>shell的优点</p><ul><li>最好的环境兼容性, 几乎所有Linux都预装shell运行环境 (<code>sh</code>或<code>bash</code>)</li></ul><p>shell的缺点</p><ul><li>不支持面向对象</li><li>功能很弱, 解释型, 只能运行到指定一行, 才知道那一行错了</li></ul><p>若是简单的, 且对兼容性有高要求, Linux中无需预装任何就能运行, 那就用shell</p><p>若是复杂的, 那还是建议用python, 装python解释器也不怎么花功夫.</p><blockquote><p><mark>shell自身提供功能少的可怜, 只有依赖其他可执行程序和命令时, 才会变得强大</mark></p></blockquote><h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 原生bash不支持简单数学运算</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要调用其他命令实现</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> expr 一个C语言程序</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ``为获得命令输出结果</span></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo &quot;两树之和: $val&quot;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加法</td><td style="text-align:left">`expr $a + $b` 结果为 30。</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减法</td><td style="text-align:left">`expr $a - $b` 结果为 -10。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘法</td><td style="text-align:left">`expr $a * $b` 结果为  200。</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除法</td><td style="text-align:left">`expr $b / $a` 结果为 2。</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取余</td><td style="text-align:left">`expr $b % $a` 结果为 0。</td></tr><tr><td style="text-align:left">=</td><td style="text-align:left">赋值</td><td style="text-align:left">a=$b 把变量 b 的值赋给 a。</td></tr><tr><td style="text-align:left">==</td><td style="text-align:left">相等。用于比较两个数字，相同则返回 true。</td><td style="text-align:left">[ $a == $b ] 返回 false。 ==两边必有空格</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不相等。用于比较两个数字，不相同则返回 true。</td><td style="text-align:left">[ $a != $b ] 返回 true</td></tr></tbody></table><p><mark>关系运算符仅支持数字, 不支持字符串</mark></p><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义与赋值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 变量名和等号之间不能有空格</span></span><br><span class="line">varibleName=&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用</span></span><br><span class="line">echo $varibleName</span><br><span class="line"><span class="meta">#</span><span class="bash"> 若想限定变量名范围, 可加&#123;&#125;, 最好都加&#123;&#125;</span></span><br><span class="line">echo &quot;$&#123;varibleName&#125;, Hi!&quot;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3><ul><li><p>单引号</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单引号字串中不能出现单引号</span></span><br><span class="line">str=&#x27;this is a string&#x27;</span><br></pre></td></tr></table></figure></li><li><p>双引号</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul></li><li><p>获取字符串长度</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出：4</span><br></pre></td></tr></table></figure><ul><li>提取子字符串</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;alibaba is a great company&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; #输出：liba</span><br></pre></td></tr></table></figure><ul><li>显示命令执行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></table></figure><ul><li>printf命名 与c语言类似</li></ul><h3 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h3><p><mark>shell的流程控制不可为空</mark></p><h4 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line">elif condition2</span><br><span class="line">command</span><br><span class="line">else</span><br><span class="line">command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">command</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">for(( EXP1; EXP2; EXP3 ))</span><br><span class="line">do</span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">command</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">until condition</span><br><span class="line">do </span><br><span class="line">command</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> ;;表示<span class="built_in">break</span> <span class="keyword">case</span>分支用 )</span></span><br><span class="line">case &quot;$&#123;opt&#125;&quot; in</span><br><span class="line">&quot;condition1&quot; )</span><br><span class="line">doSomething</span><br><span class="line">;;</span><br><span class="line">&quot;condition2&quot; )</span><br><span class="line">doSomething</span><br><span class="line">;;</span><br><span class="line">* ) doDefault</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><p>文件包含</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加载function.sh文件</span></span><br><span class="line">source ./function.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于以下命令</span></span><br><span class="line">. ./function.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 函数定义</span></span><br><span class="line">[ funciton ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">action;</span><br><span class="line">[ return int;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用插入的参数</span></span><br><span class="line">funcWithParam()&#123;</span><br><span class="line">echo &quot;第一个参数$&#123;1&#125;&quot;</span><br><span class="line">echo &quot;第二个参数$&#123;2&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shell数组"><a class="markdownIt-Anchor" href="#shell数组"></a> Shell数组</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 空格分隔, 括号表示数组, 下标从0开始</span></span><br><span class="line">array_name=(element1 element2 ... elementN)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问数组元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[index]&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问所有元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[*]&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取长度</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#array_name[*]&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="shell常用命令"><a class="markdownIt-Anchor" href="#shell常用命令"></a> Shell常用命令</h2><h3 id="test命令"><a class="markdownIt-Anchor" href="#test命令"></a> test命令</h3><blockquote><p>test命令本质是一个C语言程序</p></blockquote><p>用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试. 本身也是一个程序</p><ul><li>比较</li></ul><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-eq</td><td style="text-align:left">等于则为真</td></tr><tr><td style="text-align:left">-ne</td><td style="text-align:left">不等于则为真</td></tr><tr><td style="text-align:left">-gt</td><td style="text-align:left">大于则为真</td></tr><tr><td style="text-align:left">-ge</td><td style="text-align:left">大于等于则为真</td></tr><tr><td style="text-align:left">-lt</td><td style="text-align:left">小于则为真</td></tr><tr><td style="text-align:left">-le</td><td style="text-align:left">小于等于则为真</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $&#123;num1&#125; -eq $&#123;num2&#125;</span><br><span class="line">then</span><br><span class="line">echo &quot;num1 == num2&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;num1 != num2&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li>文件测试</li></ul><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-e 文件名</td><td style="text-align:left">如果文件存在则为真</td></tr><tr><td style="text-align:left">-r 文件名</td><td style="text-align:left">如果文件存在且可读则为真</td></tr><tr><td style="text-align:left">-w 文件名</td><td style="text-align:left">如果文件存在且可写则为真</td></tr><tr><td style="text-align:left">-x 文件名</td><td style="text-align:left">如果文件存在且可执行则为真</td></tr><tr><td style="text-align:left">-s 文件名</td><td style="text-align:left">如果文件存在且至少有一个字符则为真</td></tr><tr><td style="text-align:left">-d 文件名</td><td style="text-align:left">如果文件存在且为目录则为真</td></tr><tr><td style="text-align:left">-f 文件名</td><td style="text-align:left">如果文件存在且为普通文件则为真</td></tr><tr><td style="text-align:left">-c 文件名</td><td style="text-align:left">如果文件存在且为字符型特殊文件则为真</td></tr><tr><td style="text-align:left">-b 文件名</td><td style="text-align:left">如果文件存在且为块特殊文件则为真</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">echo &quot;./bash is exist&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;./bash is not exist&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：</p><p><strong>!</strong> 最高， <strong>-a</strong> 次之， <strong>-o</strong> 最低</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">num3=200</span><br><span class="line">if test $&#123;num1&#125; -eq $&#123;num2&#125; -a $&#123;num3&#125; -eq $&#123;num2&#125;</span><br><span class="line">then</span><br><span class="line">echo &quot;num1 == num2 &amp;&amp; num3 == num2&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;num1 num2 num3不完全相等&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="grep-查找"><a class="markdownIt-Anchor" href="#grep-查找"></a> grep 查找</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在path/to/file文件中, 检索符合条件的字符, 会将满足条件的行输出出来</span></span><br><span class="line">grep &quot;search_pattern&quot; path/to/file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一般配合管道使用 管道是什么? 下面会有描述</span></span><br><span class="line">ls -al | grep *.log # 在当前目录中, 找到后缀为.log的文件 </span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-grep.html">grep命令参数讲解</a></p><h3 id="sed命令-编辑"><a class="markdownIt-Anchor" href="#sed命令-编辑"></a> sed命令 编辑</h3><p>stream editor流编辑器.</p><p>需要事先提供一组<mark>规则(又称脚本)</mark>, sed会按照该规则编辑数据</p><p>处理文本文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-e 脚本命令</td><td>该选项会将其后跟的脚本命令添加到已有的命令中。</td></tr><tr><td>-f 脚本命令文件</td><td>该选项会将其后文件中的脚本命令添加到已有的命令中。</td></tr><tr><td>-n</td><td>默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。</td></tr><tr><td>-i</td><td>此选项会直接修改源文件，要慎用。</td></tr></tbody></table><h4 id="script命令"><a class="markdownIt-Anchor" href="#script命令"></a> script命令</h4><p>s匹配替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定行数, 只会检查该行, 否则检查所有行</span></span><br><span class="line">[行数]s/被替换内容/替换新内容/flag</span><br></pre></td></tr></table></figure><table><thead><tr><th>flags 标记</th><th>功能</th></tr></thead><tbody><tr><td>1~512 之间的数字</td><td>表示指定要替换的字符串出现第几次时才进行替换，<br />例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记；</td></tr><tr><td>g</td><td>对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A；</td></tr><tr><td>p</td><td>会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。</td></tr><tr><td>w file</td><td>将缓冲区中的内容写到指定的 file 文件中；</td></tr><tr><td>&amp;</td><td>用正则表达式匹配的内容进行替换；</td></tr><tr><td>\n</td><td>匹配第 n 个子串，该子串之前在 pattern 中用 () 指定。</td></tr><tr><td>\</td><td>转义（转义替换部分包含：&amp;、\ 等）。</td></tr></tbody></table><p>a附加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若指定行数, 则在指定行后面附加新文件内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 行数可以指定多个 2, 3表示第2, 3行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或从一行到最后一行$  2,$表示从第2行到最后一行</span></span><br><span class="line">[行数]a\新文件内容  </span><br></pre></td></tr></table></figure><p>c全部替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若指定行数, 则将那一行修改位替换的新文本</span></span><br><span class="line">[address]c\用于替换的新文本</span><br><span class="line">sed &#x27;3c\the third line will be replaced&#x27;</span><br></pre></td></tr></table></figure><h3 id="awk分析"><a class="markdownIt-Anchor" href="#awk分析"></a> awk分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">$ awk 动作 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># print表示打印, $0表示所有内容, $1为第一个字段, $2为第二个</span></span><br><span class="line"><span class="comment"># 用-F指明区分字符 </span></span><br><span class="line"><span class="comment"># 按一行行处理</span></span><br><span class="line"><span class="comment"># 用单引号, 不要用双引号, 否则会将转义后的语句传给awk</span></span><br><span class="line"><span class="comment"># 将一行句子以:分隔, $1表示打印第一个  如 root:seed 会被分隔为[root, seed], $1对应root</span></span><br><span class="line">$ awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> demo.txt</span><br></pre></td></tr></table></figure><h2 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> |为管道</span></span><br><span class="line">ls -al /etc | less</span><br></pre></td></tr></table></figure><p>将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;pattern&quot; path/to/file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 采用管道, 会将cat的输出作为grep的输入</span></span><br><span class="line">cat filename | grep &quot;pattern&quot;</span><br></pre></td></tr></table></figure><p>cat filename | grep “pattern” 发生什么?</p><ol><li>进程装载cat程序, 执行cat程序</li><li>打开filename文件, 将内容输出到管道文件中</li></ol><blockquote><p>管道文件: 可视为一个文件, 不过该文件仅会存储在内存中, 不会写入磁盘.</p></blockquote><ol start="3"><li><p>grep 打开管道文件</p><blockquote><p>grep命令, 是针对文件的, 需要打开文件, 并读取文件内容. 此处打开的是管道文件</p></blockquote></li><li><p>对管道文件内容进行匹配.</p></li><li><p>将匹配结果输出到终端中</p></li></ol><blockquote><p>父进程与子进程通信, 也可以通过管道完成</p></blockquote><h3 id="重定向与管道的差别"><a class="markdownIt-Anchor" href="#重定向与管道的差别"></a> 重定向与管道的差别</h3><ul><li><p>管道: 将标准输出作为标准输入传递给<mark>另一个命令</mark></p><blockquote><p>具体流程是</p><ol><li>标准输出重定向到管道文件</li><li>将管道文件路径传给下一个命令</li></ol></blockquote></li><li><p>重定向: 将输出符<mark>指向</mark>文件</p></li></ul><h2 id="信号signal"><a class="markdownIt-Anchor" href="#信号signal"></a> 信号signal</h2><p><em>信号(signal)是一种软中断，信号机制是进程间通信的一种方式，采用异步通信方式</em></p><h3 id="产生"><a class="markdownIt-Anchor" href="#产生"></a> 产生</h3><ul><li><p>硬件方式</p><ul><li><p>用户输入</p><blockquote><p>ctrl+C, 产生SIGINT信号</p></blockquote></li><li><p>硬件异常</p><blockquote><p>CPU检测到内存非法访问等异常, 通知内核生成对应信号, 并发送给产生事件的进程</p></blockquote></li></ul></li><li><p>软件方式</p><ul><li><p>系统调用, 发送signal信号</p><ul><li><p>alarm调用, 设定一个闹钟. 告诉内核在seconds秒之后给当前进程发送<code>SIGALRM</code>信号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"> <span class="comment">// 处理SIGALRM信号, 默认是终止进程</span></span><br></pre></td></tr></table></figure></li><li><p><code>kill(pid, signal)</code>调用</p><p>向pid进程, 发送signal信号</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">kill</span><span class="params">(pid, SYNC_SIG)</span> </span>== <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="内核中的信号表示"><a class="markdownIt-Anchor" href="#内核中的信号表示"></a> 内核中的信号表示</h3><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20220330165112082-9343521.png?raw=true" alt="image-20220330165112082" style="zoom:50%;" /><ul><li><p>block  信号种类</p></li><li><p>pending</p><ul><li>1表示已经产生信号, 但信号尚未处理</li></ul></li><li><p>handler</p><p>处理信号函数</p></li></ul><h3 id="发送信号-kill命令"><a class="markdownIt-Anchor" href="#发送信号-kill命令"></a> 发送信号 kill命令</h3><blockquote><p>kill – terminate or signal a process</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以查看系统定义的信号列表</span></span><br><span class="line">kill -l </span><br><span class="line"><span class="meta">#</span><span class="bash"> 中断进程 142 与157</span></span><br><span class="line">kill 142 157</span><br><span class="line"><span class="meta">#</span><span class="bash"> 向进程发送SIGHUP信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将507进程挂起</span></span><br><span class="line">kill -s HUP 507</span><br></pre></td></tr></table></figure><p>shell中可通过按键给前台进程发送信号</p><ul><li><p>ctrl + c 产生SIGINT信号 中断程序</p></li><li><p>ctrl + z 产生SIGTSTP信号 使进程暂停,</p><blockquote><ul><li>SIGSTOP信号 不可以被程序忽视 ctrl / 按了一定会退出</li><li>SIGTSTP信号 可以被程序忽视, 若程序修改SIGTSTP信号的处理函数, 那么程序不会退出, 而是改为执行处理函数</li></ul><p>两者信号的操作都是暂停进程</p></blockquote></li></ul><h4 id="种类"><a class="markdownIt-Anchor" href="#种类"></a> 种类</h4><p>定义64中信号, 32种可靠信号与32种不可靠信号</p><ul><li>不可靠信号： 又称非实时信号，不支持排队，信号可能会丢失, 比如发送多次相同的信号, 进程只能收到一次. 信号值取值区间为1~31</li><li>可靠信号： 也称为实时信号，支持排队, 信号不会丢失, 发多少次, 就可以收到多少次. 信号值取值区间为32~64</li></ul><h3 id="信号安装"><a class="markdownIt-Anchor" href="#信号安装"></a> 信号安装</h3><p>先要在进程中安装对应信号, 那么才会对信号进行处理.</p><p>主要建立信号值和进程相应信息值的动作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta"># sigaction函数可以读取和修改与指定信号相关联的处理动作. 调用成功则返回0，出错则返回-1.</span></span><br><span class="line"># 若act指针非空，则根据act修改该信号的处理动作。</span><br><span class="line"># 若oact指针非空，则通过oact传出该信号原来的处理动作</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> __<span class="title">sigaction_u</span> __<span class="title">sigaction_u</span>;</span>  <span class="comment">/* signal handler */</span></span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask;               <span class="comment">/* signal mask to apply */</span></span><br><span class="line">  <span class="comment">// 默认设为0, 修改信号的行为</span></span><br><span class="line"><span class="keyword">int</span>     sa_flags;               <span class="comment">/* see signal options below */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 该宏定义将sa_handler视为 __sigaction_u中的函数指针类型, 接受一个整型参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_handler      __sigaction_u.__sa_handler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* union for signal handlers */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> __<span class="title">sigaction_u</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span>    (*__sa_handler)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">void</span>    (*__sa_sigaction)(<span class="keyword">int</span>, struct __siginfo *, <span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="信号阻塞"><a class="markdownIt-Anchor" href="#信号阻塞"></a> 信号阻塞</h3><p>进程可以选择阻塞（Block）某个信号。被阻塞的信号产生时将保持在未决状态(pending)，直到进程解除对此信号的阻塞，才执行递达的动作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printsigset</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (sigismember(<span class="built_in">set</span>, i) == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用s和p对信号进行存储</span></span><br><span class="line">    <span class="keyword">sigset_t</span>  s, p;</span><br><span class="line">    <span class="comment">// 初始化s, 将s的每一位置为0</span></span><br><span class="line">    sigemptyset(&amp;s);</span><br><span class="line">    <span class="comment">// 往信号集s中添加SIGINT信号</span></span><br><span class="line">    sigaddset(&amp;s, SIGINT);</span><br><span class="line">    <span class="comment">// 更改进程信号屏蔽字</span></span><br><span class="line">    <span class="comment">// SIG_BLOCK 进行阻塞</span></span><br><span class="line">  <span class="comment">// 该进程要求对SIG_BLOCK信号进行阻塞</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;s, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回待处理的信号集传递给调用线程</span></span><br><span class="line">        <span class="comment">// 在集合中, 返回未决信号的掩码</span></span><br><span class="line">        sigpending(&amp;p);</span><br><span class="line">        printsigset(&amp;p);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理信号流程"><a class="markdownIt-Anchor" href="#处理信号流程"></a> 处理信号流程</h3><ol><li><p>用户程序注册了<code>SIGQUIT</code>信号的处理函数<code>sighandler</code></p></li><li><p>当前正在执行<code>main</code>函数，这时<mark>发生中断或异常切换到内核态</mark></p></li><li><p>在中断处理完毕后要返回用户态的<code>main</code>函数之前检查到有信号<code>SIGQUIT</code>递达</p></li><li><p>内核决定返回用户态后不是恢复<code>main</code>函数的上下文继续执行，而是执行<code>sighandler</code>函数，<mark><code>sighandler</code>和<code>main</code>函数使用不同的堆栈空间</mark>，它们之间不存在调用和被调用的关系，是两个独立的控制流程</p><blockquote><p>但允许调用全局变量, 要防止冲突. 信号函数与主函数是异步的, 可以当做考虑并发问题(虽然不是并发, 处理信号函数时, 主函数会暂停)</p></blockquote></li><li><p><code>sighandler</code>函数返回后自动执行特殊的系统调用<code>sigreturn</code>再次进入内核态</p></li><li><p>如果没有新的信号要递达，这次再返回用户态就是恢复<code>main</code>函数的上下文继续执行了</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="comment">// signo为信号</span></span><br><span class="line"><span class="comment">// 处理该函数时, 进程原先执行的函数会停止, 该函数会用与原进程不同的堆栈, 但可以通过适当使用全局变量进行交互</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 处理不同的信号 */</span></span><br><span class="line">    <span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGALRM:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SIGALRM is coming %d\n&quot;</span>, signo);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGINT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is coming %d\n&quot;</span>, signo);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line"></span><br><span class="line">    newact.sa_handler = sig_alrm;</span><br><span class="line">    <span class="comment">// 初始化掩码</span></span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// oldact为之前处理SIGALRM的行为</span></span><br><span class="line">    sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line">    sigaction(SIGINT, &amp;newact, &amp;oldact);</span><br><span class="line">    <span class="comment">// 告知内核, 在nsecs秒后, 向该进程发送SIGALRM信号</span></span><br><span class="line">    <span class="comment">// 不一定会在nsecs秒处理, 因为那时可能在处理其他信号</span></span><br><span class="line">    alarm(nsecs);</span><br><span class="line">    <span class="comment">// 暂停, 等待信号的来临</span></span><br><span class="line">    pause();</span><br><span class="line">    <span class="comment">// 要求内核停止发送alarm信号</span></span><br><span class="line">    <span class="comment">//  alarm的返回值为调用alarm时timer中剩余的时间, 若之前没有设置timer,则返回0</span></span><br><span class="line">    unslept = alarm(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 恢复为原来的SIGALRM信号处理</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        mysleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="volatile限定符"><a class="markdownIt-Anchor" href="#volatile限定符"></a> volatile限定符</h4><p>若该进程对变量没有修改, 若该变量被信号处理函数或非该进程修改, 进程在执行时, 该值是不会被修改的 (哪怕被信号处理函数修改过, 回到主程序查看, 值并没有被修改)</p><blockquote><p>这样做是出于效率考虑</p></blockquote><p>若进程需要和信号处理函数共用一个变量, 那么需要添加<code>volatile</code>关键字, 防止优化.</p><h3 id="信号竞争"><a class="markdownIt-Anchor" href="#信号竞争"></a> 信号竞争</h3><p>进程必须要占用处理器时, 才能处理信号.</p><p>假设以下情景</p><ol><li><p>进程A调用<code>alaram(nesc)</code>函数, 设定闹钟,</p></li><li><p>但因进程调度, A不再占有CPU,</p></li><li><p>过了<code>nesc秒</code>后, <code>SIGALRM</code>信号发送, 但进程A没有获得CPU,  处于<code>Pending</code>状态.</p></li><li><p>当A重新获得CPU时, 会优先处理<code>SIGALRM</code>信号.</p><p>此时问题来了</p></li><li><p>处理完后<code>SIGALRM</code>信号后, 回到主函数中,</p></li><li><p>此时主函数调用<code>pause</code>函数, 等待信号. 这个时候信号已经处理完了, <code>pause</code>已经失去作用. 导致进程无法继续执行.</p></li></ol><blockquote><p>问题的核心是, <code>pause</code>函数前, 信号就到达且被处理. 那么<code>pause</code>函数已经失去等待的意义, 却一直在等. 程序无法继续运行</p></blockquote><p>解决该问题可以采用<code>sigsuspend</code>函数</p><blockquote><p>核心是让pause操作能等到信号. 信号应在pause后到达. 若在前到达, 需要先对其进行阻塞.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 临时解除sigmask对应的信号屏蔽, 然后挂起的等待</span></span><br><span class="line"><span class="comment">// 该函数结束后, 会恢复对应屏蔽</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure><p>基本步骤</p><ol><li>调用<code>sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</code>时屏蔽<code>SIGALRM</code>。</li><li>调用<code>sigsuspend(&amp;suspmask);</code>时解除对<code>SIGALRM</code>的屏蔽，然后挂起等待待。</li><li><code>SIGALRM</code>递达后<code>suspend</code>返回，自动恢复原来的屏蔽字，也就是再次屏蔽<code>SIGALRM</code>。</li><li>调用<code>sigprocmask(SIG_SETMASK, &amp;oldmask, NULL);</code>时再次解除对<code>SIGALRM</code>的屏蔽</li></ol><h2 id="作业控制"><a class="markdownIt-Anchor" href="#作业控制"></a> 作业控制</h2><ul><li><p>Shell分为前台和后台.</p></li><li><p>Shell是控制<code>作业Job</code>(又称<code>进程组</code>)而非单个进程.</p><blockquote><p>后台可能有多个作业组</p><p>前台仅能有一个作业组</p></blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> proc1和proc2属于同一个后台进程组</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &amp;表示后台执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> proc1 | proc2 &amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> proc3、proc4、proc5属于同一个前台进程组</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> proc3 | proc4 | proc5</span></span><br></pre></td></tr></table></figure></li></ul><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20220331104223836-9343741.png?raw=true" alt="image-20220331104223836" style="zoom:50%;" /><p>ctrl + c会向所有前台进程组发送SIGINT信号, 一般情况下所有前台进程都会被关闭.</p><blockquote><p>除非该前台进程重写SIGINT信号的处理函数</p></blockquote><h2 id="参考信息"><a class="markdownIt-Anchor" href="#参考信息"></a> 参考信息</h2><ul><li><a href="http://akaedu.github.io/book/index.html"><strong>Linux C编程一站式学习</strong></a></li><li><a href="https://wangchujiang.com/linux-command/">Linux命令搜索</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;shell概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#shell概述&quot;&gt;&lt;/a&gt; Shell概述&lt;/h2&gt;
&lt;p&gt;Shell是指一个可执行程序, 为用户提供界面访问操作系统内核服务.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://chenyuanzhen.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程</title>
    <link href="https://chenyuanzhen.github.io/2022/03/25/uploadMd/Linux%E8%BF%9B%E7%A8%8B/"/>
    <id>https://chenyuanzhen.github.io/2022/03/25/uploadMd/Linux%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-03-25T08:41:14.000Z</published>
    <updated>2022-04-14T03:25:07.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程创建"><a class="markdownIt-Anchor" href="#进程创建"></a> 进程创建</h2><h3 id="fork系统调用"><a class="markdownIt-Anchor" href="#fork系统调用"></a> fork系统调用</h3><ul><li><p>父进程: 返回子进程PID</p><ul><li>失败会返回-1</li></ul></li><li><p>子进程: 返回0</p><blockquote><p>子进程可通过<code>getpid()</code>调用, 获得自己的PID</p><p>通过<code>getppid()</code>调用, 获得父PID</p></blockquote></li></ul><p><code>fork</code>会复制PCB中的信息</p><p>子进程会获得父进程的栈, 数据, 堆的拷贝. 两者互不干扰</p><blockquote><p>可以将将父进程设想为分裂以产生其自身的两个副本</p><p>子进程和父进程运行在分开的内存地区.</p></blockquote><blockquote><p>实际实现子进程拷贝父进程堆栈, 数据时, 并不是真的完全拷贝, 而是采用<mark>写时拷贝  copy on write</mark>的技术.</p><p>基本思想:</p><p>只读的数据就共享, 当子或父进程想要修改时, 才对要修改的数据进行拷贝, 并在拷贝上修改.</p><blockquote><p>数据是指内存页或内存段</p></blockquote></blockquote><p><code>fork</code>调用样例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Used in parent after successful fork() to record PID of child */</span></span><br><span class="line"><span class="keyword">pid_t</span> childPid; </span><br><span class="line"><span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">/* fork() failed */</span></span><br><span class="line">   <span class="comment">/* Handle error */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* Child of successful fork() comes here */</span></span><br><span class="line">   <span class="comment">/* Perform actions specific to child */</span></span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">/* Parent comes here after successful fork() */</span></span><br><span class="line">   <span class="comment">/* Perform actions specific to parent */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父进程和子进程都会执行switch以后的代码段</span></span><br></pre></td></tr></table></figure><h4 id="文件描述符"><a class="markdownIt-Anchor" href="#文件描述符"></a> 文件描述符</h4><p>父进程和子进程是<mark>共用</mark>文件描述符.</p><blockquote><p>而非拷贝</p></blockquote><blockquote><p>文件描述符包括</p><ul><li>文件指针</li><li>打开文件标识( 只读还是读写 )</li></ul></blockquote><p>子进程修改文件描述符, 是会影响到父进程.</p><h3 id="子进程与父进程的区别"><a class="markdownIt-Anchor" href="#子进程与父进程的区别"></a> 子进程与父进程的区别</h3><ul><li><p>子进程有自己独一无二的PID.</p></li><li><p>父进程的PID与子进程的父亲PID一样</p></li><li><p>子进程<mark>不会继承父亲的内存锁</mark></p></li><li><p>进程资源利用率和CPU占用时间会清零在子进程, 即重新计算</p></li><li><p>子进程的待处理信号集为空</p></li><li><p>子进程不会从父进程继承信号量调整</p></li><li><p>子进程不会继承父进程关联的锁.</p><blockquote><p>但会继承父进程打开的文件描述符</p></blockquote></li><li><p>子继承不会继承父进程尚未完成的异步I/O</p></li><li><p>子进程会完全复制父进程的虚拟地址空间</p></li></ul><h4 id="对于linux系统额外的不同"><a class="markdownIt-Anchor" href="#对于linux系统额外的不同"></a> 对于Linux系统额外的不同</h4><ul><li>当父进程中断时, 子进程是不会收到信号</li><li>子进程结束的时候会自动发送<code>SIGCHLD</code>信号给父进程, 该信号处理默认是不处理</li><li>子进程会继承父进程的目录流</li></ul><h2 id="shell-执行一个可执行程序的基本步骤"><a class="markdownIt-Anchor" href="#shell-执行一个可执行程序的基本步骤"></a> Shell 执行一个可执行程序的基本步骤</h2><h3 id="exitstatus系统调用-与-wait系统调用"><a class="markdownIt-Anchor" href="#exitstatus系统调用-与-wait系统调用"></a> exit(status)系统调用 与 wait()系统调用</h3><p><code>exit(status)</code>会中断当前进程. 参数<code>status</code>是整型, 反映中断状态.</p><p>使用<code>wait()</code>, 父进程可以获得子进程<code>exit</code>的<code>status</code>.</p><blockquote><p>wait调用, 父进程会等待子进程执行完毕.</p></blockquote><h3 id="execvepathname-argv-envp-系统调用"><a class="markdownIt-Anchor" href="#execvepathname-argv-envp-系统调用"></a> execve(pathname, argv, envp) 系统调用</h3><p>往当前进程内存中加载新的程序.  原有的栈, 数据, 堆会被丢弃. 加载新的程序会有新的堆, 栈与数据存储.</p><p><code>exec(...)</code>调用是<code>execve(...)</code>的默认版.</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:44-image-20220408112632491.png?raw=true" alt="image-20220408112632491" style="zoom:50%;" /><blockquote><p>Shell中运行可执行程序的流程图</p></blockquote><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li><a href="https://man7.org/tlpi/download/TLPI-24-Process_Creation.pdf">THE LINUX PROGRAMMING INTERGACE 第24章</a></li><li><a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork函数调用文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程创建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#进程创建&quot;&gt;&lt;/a&gt; 进程创建&lt;/h2&gt;
&lt;h3 id=&quot;fork系统调用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fork系统调用&quot;&gt;&lt;/a&gt; </summary>
      
    
    
    
    
    <category term="Linux" scheme="https://chenyuanzhen.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>JVM笔记</title>
    <link href="https://chenyuanzhen.github.io/2022/03/15/uploadMd/JVM%E7%AC%94%E8%AE%B0/"/>
    <id>https://chenyuanzhen.github.io/2022/03/15/uploadMd/JVM%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-15T14:13:28.000Z</published>
    <updated>2022-04-13T02:11:43.460Z</updated>
    
    <content type="html"><![CDATA[<p>Java Virtual Machine 虚拟机, 读入.class文件</p><h2 id="jvm生命周期"><a class="markdownIt-Anchor" href="#jvm生命周期"></a> JVM生命周期</h2><ol><li><p>启动</p><p>通过引导类加载器, 创建一个初始类完成</p></li><li><p>执行</p><p>执行一个Java程序</p></li><li><p>退出</p></li></ol><h2 id="构成"><a class="markdownIt-Anchor" href="#构成"></a> 构成</h2><h4 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h4><ul><li>引导类加载器</li><li>扩展类加载器</li><li>应用加载器</li></ul><h4 id="线程共享区"><a class="markdownIt-Anchor" href="#线程共享区"></a> 线程共享区</h4><ul><li>方法区</li></ul><blockquote><p>存放类信息，常量，静态变量，编译后代码···等</p></blockquote><p><code>native</code>修饰的方法是本地方法, 不由Java实现, 由JVM实现.</p><ul><li><p>堆</p><blockquote><p>负责存储数据</p></blockquote><p>堆内存分为<code>年轻代</code>和<code>老年代</code></p><p>大部分new对象会进入堆空间, 但线程的栈与<code>TLAB</code>, 也被允许存储对象</p><ul><li><p>TLAB (Thread - local allocation buffer)</p><p>线程私有内存空间, 默认占用年轻代 1%空间. 由于线程独享, 无锁开销.</p><blockquote><p>目的是加快对象分配, 在堆中分配内存是需要加锁的.</p></blockquote><p>与共享内存使用方法一样</p><p>用于存放线程中<mark>小且立即丢弃的</mark>对象</p></li></ul></li></ul><h4 id="线程独享区"><a class="markdownIt-Anchor" href="#线程独享区"></a> 线程独享区</h4><ul><li><p>栈</p><blockquote><p>负责执行代码</p></blockquote><ul><li>存放局部变量, 方法出口, 动态链表等</li><li>程序结束, 栈的空间自动释放</li></ul><blockquote><p>这里也被允许存放对象,</p><p>该对象的生命周期会随着方法的调用开始而开始, 调用结束和结束. 出于减轻GC负担考虑.</p><p>对象回收无需GC介入, 但栈空间小, 对象过大则无法分配</p></blockquote><p><code>逃逸分析</code> 若一个类的句柄位于方法之外, 则会被认为发生逃逸, 不会放在栈中, 此外, 若句柄被返回出去, 也会视为逃逸, 不会放在栈内.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Address address;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">setAddress</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处则发生逃逸</span></span><br><span class="line">    address = <span class="keyword">new</span> Address();</span><br><span class="line">    address.set(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序计数器</p></li></ul><h4 id="本地方法接口"><a class="markdownIt-Anchor" href="#本地方法接口"></a> 本地方法接口</h4><p>JVM实现Java中native修饰的方法</p><h4 id="jit-执行引擎"><a class="markdownIt-Anchor" href="#jit-执行引擎"></a> JIT 执行引擎</h4><p>将.class字节码转为二进制机器指令</p><h2 id="类加载"><a class="markdownIt-Anchor" href="#类加载"></a> 类加载</h2><p>阶段</p><ul><li><p>加载</p><p>由类加载器负责</p><ul><li><p>引导类加载器 Bootstrap ClassLoader</p><blockquote><p>采用C和C++编写, 无法获取. 仅用于加载java的核心类</p></blockquote><p>仅加载 java/目录下的类库, 核心的API, 如String</p></li><li><p>扩展类加载器 ClassLoader</p><blockquote><p>继承Java.lang.ClassLoader</p></blockquote></li><li><p>系统类加载器 Application ClassLoader</p></li></ul><blockquote><p>包含关系, 并不是继承关系</p><p>如目录包含</p><p>引导类包含扩展类, 扩展类包含系统类</p></blockquote><blockquote><p>允许自定义加载类</p><ul><li>防止类路径冲突</li><li>自定义class加载, 防止源码泄漏</li></ul></blockquote><p>每一个class仅由一种加载器加载</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法获取, 因为是引导类加载器, 采用C和C++编写</span></span><br><span class="line"><span class="comment">// 得到的是null</span></span><br><span class="line">ClassLoader loader = String.class.getClassLoader();</span><br></pre></td></tr></table></figure><blockquote><p>类加载器: 负责动态加载Java类到Java虚拟机的内存空间中</p></blockquote></li><li><p>链接</p><ul><li>验证</li><li>准备</li><li>解析</li></ul></li><li><p>初始化</p></li></ul><h4 id="类加载过程"><a class="markdownIt-Anchor" href="#类加载过程"></a> 类加载过程</h4><p>加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</p><ul><li><p>加载</p><ol><li><p>对应该类的二进制字节流</p></li><li><p>将字节流<code>静态存储结构</code>放在方法区</p></li><li><p>生成一个 java.lang.Class对象, 用于反射</p></li></ol></li><li><p>验证</p><p>确保class文件的字节流包含信息符合虚拟机要求, 防止class文件对虚拟机造成破坏</p></li><li><p>准备</p><p>为类变量分配内存并设置该变量的对应零值.</p><blockquote><p><mark>在<code>&lt;clinit&gt;</code>后, 才会被赋于设定初始值</mark></p></blockquote><p>经过该阶段, 类的静态变量已被分配内存并赋予零值. 但尚未赋予<mark>设定</mark>的初值</p></li><li><p>解析</p><p>将符号引用转为直接引用</p><ul><li>符号引用是字符串信息, 描述所引用的目标.</li><li>直接引用, 在运行时, 符号引用会替换为指针, 该指针指向一个函数, 或者一个类,</li></ul><blockquote><p>也可先执行<code>clinit</code>方法, 再执行解析. 防止循环引用</p></blockquote></li><li><p>初始化</p><p>执行类<code>构造器方法&lt;clinit&gt;</code></p><blockquote><p><code>&lt;clinit&gt;</code>由JVM自动生成</p><p>自动收集类中的所有类的<mark>静态变量的赋值动作</mark>与<mark>静态代码块的语句</mark>合并生成.</p><p>按照语句在源文件出现顺序执行</p></blockquote><p>必须先执行父类的<code>&lt;clinit&gt;</code>函数, 且<code>&lt;clinit&gt;</code>函数在多线程情况下会加锁.</p><blockquote><p>防止一个类被多次加载.</p></blockquote></li></ul><p>​<mark>一个类只会加载一次</mark>并会将信息放到方法区,  意味着<code>&lt;clinit&gt;</code>只会调用一次,</p><p>​实例化会从方法区中读取类信息, 一个类若没有static, 那么不会有<code>&lt;clinit&gt;</code>方法</p><blockquote><p>函数中类的构造函数对应虚拟机中 <code>&lt;init&gt;</code>方法</p></blockquote><h2 id="双亲委派机制"><a class="markdownIt-Anchor" href="#双亲委派机制"></a> 双亲委派机制</h2><p>class文件是按需加载的, 而加载一个class文件时, 会先询问上级<code>加载器</code>是否能完成加载.</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220308112126606.png?raw=true" alt="image-20220308112126606" style="zoom:50%;" /><p>如我在项目路径中, 自定义一个java.lang.String类, 那么在加载我自定义的String类时, 由于<code>双亲委派机制</code>,</p><ol><li>从<code>系统类加载器</code>出发, 询问<code>拓展类加载器</code>能否完成加载</li><li><code>拓展类</code>询问<code>引导类</code>能否加载</li><li>由于<code>引导类</code>是负责加载 java.lang下的类, 所以由引导类加载器加载java.lang.String. 但此时该java.lang.String是Java原String, 并非项目路径下的String. 因为<mark>引导类加载器搜索范围是 java目录下, 而非项目目录</mark>. 所以项目中仍是使用java核心API的String</li><li>引导类加载器已经完成加载, 其余加载器就无需干活.</li></ol><h4 id="目的"><a class="markdownIt-Anchor" href="#目的"></a> 目的</h4><p>出于安全考虑, 防止外部引入与核心API同名的类导致Java项目出错</p><blockquote><p>保证JDK的系统API不会被用户定义的类加载器所破坏</p></blockquote><h2 id="对象创建实例化过程"><a class="markdownIt-Anchor" href="#对象创建实例化过程"></a> 对象创建(实例化)过程</h2><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220313214347949.png?raw=true" alt="image-20220313214347949" style="zoom:33%;" /><ol><li><p>类加载检查</p><p>检查类是否已经加载到方法区, 若未加载, 则先执行类加载</p></li><li><p>分配内存</p><p>将新生代划分空间, 写好类信息头后, 并将给各变量其赋予零值.</p><blockquote><p>内存分配并发问题.  同时有多个线程分配内存</p><ul><li>CAS操作</li><li>每个线程在Eden区独享一块内存,称为<code>TLAB</code>, 所用内存超过则用CAS操作赋值.</li></ul></blockquote></li><li><p>设置对象头</p><p>存储:</p><ul><li>如何找到类的元数据</li><li>对象哈希码</li><li>对象的GC分代年龄</li><li>等等</li></ul></li><li><p>执行<code>&lt;init&gt;</code>方法</p><p>执行构造函数, 完成各变量的赋值, 执行顺序如下</p><ol><li>先执行父类的构造函数</li><li>执行构造函数外的赋值语句</li><li>执行自己的构造函数.</li></ol></li></ol><h2 id="jvm内存分配与回收"><a class="markdownIt-Anchor" href="#jvm内存分配与回收"></a> JVM内存分配与回收</h2><p>Java堆 又称<code>GC</code></p><h4 id="分代垃圾收集算法"><a class="markdownIt-Anchor" href="#分代垃圾收集算法"></a> 分代垃圾收集算法</h4><p>堆分为: 新生代, 老生代.</p><blockquote><p>经过多次GC还能活着, 可以认为该对象在以后也要活着, 那么应放到Old Memory中. 那么在执行GC时, JVM只需要扫描被回收概率大的对象, 即刚被分配的对象.</p></blockquote><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220305085154066.png?raw=true" alt="image-20220305085154066" style="zoom:50%;" /><p>过程:</p><ul><li><p>对象分配在Eden, 经过一次Eden垃圾回收后, 会进入 Survivor0或 Survivor1.</p></li><li><p>此外每经过一次垃圾回收, 年龄 + 1. 当年龄大于一定程度时, 会放置到Old Memory变为老生代.</p></li><li><p>经过一次GC后, Eden区和From区会被清空, From会和To交换角色.</p></li><li><p>当Eden区没有足够空间分配, 会触发MinorGC, 会通过<code>分配担保机制</code>将新生代对象提起放到老年代</p></li></ul><h4 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h4><ul><li><p>大对象直接进入老年代</p><blockquote><p>避免大对象分配内存由于<code>分配担保机制</code>带来复制而降低效率</p></blockquote></li><li><p>长期存活的对象会进入老年代</p></li></ul><h4 id="gc名词解释"><a class="markdownIt-Anchor" href="#gc名词解释"></a> GC名词解释</h4><ul><li>新生代收集 MinorGC / YoungGC 仅对新生代区域进行垃圾收集</li><li>老年代收集 MajorGC / OldGC 仅对老年代进行垃圾收集</li><li>混合收集 MixedGC 对整个新生代和部分老年代进行垃圾收集</li></ul><p>整堆收集 Full GC 收集整个Java堆和方法区</p><h4 id="空间分配担保"><a class="markdownIt-Anchor" href="#空间分配担保"></a> 空间分配担保</h4><p>确保在MinorGC之前老年代本身还有容纳新生代所有对象的剩余空间.</p><h2 id="确定一个对象真的要挂了"><a class="markdownIt-Anchor" href="#确定一个对象真的要挂了"></a> 确定一个对象真的要挂了?</h2><h4 id="方法一-引用计数法"><a class="markdownIt-Anchor" href="#方法一-引用计数法"></a> 方法一 引用计数法</h4><p>与C<ins>的shared_ptr类似, 一块对象每被引用一次, 则引用计数器</ins>. 解除则引用计数器–.</p><p>当引用计数器为0时, 则回收</p><blockquote><p>但也存在和shared_ptr一样的问题, <mark>循环引用</mark>.</p><p>即两个对象彼此互相指着, 但除此之外, 无其他引用.</p><p>C++是采用weak_ptr解决</p></blockquote><h4 id="方法二-可达性分析"><a class="markdownIt-Anchor" href="#方法二-可达性分析"></a> 方法二 可达性分析</h4><p>从<code>GC Root</code>的对象作为起点出发, <code>GC Root</code>无法访问到的对象, 说明该对象已经不可用.</p><p><code>GC Root</code>可以是</p><ul><li><p><mark>所有正在运行的线程的本地栈上的引用变量</mark></p></li><li><p><strong>JVM内部使用的引用</strong></p></li><li><p>⽅法区中的静态变量</p></li><li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象</p></li></ul><h2 id="强-软-弱-虚引用"><a class="markdownIt-Anchor" href="#强-软-弱-虚引用"></a> 强 / 软 / 弱 / 虚引用</h2><p>软/ 弱 / 虚引用 为一个特定类,</p><ul><li><p>强引用</p><p>平时使用的引用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用, 该引用指向的对象, JVM不会回收</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>哪怕内存满, 只会报OOM错误</p></li><li><p>软引用</p><p>内存足够, 不回收该引用</p><p>内存不足, 会回收该对象</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference(o1);</span><br><span class="line">o1 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>弱引用</p><p>不管内存是否足够, GC时会进行回收</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object o1 = <span class="keyword">new</span> Object;</span><br><span class="line">WeakPeference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference(o1);</span><br><span class="line">o1 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>虚引用</p><p><code>PhantomReference</code>类实现, 等同于没有任何引用, 仅用于调用<code>finalize()</code>方法,</p><p>需配合引用队列一起使用</p></li></ul><h2 id="回收类信息"><a class="markdownIt-Anchor" href="#回收类信息"></a> 回收类信息</h2><p>当一个类满足以下<mark>所有条件</mark>, 才<mark>可能</mark>会被回收, 下次使用需重新加载</p><ul><li>Java堆中不存在该类的实例</li><li>ClassLoader已经被回收</li><li>对应的反射Class没有被使用</li></ul><h2 id="垃圾收集算法"><a class="markdownIt-Anchor" href="#垃圾收集算法"></a> 垃圾收集算法</h2><h3 id="标记-清除算法"><a class="markdownIt-Anchor" href="#标记-清除算法"></a> 标记-清除算法</h3><p>将待清除的对象打上标记, 待会统一进行清除</p><p>优点</p><ul><li>效率高</li></ul><p>缺点</p><ul><li>产生许多内存碎片</li></ul><h3 id="复制算法"><a class="markdownIt-Anchor" href="#复制算法"></a> 复制算法</h3><p>将内存分为两个大小相同的块, 将要保留的对象放到另一边. 清除时, 只需要将当前使用的内存全部清空即可</p><p>优点</p><ul><li>产生较少内存碎片</li></ul><p>缺点</p><ul><li>需要拷贝</li></ul><h3 id="标记-整理算法"><a class="markdownIt-Anchor" href="#标记-整理算法"></a> 标记-整理算法</h3><p>依然是将要回收的对象打上标记, 在清除时, <mark>将所有存活对象向一端移动</mark>. 最后清除边界以外的内存</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220306220007575.png?raw=true" alt="image-20220306220007575" style="zoom: 33%;" /><h3 id="分代收集算法"><a class="markdownIt-Anchor" href="#分代收集算法"></a> 分代收集算法</h3><p>JVM根据对象存活周期, 区分新生代, 老年代. 并根据其特点采用不同的垃圾回收算法</p><ul><li><p>新生代中, 采用复制算法</p><blockquote><p>新生代中, 对象淘汰的概率最大, 往往只要少量的复制成本完成</p></blockquote></li><li><p>老年代, 采用标记整理算法</p><blockquote><p>老年代, 对象淘汰概率小, 且需要减少内存碎片, 以便老年代存放更多对象</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java Virtual Machine 虚拟机, 读入.class文件&lt;/p&gt;
&lt;h2 id=&quot;jvm生命周期&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm生命周期&quot;&gt;&lt;/a&gt; JVM生命周期&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;启动&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://chenyuanzhen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程笔记</title>
    <link href="https://chenyuanzhen.github.io/2022/02/21/uploadMd/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://chenyuanzhen.github.io/2022/02/21/uploadMd/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-02-21T10:26:00.000Z</published>
    <updated>2022-04-13T02:11:59.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java线程与操作系统的线程区别"><a class="markdownIt-Anchor" href="#java线程与操作系统的线程区别"></a> Java线程与操作系统的线程区别</h2><p>内存通常分为</p><ul><li>用户空间</li><li>内核空间</li></ul><p>当线程/进程运行在用户空间为用户态, 相反则为内核态</p><blockquote><p>内核态程序访问权限高, 允许访问任何资源</p><p>而用户态只能访问用户空间</p><p>是出于安全考虑, 才区分用户态和内核态</p></blockquote><h2 id="操作系统线程"><a class="markdownIt-Anchor" href="#操作系统线程"></a> 操作系统线程</h2><ol><li><p>用户空间中实现线程</p><p>开发者需要自定线程数据结构, 创建, 调度等一些工作. <mark>操作系统仅会对进程调度</mark></p><p>好处</p><ul><li>线程与操作系统无关</li></ul></li></ol><ul><li><p>避免操作系统从内核态到用户态开销</p><p>坏处</p><ul><li>操作系统无法得知线程存在, 而CPU时间片切换并不会考虑线程, 导致一个线程阻塞导致进程阻塞. 所有线程都会因失去CPU资源而停止</li></ul></li></ul><ol start="2"><li><p>内核空间实现线程</p><p>运行在内核空间的线程, 由内核负责线程调度</p><p>几乎所有的<strong>现代</strong>操作系统，包括 Windows、Linux、Mac OS X 和 Solaris 等，都支持内核线程。</p><p>开发者只需调用操作系统内置的线程, 无需负责线程创建, 销毁, 调度等</p><h4 id="用户线程和内核线程模型"><a class="markdownIt-Anchor" href="#用户线程和内核线程模型"></a> 用户线程和内核线程模型</h4><ol><li><p>一对多</p><p>多个用户线程映射到一个内核线程</p><p>几乎不用, 因为无法利用多个CPU, 未增加并发性</p></li><li><p>一对一</p><p>一个用户线程映射一个内核线程</p> <img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220127214020868.png?raw=true" alt="image-20220127214020868" style="zoom:33%;" /><ul><li>开销大, 且减慢系统速度, 需注意不得创建太多线程</li><li>并发性强, 能更好发挥多个CPU的性能</li></ul></li><li><p>多对多</p><p>多对多模型将任意数量的用户线程复用到相同或更少数量的内核线程上，结合了一对一和多对一模型的最佳特性</p> <img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220127214144634.png?raw=true" alt="image-20220127214144634" style="zoom:33%;" /><p>好处</p><ul><li>用户对创建线程数无限制</li><li>可为多个进程分配可变数量的内核线程</li></ul></li></ol><h2 id="java线程"><a class="markdownIt-Anchor" href="#java线程"></a> Java线程</h2><p>Java<strong>线程库是为开发人员提供创建和管理线程的一套 API</strong>。</p><p>有用户空间实现和内核空间实现</p><ul><li>用户空间一般用在无内核支持</li><li>内核空间用在内核支持线程, 一个API函数会调用内核的系统调用</li></ul><h4 id="主要线程库"><a class="markdownIt-Anchor" href="#主要线程库"></a> 主要线程库</h4><ol><li><p>POSIX Pthreads：可以作为用户或内核库提供，作为 POSIX 标准的扩展</p></li><li><p>Win32 线程：用于 Window 操作系统的内核级线程库</p></li><li><p>Java 线程：Java 线程 API 通常采用宿主系统的线程库来实现，也就是说在 Win 系统上，Java 线程 API 通常采用 Win API 来实现，在 UNIX 类系统上，采用 Pthread 来实现。</p></li></ol><blockquote><p>JDK1.2后, 是用内核级线程, 而针对不同的操作系统, 设计思路是不一样的</p><p><mark>JVM 中明确声明了：<strong>虚拟机中的线程状态，不反应任何操作系统中的线程状态</strong>。</mark></p></blockquote><p>JVM未限定 Java 线程模型, 可能是一对一, 多对多, or 多对一.</p></li></ol><h3 id="数据区域"><a class="markdownIt-Anchor" href="#数据区域"></a> 数据区域</h3><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-image-20220127221131896.png?raw=true" alt="image-20220127221131896" style="zoom:33%;" /><p>线程共有</p><ul><li><p>Java堆, 存放对象实例, Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p></li><li><p>方法区</p><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li></ul><p>线程私有</p><ul><li><p>虚拟机栈</p><ul><li><p>每个方法在执行的同时都会创建一个<mark>栈帧</mark>，用于存储局部变量表、操作数栈、动态链接、方法的返回地址等信息。</p></li><li><p><strong>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</strong>，当然，出栈的顺序自然是遵守栈的后进先出原则的。</p></li></ul></li><li><p>本地方法栈</p><p>与虚拟机栈相似, 但使用的方法是Native方法.</p><blockquote><p>Native方法, 在Java中仅仅是一个接口, 具体实现是由外部非Java语言编写, 所以同一个Native方法, 不同虚拟机调用它, 结果与运行效率不同, 每个虚拟机对native方法有着自己的实现</p></blockquote></li><li><p>程序计数器</p><p>如果线程正在执行的是一个 Java 方法，程序计数器中记录的就是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</p></li></ul><h3 id="线程的上下文切换发生"><a class="markdownIt-Anchor" href="#线程的上下文切换发生"></a> 线程的上下文切换发生</h3><p>从线程A转而执行另一个线程B, 需要保存线程A的状态信息, 同时恢复另一个线程B的状态</p><h4 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h4><ul><li>线程的CPU时间片用完</li><li>发生垃圾回收</li><li>有更高优先级线程需运行</li><li>线程自身调用sleep, yield, wait, join的等方法</li></ul><h2 id="java内存模型-又名jmm"><a class="markdownIt-Anchor" href="#java内存模型-又名jmm"></a> Java内存模型  又名JMM</h2><p>与操作系统中CPU, 内存, 硬盘的内存模型相似</p><p>JMM所有变量都存储在主内存, 每个线程还有自己的工作内存.</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-image-20220127222825686.png?raw=true" alt="image-20220127222825686" style="zoom: 33%;" /><h4 id="主内存"><a class="markdownIt-Anchor" href="#主内存"></a> 主内存</h4><p>所有变量都会存储在主内存</p><h4 id="工作内存-又名-local-memory"><a class="markdownIt-Anchor" href="#工作内存-又名-local-memory"></a> 工作内存 又名 Local Memory</h4><p>工作内存, 存储线程中使用的变量 (是主存的副本)</p><p>线程对变量的<mark>所有操作必须在工作内存进行, 不能直接读写主内存的数据</mark></p><blockquote><p>不然会出现缓存一致性问题, 即主内存数据与工作内存数据出现不一致问题且无法得知那个正确</p></blockquote><blockquote><p>变量包含实例字段、静态字段和构成数组对象的元素</p><p>并不包含局部变量和方法参数, 这些为线程私有, 不会被共享</p></blockquote><h3 id="原子性"><a class="markdownIt-Anchor" href="#原子性"></a> 原子性</h3><p>与mysql的原子性是一样的, 不可中断的步骤, 要么都做, 要么不做</p><h4 id="jmm中的8种原子操作"><a class="markdownIt-Anchor" href="#jmm中的8种原子操作"></a> JMM中的8种原子操作</h4><p>作用于主内存</p><ul><li>lock (锁定) 它把一个变量标识为一条线程独占的状态</li><li>unlock (解锁) 它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read (读取) 一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>write(写入) 它把store操作从工作内存中得到的变量的值放入主内存的变量</li></ul><p>作用于工作内存</p><ul><li>load (载入) 它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use(使用) 它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作</li><li>assign(赋值) 它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li>store (存储) 它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li></ul><h4 id="线程安全"><a class="markdownIt-Anchor" href="#线程安全"></a> 线程安全</h4><p><strong>一段代码在被多个线程访问后，它仍然能够进行正确的行为，那这段代码就是线程安全的</strong>。</p><h3 id="确保原子性"><a class="markdownIt-Anchor" href="#确保原子性"></a> 确保原子性</h3><p>Java通过锁和循环CAS方式.</p><h4 id="自带原子性"><a class="markdownIt-Anchor" href="#自带原子性"></a> 自带原子性</h4><p>根据JMM的8中原子操作, 可认为</p><ul><li>基本数据类型访问, 读写</li></ul><p>都是原子性</p><blockquote><p>long和double是非原子性的</p></blockquote><h4 id="synchronized关键字"><a class="markdownIt-Anchor" href="#synchronized关键字"></a> synchronized关键字</h4><h3 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h3><p>缓存一致性问题, 工作内存与主内存的延时.</p><blockquote><p>当一个线程修改共享变量, 其他线程应能立即得知修改</p></blockquote><p>根据JMM <strong>不同的线程通信过程必须要经过主内存</strong>。</p><h4 id="java中保证可见性"><a class="markdownIt-Anchor" href="#java中保证可见性"></a> java中保证可见性</h4><ul><li><p>volatile关键字</p><p>修饰共享变量</p></li><li><p>final关键字</p><blockquote><p>当然变量都不允许变化</p></blockquote></li><li><p>synchronized</p><blockquote><p><strong>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）</strong></p></blockquote></li></ul><h3 id="有序性"><a class="markdownIt-Anchor" href="#有序性"></a> 有序性</h3><p>并发执行时, CPU不保证每一次运行线程的执行顺序是相同的.</p><blockquote><p>Java编译器: 指令重排序</p><p>重排序满足 as-if-serial语义</p><p>不管怎么重排序, <strong>单线程</strong>环境下程序的执行结果不能被改变</p><p>而对于多个CPU执行多个线程, 是不满足的.</p></blockquote><p>CPU和编译器不会对存在<mark>数据依赖关系</mark>的操作进行重排序, 因为对此重排序会改变执行结果</p><blockquote><p>数据依赖关系</p><p>有两个操作访问同一个变量, 且操作A为写操作, 操作B需要拿到A写操作后的结果. 若B先进行读, 然后A再执行写操作. 两个结果为不一致.</p></blockquote><p>java程序天然的有序性</p><ul><li>线程内所有操作都是有序的</li><li>一个线程看另一个线程, 所有操作都是无序的</li></ul><h4 id="java确保有序性"><a class="markdownIt-Anchor" href="#java确保有序性"></a> Java确保有序性</h4><ul><li><p>volatile</p></li><li><p>synchronized</p><blockquote><p><strong>一个变量在同一个时刻只允许一条线程对其进行 lock 操作</strong></p></blockquote></li><li><p>Happens-before原则</p><p>用于判断数据是否存在竞争，线程是否安全的非常有用的手段.</p></li></ul><h2 id="happens-before原则"><a class="markdownIt-Anchor" href="#happens-before原则"></a> Happens-before原则</h2><p>Happens-before是为了防止在多线程情况下, 指令重排序的影响 , 保证内存的<mark>可见性</mark>和<mark>有序性</mark>.</p><p>可见性实现</p><ul><li>写完要将工作内存flush到主内存</li><li>读前要先从主内存中重新获取,</li></ul><p>有序性实现</p><ul><li>缩小或禁止指令重排序</li></ul><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><ol><li><p>JMM 对程序员强内存模型的承诺。</p><blockquote><p>“<strong>强内存模型</strong>”: 希望内存模型易于理解、易于编程</p><p>“<strong>弱内存模型</strong>”: 编译器和处理器希望内存模型的约束越少越好, 这样能尽可能多的优化</p></blockquote><p>若A Happens-before B, 那么<mark>仅JMM</mark>会向程序员保证, A的操作结果对B可见</p></li><li><p><strong>只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器允许调整语句的执行顺序</strong>。</p></li></ol><h3 id="happens-before规则"><a class="markdownIt-Anchor" href="#happens-before规则"></a> Happens-before规则</h3><ul><li><p>管程锁定</p><p>synchronized中的变量只允许在synchronized内重排序, 不允许到重排序出synchronized范围外</p><p>还有一个是解锁操作必须放在加锁操作之后</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 重排序不允许将下列语句放到synchronized块之外.</span></span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>管程: 结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享資源。</p></blockquote></li><li><p>volatile 变量</p><p>对一个volatile变量的写语句, 禁止指令重排序, 执行顺序 == 语句顺序,</p><blockquote><p>语句顺序中在volatile写语句之前, 执行顺序也只能在volatile写语句之前执行</p></blockquote><p>而对一个volatile变量的读语句,  禁止指令重排序, 执行顺序 == 语句顺序,</p><blockquote><p>语句顺序在volatile读语句之后的, 执行顺序也只能在volatile读语句之后执行</p></blockquote></li><li><p><strong>线程启动规则</strong>：Thread 对象的 start() 方法先行发生于此线程的每一个动作。</p></li><li><p>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread 对象的 join() 方法是否结束、Thread 对象的 isAlive() 的返回值等手段检测线程是否已经终止执行。</p></li><li><p><strong>线程中断规则</strong>: 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread 对象的 interrupted() 方法检测到是否有中断发生</p></li><li><p><strong>对象终结规则</strong>（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p></li><li><p>传递性</p></li></ul><h2 id="创建线程"><a class="markdownIt-Anchor" href="#创建线程"></a> 创建线程</h2><p>线程可以分为任务Runnable与线程本身Thread</p><h4 id="三种方法"><a class="markdownIt-Anchor" href="#三种方法"></a> 三种方法</h4><ul><li><p>线程与任务合并</p><p>线程创建用于执行一些特定任务</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可见Thread类是应用Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义线程对象</span></span><br><span class="line"><span class="keyword">public</span> MyThread extends Thread &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程需执行的任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以添加线程名字 new myThread(&quot;t1&quot;);</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br></pre></td></tr></table></figure><ul><li><p>任务与线程分离  <mark>推荐使用</mark></p><p>用于多个线程执行同一个任务.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(), <span class="string">&quot;name 是可选的&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Thread + Callable接口</p><p>Runnable不能获取任务执行结果, 因为run方法返回是void类型</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable不能直接传给Thread, 需要包装成Runnable类型, 而FutureTask&lt;&gt; 间接继承Runnable接口并且FutureTask&lt;&gt;接口定义可以获取 call() 返回值的方法 get()</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyCallable callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line"><span class="comment">// 将callable包装为FutureTask实例</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line"><span class="comment">// 传入Thread</span></span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(task);</span><br><span class="line">t3.start();</span><br><span class="line"><span class="comment">// 会阻塞调用该方法的线程, 只有call方法成功返回, 才会继续执行</span></span><br><span class="line">Integer result = task.get();</span><br></pre></td></tr></table></figure></li></ul><h2 id="启动线程"><a class="markdownIt-Anchor" href="#启动线程"></a> 启动线程</h2><p>虽然任务都写在Thread的run方法, 但启动线程调用的是start方法. 因为<mark>start方法会完成线程初始化的工作后, 再调用run方法</mark>, 而直接调用run方法并没有开启新线程, 跟普通方法一样, 在当前线程执行run方法, 并没有启动一个新线程.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  TODO;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"><span class="comment">// NOT t1.run()</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h2 id="线程状态"><a class="markdownIt-Anchor" href="#线程状态"></a> 线程状态</h2><ul><li><p>NEW状态</p><p>初始状态，线程被创建出来但是还没有开始运行，也就是还没有调用 start 方法。</p><blockquote><p>对应操作系统中的新建态</p></blockquote></li><li><p>RUNNABLE状态</p><p>线程已经运行</p><blockquote><p>对应操作系统的中运行态</p></blockquote></li><li><p>BLOCKED状态</p><p>线程阻塞状态.</p><p>当线程尝试获取synchronized锁住的对象时, 竞争锁失败, 线程会进入BLOCKED状态.</p><p>当线程从BLOCKED状态得知synchronized锁住对象解锁后, 重新变为Runnable, 再一次进入synchronized区域或方法竞争锁.</p></li><li><p>WAITING状态</p><p>进入等待状态的线程需要依靠其他线程的通知才能回到RUNNABLE状态.</p><p>从RUNNABLE变为WAITING状态有以下三种方法</p><ul><li><p>调用Object.wait</p></li><li><p>调用Thread.join</p><blockquote><p>主线程调用join方法, 会等待子线程运行完再继续回字形</p></blockquote></li><li><p>调用LockSupport.park</p></li></ul><p>从WAITING状态变为RUNNABLE状态</p><ul><li>调用object.notify</li><li>调用object.notifyAll</li><li>调用LockSupport.unpark</li></ul></li><li><p>TIMED_WAITING状态</p><p>在指定时间从WAITING变为RUNNABLE状态</p></li><li><p>TERMINATED状态</p><p>终止状态</p></li></ul><h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2><p>锁用于控制多个线程访问共享资源.</p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><ul><li><p>是否锁住共享资源</p><ul><li>悲观锁</li><li>乐观锁</li></ul></li><li><p>锁住共享资源失败, 线程是否要阻塞</p><ul><li>自旋锁</li><li>适应性自旋锁</li></ul></li><li><p>针对synchronized关键字</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul></li><li><p>竞争锁时, 是否允许插队</p><ul><li>公平锁</li><li>非公平锁</li></ul></li><li><p>锁只能单\多个线程持有</p><ul><li>排它锁</li><li>共享锁</li></ul></li></ul><h4 id="悲观与乐观"><a class="markdownIt-Anchor" href="#悲观与乐观"></a> 悲观与乐观</h4><p>悲观锁认为一定有别的线程修改数据, 所以获取数据要加锁, 确保不会被别的线程修改</p><blockquote><p>synchronized与Lock接口属于悲观锁</p></blockquote><p>乐观锁认为线程别的线程不会修改数据, 不会添加锁, 仅在提交前判断, 是否有数据修改该线程.</p><ul><li><p>没有修改, 直接写入</p></li><li><p>发生修改, 执行不同的操作</p><blockquote><p>报错或自动重试</p></blockquote></li></ul><p>CAS算法实现, JUC包的原子类实现乐观锁</p><blockquote><p>CAS属于无锁编程, Compare and set</p></blockquote><h4 id="自旋与自旋适应"><a class="markdownIt-Anchor" href="#自旋与自旋适应"></a> 自旋与自旋适应</h4><p>阻塞或唤醒一个Java线程是要切换到内核态的, 性能会有所损耗.</p><p>一般情况下, 线程获取锁失败会变为阻塞状态. 但有时, 线程若能多等一会, 锁释放, 直接获取, 从而避免阻塞和唤醒操作.</p><blockquote><p>多等一会 == 自旋, 就是dowhile循环, 空转.</p></blockquote><p>若一直等, 那会过分占用处理器时间, 所以设有自旋次数, 当自旋超过设定次数后, 便变为阻塞状态.</p><p><strong>自旋适应</strong>由JDK1.6引入, 自旋次数由JVM根据前一次同一个锁的自旋时间等信息, 动态调整自旋次数.</p><h4 id="无锁-偏向锁-轻量级锁-重量级锁"><a class="markdownIt-Anchor" href="#无锁-偏向锁-轻量级锁-重量级锁"></a> 无锁 | 偏向锁 | 轻量级锁 | 重量级锁</h4><p>解锁, 加锁会有一定消耗, 为减少锁的开销, 引入偏向锁, 轻量级锁</p><ul><li><p>偏向锁, 偏心锁</p><p>基于原理: 大多数情况, 锁不存在多线程竞争, 且总是由同一个线程多次获得</p><p><mark>等到锁竞争才会释放锁</mark></p></li><li><p>轻量级锁</p><p>当线程持有的锁是偏向锁且有另一个线程竞争该锁, 则变为轻量级锁.</p></li><li><p>重量级锁</p><p>当竞争线程数量大于2, 变为重量级锁</p><blockquote><p>重量级锁有自旋操作, 且可能会阻塞, 需要由操作系统唤醒, 重新竞争.</p></blockquote></li></ul><h4 id="公平锁"><a class="markdownIt-Anchor" href="#公平锁"></a> 公平锁</h4><p>多个线程按照申请锁的顺序获取锁.</p><p>优点:</p><ul><li>不会饿死</li></ul><h4 id="非公平锁"><a class="markdownIt-Anchor" href="#非公平锁"></a> 非公平锁</h4><p>线程会尝试获取锁, 即插队, 若插入失败, 那么排队.</p><p>优先:</p><ul><li>插队成功, 可减少唤醒开销.</li></ul><p>但会可能饿死</p><p>synchronized是非公平锁</p><h4 id="可重入锁"><a class="markdownIt-Anchor" href="#可重入锁"></a> 可重入锁</h4><p>同一个线程在外层方法获取锁时, 进入该线程的内部方法也会自动获取锁. <mark>不会因为之前已经获取锁没释放而阻塞</mark></p><p>反之为不可重入锁</p><blockquote><p>synchronized为可重入锁</p></blockquote><h4 id="排他锁"><a class="markdownIt-Anchor" href="#排他锁"></a> 排他锁</h4><p>该锁一次只能被一个线程所持有, 允许读写</p><blockquote><p>synchronized为排他锁</p></blockquote><p>属于悲观锁一种</p><h4 id="共享锁"><a class="markdownIt-Anchor" href="#共享锁"></a> 共享锁</h4><p>该锁能被多个线程持有, 但只允许读操作, 属于乐观锁</p><h2 id="synchronized关键字-2"><a class="markdownIt-Anchor" href="#synchronized关键字-2"></a> synchronized关键字</h2><p><mark>Java中每一个对象都可作为锁</mark></p><h3 id="基本使用"><a class="markdownIt-Anchor" href="#基本使用"></a> 基本使用</h3><ol><li><p>锁住函数</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="comment">// 锁是Test对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">  <span class="comment">// 锁是Test类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>锁住方法块</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object room = <span class="keyword">new</span> Object(); <span class="comment">// 声明一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 锁住room对象</span></span><br><span class="line">  <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">    <span class="comment">// 只有获得room的锁, 才能进入该块, 否则阻塞, 退出或抛出异常必须释放锁</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>当一个线程试图访问同步方法或者同步方法块时，它首先必须得到锁才能进入这些代码块，并且退出或抛出异常时必须释放锁</strong></p></blockquote></li></ol><p>是给实例或类配一把锁, 要声明一个类用于充当锁的角色</p><h3 id="内存语义"><a class="markdownIt-Anchor" href="#内存语义"></a> 内存语义</h3><p>无论是synchronized还是Lock接口实现类, 都一样.</p><ul><li><p>锁释放</p><p>当线程释放锁时, JMM会将线程本地内存中的共享变量<mark>刷新</mark>到主内存</p></li><li><p>锁获取</p><p>线程获取锁时, JMM将线程内存设为失效, 强迫读取主内存</p></li></ul><h3 id="什么是锁"><a class="markdownIt-Anchor" href="#什么是锁"></a> 什么是锁</h3><p>synchronized修饰的方法块, 在JVM编译时, 会在开始与结束多加指令monitorenter与monitorexit.</p><blockquote><p>JVM依靠<code>monitorenter</code>与<code>monitorexit</code>, 实现同步</p></blockquote><p><mark>监视器为Java中锁的实现.</mark> 任何一个对象都与一个监视器( monitor )相关联.</p><p>当一个监视器有拥有者时, 监视器会被锁定.</p><blockquote><p>只有拥有监视器(对应尝试获得锁)才能在执行相关指令.</p></blockquote><h3 id="monitor-监视器-管程"><a class="markdownIt-Anchor" href="#monitor-监视器-管程"></a> monitor 监视器 管程</h3><p>操作系统中管程, 用于管理进程同步与互斥机制. 一个时刻只能有一个进程使用管程.</p><blockquote><p>信号量当然也能代替管程, 但管程封装较好</p></blockquote><p>每一个对象都关联一个monitor,</p><p>对象在堆内存中布局分为对象头, 实例数据, 对齐填充.</p><p>对象头中包含</p><ul><li><p>Mark Work</p><p>包含hashCode和<mark>锁信息</mark>等,</p><blockquote><p>与监视器有骨感</p></blockquote></li><li><p>类型指针</p></li><li><p>数组长度</p></li></ul><h2 id="synchronized锁优化技术"><a class="markdownIt-Anchor" href="#synchronized锁优化技术"></a> Synchronized锁优化技术</h2><p>在JDK1.6后, synchronized锁因出现轻量级, 偏向🔐, 适应性自旋等技术. 使得锁性能得到提高.</p><blockquote><p>Java线程多是映射到操作系统内核中, 一些简单的同步块, 可通过自旋避免陷入内核态的阻塞. 减少操作系统干预.</p></blockquote><p>synchronized锁有四种级别, 开销从低到高为</p><ul><li>无锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li></ul><p>锁只能升级不能降级, 称为<mark>锁膨胀过程</mark></p><blockquote><p>为提高获得锁和释放锁的效率</p></blockquote><h4 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁"></a> 偏向锁</h4><p>偏心锁, 锁会偏向于第一个获得它的线程</p><blockquote><p>该锁的适用场景, 锁不存在多线程竞争且由同一个线程多次获得. 将锁重入的CAS操作也省略</p></blockquote><p>如果一个锁从来未被其他线程获取, 那么持有偏向锁的线程, 默认一直拥有该锁. 直到有其他线程竞争该锁.</p><blockquote><p>默认拥有时, 只需设置一次Thread ID</p></blockquote><ul><li><p>撤销</p><ol><li>JVM会暂停拥有偏向锁的线程. 判断该线程是否存活</li><li>将偏向锁升级为轻量级锁</li></ol></li></ul><h4 id="轻量级锁"><a class="markdownIt-Anchor" href="#轻量级锁"></a> 轻量级锁</h4><p>用于<mark>无多线程竞争</mark>前提下. 用CAS操作消除同步使用的互斥量.</p><blockquote><p>CAS可避免切换开销</p></blockquote><p>加锁步骤</p><ul><li><p>获得同步对象, 在marwork中标记</p></li><li><p>锁记录</p><p>当前线程的栈帧建立一个锁记录, 用于后序存储对象MarkWord的拷贝</p><blockquote><p>必须要对加锁的进行记录, 只有当加锁次数 == 解锁次数, 才能释放锁</p></blockquote></li><li><p>赋值锁对象的MarkWord到锁记录中</p></li><li><p>利用CAS操作更新对象的MarkWord</p></li></ul><h4 id="重量级锁"><a class="markdownIt-Anchor" href="#重量级锁"></a> 重量级锁</h4><p>JDK1.6之前的synchronized都是重量级锁. 因为<mark>阻塞和唤醒都需要操作系统切换用户态和核心态.</mark></p><h3 id="volatile-与双重校验锁"><a class="markdownIt-Anchor" href="#volatile-与双重校验锁"></a> Volatile 与双重校验锁</h3><h4 id="指令重排序"><a class="markdownIt-Anchor" href="#指令重排序"></a> 指令重排序</h4><blockquote><p>先不考虑内存可见性问题</p></blockquote><p>在单线程的情况下, CPU处于执行效率, 会对程序语句进行重排序. 并保证不会影响结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单线程情况下, 编写的语句顺序</span></span><br><span class="line">c = a + b;</span><br><span class="line">d = a + c;</span><br><span class="line">f = g + h;</span><br><span class="line"><span class="comment">// 可见第4行语句与第2, 3行语句无关, 所以第4行语句重排序时, 可放到2, 3语句执行之前.</span></span><br><span class="line"><span class="comment">// 执行顺序可以为 4, 2, 3 | 2, 4, 3 | 2, 3, 4 只要保证2执行与3之前. </span></span><br></pre></td></tr></table></figure><p>但在多线程的情况下, 指令重排序会带来意想不到的错误.</p><p>考虑以下情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrameInstaller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> frameCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> Frame frame;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasFrame = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    frameCount++;</span><br><span class="line">    frame = <span class="keyword">new</span> Frame();</span><br><span class="line">    hasFrame = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Frame <span class="title">getFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待, 直到有frame时退出</span></span><br><span class="line">    <span class="keyword">while</span>(!hasFrame) &#123;&#125;</span><br><span class="line">    frameCount--;</span><br><span class="line">    Frame output = frame;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个线程A, B. A执行putFrame函数, B执行getFrame函数. 两个CPU分别执行A, B.</p><p>单独看putFrame,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameCount++;</span><br><span class="line">frame = <span class="keyword">new</span> Frame();</span><br><span class="line">hasFrame = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>CPU认为这三行语句是可以重排序的. 因为仅看该函数, 执行顺序并不会影响该函数的结果. 最后都是三个变量值被修改. 且三个变量谁先执行都没关系.</p><p>假设重排序后, A的执行顺序是3 2 1, 而B的执行顺序与语句顺序一致.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发生指令重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    hasFrame = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// A还没执行以下语句, A被调度走了</span></span><br><span class="line">    frameCount++;</span><br><span class="line">    frame = <span class="keyword">new</span> Frame();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Frame <span class="title">getFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// B看见hasFrame = true, 执行后面语句</span></span><br><span class="line">    <span class="keyword">while</span>(!hasFrame) &#123;&#125;</span><br><span class="line">    <span class="comment">// 问题发生, 此时frameCount和frame都没有赋值, getFrame会返回的旧值!!!</span></span><br><span class="line">    frameCount--;</span><br><span class="line">    Frame output = frame;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="volatile中的happen-before"><a class="markdownIt-Anchor" href="#volatile中的happen-before"></a> Volatile中的Happen - before</h4><p>happen - before出来解决该问题. A happen before B == A 一定在B之前先执行. 通过<mark>禁止指令重排序实现.</mark></p><p>解决上述问题, 只需要加一个<code>volatile</code>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasFrame = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   frameCount++;</span><br><span class="line">   frame = <span class="keyword">new</span> Frame();</span><br><span class="line">   <span class="comment">// 由于有volatile修饰, hasFrame一定是最后执行的, 不允许将hasFrame = true;语句优先执行, 而位于该语句上面的语句, 执行顺序允许重排序</span></span><br><span class="line">   hasFrame = <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Frame <span class="title">getFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 等待, 直到有frame时退出</span></span><br><span class="line">   <span class="comment">// 由于有volatile修饰, 一定要先执行 读hasFrame, 后面的语句允许重排序. 但只有!hasFrame必须在其余语句之前先执行.</span></span><br><span class="line">   <span class="keyword">while</span>(!hasFrame) &#123;&#125;</span><br><span class="line">   frameCount--;</span><br><span class="line">   Frame output = frame;</span><br><span class="line">   <span class="keyword">return</span> output;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4><p>定量被定义为Volatile, 具有两项特性</p><ul><li><p>保证所有线程对该变量的可见性</p><blockquote><p>其余变量需要经过工作内存和主内存才对外可见, 会出现内存可见性问题, 即脏读</p></blockquote><p>实现:</p><p>通过信号量是实现</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 线程 A</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 线程 B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>禁止指令重排序</p></li></ul><p>单例模式中的双重校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line"><span class="comment">// 私有化构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span></span>&#123;&#125;; </span><br><span class="line"><span class="comment">// 一定要用volatile修饰, 禁止指令重排序, 防止因为指令重排序而导致对象未完成初始化而被访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingleTon instance = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 第一次校验, 防止重复构建新的实例</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;     </span><br><span class="line">              <span class="comment">// 此处可能有多个线程通过第一次校验</span></span><br><span class="line">                <span class="keyword">synchronized</span> (SingleTon.class) &#123;</span><br><span class="line">                   <span class="comment">// 这里由于封锁类, 所以只会有一个线程进入, 若实例已经创建, 那么因第二层校验直接跳过.</span></span><br><span class="line">                       <span class="comment">// 第二次校验, 防止多个线程通过经过第一次校验, 导致重复构建多个实例</span></span><br><span class="line">                        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;     </span><br><span class="line">                            instance = <span class="keyword">new</span> SingleTon();</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="final保证可见性"><a class="markdownIt-Anchor" href="#final保证可见性"></a> Final保证可见性</h3><p>volatile, synchronized, final都能保证内存可见性</p><blockquote><p>即不会脏读</p></blockquote><p>JDK1.5前, 有一个缺陷, final域的值会变, 可能会发生, 一个线程访问尚未初始化的final值.</p><p>通过给final域增加写和读重排序规则实现.</p><p>只要程序员保证</p><ul><li><p>对象正确构造, 即没有发生this引用逃逸.</p><blockquote><p>this引用逃逸</p><p>在构造函数执行时, 允许外部访问this指针.</p></blockquote></li></ul><p>在构造函数中的普通域变量赋值可能会因为指令重排序, 导致放到构造函数后执行. 导致在对象构造完后, 由于普通域尚未进行赋值, 导致发生脏读. 其他线程读取到普通域尚未初始化的值</p><h2 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h2><p>compare and set</p><p>无锁编程, 在不使用锁的情况下保证线程安全.</p><blockquote><p>CAS属于一个算法, CAS可以实现乐观锁</p></blockquote><p>用于保证线程同步更新主内存</p><blockquote><p>多个线程同一个时刻更新主内存同一个变量, 只有一个线程可以成功</p></blockquote><h3 id="操作数"><a class="markdownIt-Anchor" href="#操作数"></a> 操作数</h3><p>比较并替换</p><ul><li>需要读写的主内存位置</li><li>变量原有值</li><li>线程将要变化为的值</li></ul><blockquote><p>主内存中当前值与原有值匹配, 线程将变量更新为新值</p><p>不匹配, 则更新失败, 自旋重试</p></blockquote><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-1640878086-zvcjRc-image.png?raw=true" alt="image.png" style="zoom:50%;" /><h3 id="三大问题"><a class="markdownIt-Anchor" href="#三大问题"></a> 三大问题</h3><h4 id="aba问题"><a class="markdownIt-Anchor" href="#aba问题"></a> ABA问题</h4><p>原变量已经变了两次, 又变为与原变量一样的值. 如何识别该变量已经被修改过?</p><p>添加版本号, 每次修改版本号 + 1</p><h4 id="只能保证一个共享变量的原子操作"><a class="markdownIt-Anchor" href="#只能保证一个共享变量的原子操作"></a> 只能保证一个共享变量的原子操作</h4><p>若想同时原子地修改两个以上的共享变量, 需要利用合并操作, 将其视为一个变量操作.</p><h4 id="循环时间开销长"><a class="markdownIt-Anchor" href="#循环时间开销长"></a> 循环时间开销长</h4><h2 id="unsafe类"><a class="markdownIt-Anchor" href="#unsafe类"></a> Unsafe类</h2><p>非安全类, 允许直接操作内存.</p><h3 id="功能点"><a class="markdownIt-Anchor" href="#功能点"></a> 功能点</h3><ul><li>线程调度</li><li>内存屏障, 用于防止指令重排序</li><li>获取内存页大小</li><li>内存操作(克隆, 分配, 拷贝等)</li><li>动态创建类, 检测确保类初始化</li></ul><p>…</p><p><mark>Unsafe类中的所有方法都被native修饰</mark>,</p><blockquote><p>仅有接口, 具体实现是通过调用底层操作系统API</p></blockquote><p>J.U.C包中调用许多Unsafe类的方法, 可视为是Unsafe的包装类</p><blockquote><p>J.U.C对应全名为 java.util.concurrent.atomic. 使用Unsafe类的CAS操作用无锁方式保证数据更新是线程安全的, 方法高效</p></blockquote><p>最常调用的方法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapXxx</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object expected, Object update)</span></span></span><br></pre></td></tr></table></figure><ul><li>o为修改字段的对象</li><li>offset是对象内存偏移量</li><li>expected是期望值</li><li>update是要设置的值</li></ul><h3 id="原子类"><a class="markdownIt-Anchor" href="#原子类"></a> 原子类</h3><p>位于J.U.C包内一个子包, Atomic包.</p><p>包含许多线程安全类的基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger integer = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// addAndGet为加1后返回</span></span><br><span class="line">        <span class="keyword">int</span> addVal = integer.addAndGet(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> tmpGet = integer.get();</span><br><span class="line">        System.out.println(addVal);</span><br><span class="line">        System.out.println(tmpGet);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java仅提供int, long, boolean类型的原子类</p><p>而char可通过升级为int解决</p><p>float与double则要</p><blockquote><p><em>you can use an <code>AtomicInteger</code>to hold byte values, and cast appropriately. <strong>You can also hold floats using <code>Float.floatToIntBits</code> and <code>Float.intBitstoFloat</code> conversions, and doubles using <code>Double.doubleToLongBits</code> and <code>Double.longBitsToDouble</code> conversions.</strong></em></p></blockquote><h2 id="aqs"><a class="markdownIt-Anchor" href="#aqs"></a> AQS</h2><blockquote><p>Abstract Queue Synchronizer AQS 队列同步器</p><p><code>模板设计模式</code></p></blockquote><p>Java锁的另一套实现, 一套为synchronized关键字, 一套为Lock接口的类</p><blockquote><p>synchronized锁简化操作, 将锁的获取和释放隐藏. 会自动尝试获取锁</p></blockquote><p>而AQS则是采用<mark>一个双向队列</mark>来完成对线程获取资源时候的<mark>排队工作</mark>的</p><blockquote><p>队列中存放多个需要该资源的线程. 每次只有队首才能获得资源并弹出队列. (如果是独占式的)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Lock</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Lock接口允许在获取一把锁的情况下, 获得另一把锁.  对锁的获取和释放更为自由</p><blockquote><p>synchronized也行, 但如同嵌套函数, 无法释放外层锁,</p></blockquote><h3 id="基本方法"><a class="markdownIt-Anchor" href="#基本方法"></a> 基本方法</h3><p>待重写方法</p><table><thead><tr><th>返回参数</th><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>boolean</td><td>tryAcquire(int arg)</td><td>在AQS抽象类中, 可通过重写该类, 实现公平或非公平获得锁</td></tr><tr><td>boolean</td><td>tryRelease(int arg)</td><td>在AQS抽象类中, 可通过重写该类, 自定义选择要唤醒的线程, 并给与其锁</td></tr><tr><td>int</td><td>tryAcquireShared(int arg)</td><td>重写该类, 实现共享锁中公平或非公平获取</td></tr><tr><td>boolean</td><td>tryReleaseShared(int )</td><td>重写该类, 实现共享锁中, 要唤醒的线程</td></tr></tbody></table><p>提供方法不可修改</p><table><thead><tr><th>返回参数</th><th>方法名称</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>acquire(int arg)</td><td>独占式获取同步状态, 成功则返回, 否则进队列中等待</td></tr><tr><td>void</td><td>acquireShared(int arg)</td><td>共享式获取同步状态, 成功则返回, 否则进队列中等待<br />同一个时刻允许多个线程获取同步状态</td></tr><tr><td>boolean</td><td>release(int arg)</td><td>独占式释放同步状态并唤醒队首线程</td></tr><tr><td>boolean</td><td>releaseShared(int arg)</td><td>共享式的释放同步状态</td></tr><tr><td>Collection&lt;Thread&gt;</td><td>getQueuedThreads()</td><td>获取等待在同步队列中的线程集合</td></tr></tbody></table><h3 id="aqs两种模式"><a class="markdownIt-Anchor" href="#aqs两种模式"></a> AQS两种模式</h3><ul><li>独占Exclusive</li><li>共享Share</li></ul><p>AQS所有子类只会使用其中一种. <mark>不存在一个子类同时使用独占和共享模式</mark></p><h4 id="独占"><a class="markdownIt-Anchor" href="#独占"></a> 独占</h4><p>同一个时刻仅有一个线程尝试获取锁, 其余只能在队列等待.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 若无法获取锁, 会将锁放入queue中, tryAcquire允许重写, 实现非公平竞争</span></span><br><span class="line">  <span class="keyword">if</span>(!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">     <span class="comment">// 只有等待过后, 然后获得锁, 才会执行selfInterrupt, 方法结束</span></span><br><span class="line">     selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取锁失败的线程都会通过 CAS 操作被加入到队列尾端，<mark>并且在队列中无限自旋等待获取锁</mark>；</p></blockquote><p>获取锁流程图</p><img src="https://pic.leetcode-cn.com/1640878714-SqusUj-image.png" alt="图片来源《Java 并发编程的艺术》" style="zoom:50%;" /><p>释放锁</p><p>步骤</p><ul><li>释放锁</li><li>利用CAS操作唤醒当前节点的后继节点尝试获得锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="共享"><a class="markdownIt-Anchor" href="#共享"></a> 共享</h4><p>同一时刻允许多个线程同时获得同步状态(锁)</p><p>获得锁</p><p>acquireShared. 尝试获取, 若失败会调用doAcquireShared方法 (与独占锁tryAcquire一样). 失败会无限自旋获取锁.</p><p>释放锁</p><p>也与独占锁类似, 释放锁后会唤醒后继节点.</p><p>但由于共享锁会有多个线程同时释放锁的可能, 所以需要CAS操作 + 循环 保证共享锁成功释放.</p><h3 id="lock接口-aqs的应用"><a class="markdownIt-Anchor" href="#lock接口-aqs的应用"></a> Lock接口        AQS的应用</h3><p>Lock接口仅有6个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"><span class="comment">// 尝试获取锁, 获得锁后返回</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 可中断的获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 尝试非阻塞获取锁. 调用后立即返回, 得到为true, 否则为false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 指定非阻塞时间的获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 当前线程获得锁才能调用</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock接口的实现通过聚合一个AQS的子类完成线程访问控制.</p><p>AQS是使用<code>模板方法设计模式</code>.</p><blockquote><p>模板方法设计模式, 父类提供一些不可被子类重写的方法, 整体的骨架(模板)不可改变, 但具体实现细节可有子类重写.</p></blockquote><p>一个抽象类, 用于构建锁或其他同步组件的基本框架. 利用内置FIFO双向队列(名为CLH)完成线程获取资源的排队工作.</p><p>使用volatile修改的int成员变量<code>state</code>表示同步状态.</p><blockquote><p>同步状态:</p><p>当加锁时, 利用CAS操作 state+1</p><p>解锁时, CAS操作 state - 1</p></blockquote><p>步骤为</p><ul><li>请求锁资源失败, 放入CLH队列末尾.</li><li>持有锁的线程释放锁后, 会唤醒后继节点, 让其尝试获取锁</li></ul><h3 id="reentrantlock-可重入锁-lock接口的实现"><a class="markdownIt-Anchor" href="#reentrantlock-可重入锁-lock接口的实现"></a> ReentrantLock 可重入锁  Lock接口的实现</h3><p>ReentrantLock本质是调用<code>NonfairSync</code>与<code>FairSync</code>.</p><h2 id="线程出错例子"><a class="markdownIt-Anchor" href="#线程出错例子"></a> 线程出错例子</h2><p>三个线程同时执行counter++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// i要足够大才能出现问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; ++i) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; ++i) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//  本应是 100000 * 3, 但输出值会随机变化</span></span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用CAS中的原子整数解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 利用CAS解决</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">                counter.addAndGet(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; ++i) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; ++i) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用synchronized解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span>  Integer counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 要锁住整个Solution类, 因为是static变量, 是属于类而非对象</span></span><br><span class="line">          <span class="comment">// 或者声明一个final Object类, 仅用于上锁 synchronized(lock)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Solution.class) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">                    counter += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; ++i) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; ++i) &#123;</span><br><span class="line">            threads[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合框架-collection"><a class="markdownIt-Anchor" href="#集合框架-collection"></a> 集合框架 Collection</h3><p>单列集合Collection</p><p>双列集合Map</p><blockquote><p>接口与实现分离</p></blockquote><h3 id="collection三个子接口"><a class="markdownIt-Anchor" href="#collection三个子接口"></a> Collection三个子接口</h3><ul><li><p>List</p><p>元素有序, 可重复</p><ul><li>ArrayList</li><li>LinkedList</li></ul></li><li><p>Set</p><p>元素无需, 拒绝添加重复元素</p><ul><li>HashSet</li><li>LinkedHashSet</li></ul></li><li><p>Queue</p><p>单向队列</p></li></ul><h3 id="map接口"><a class="markdownIt-Anchor" href="#map接口"></a> Map接口</h3><p>每个元素由键值组成, 通过键可以找到对应的值</p><blockquote><p>不能包含重复键, 一个键对应一个值</p></blockquote><p>实现有</p><ul><li><p>HashMap</p><blockquote><p>由数组(小容量) 红黑树(大容量)实现, 链表解决哈希冲突</p></blockquote></li><li><p>LinkedHashMap</p><p>保证存取顺序一致</p></li></ul><h2 id="线程不安全的集合"><a class="markdownIt-Anchor" href="#线程不安全的集合"></a> 线程不安全的集合</h2><p>部分集合都是线程不安全, 而J.U.C为每一个类集合提供线程安全的实现. 线程安全的集合都是以Concurrent或CopyOnWrite开头.</p><ul><li><p>Concurrent开头集合采用比较复杂的算法保证<mark>永远不会锁住整个集合</mark>. 并发写有较好的性能</p></li><li><p>CopyOnWrite 开头采用<mark>写时复制</mark>支持并发读</p><blockquote><p>写时复制是指, 添加元素时是先拷贝出一个副本, 在副本中修改, 再将原集合引用指向该副本. 允许并发读而不加锁</p></blockquote><p>即读写分离</p></li></ul><h3 id="线程安全的collection接口"><a class="markdownIt-Anchor" href="#线程安全的collection接口"></a> 线程安全的Collection接口</h3><ul><li><p>List</p><ul><li><p>Vector</p><blockquote><p>ArrayList的操作加一层synchronized</p></blockquote></li><li><p>CopyOnWriteArrayList</p></li></ul></li><li><p>Set</p><ul><li>CopyOnWriteArraySet</li><li>ConcurrentSkipListSet</li></ul></li><li><p>Queue</p><ul><li>…</li></ul><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-1640936848-wsrdQE-image.png?raw=true" alt="image.png" /></p></li></ul><h3 id="线程安全的map接口"><a class="markdownIt-Anchor" href="#线程安全的map接口"></a> 线程安全的Map接口</h3><ul><li>HashTable</li><li>ConcurrentMap接口<ul><li><code>ConcurrentHashMap</code></li><li><code>ConcurrentSkipListMap</code></li></ul></li></ul><h3 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h3><p>由Segment数组 + HashEntry 数组构成</p><ul><li><p>Segment</p><p>一种可重入锁</p></li><li><p>HashEntry</p><p>存储数据</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 真正存放数据的地方</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        <span class="keyword">this</span>.table = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构成关系</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-image-20220214210653596.png?raw=true" alt="image-20220214210653596" style="zoom:50%;" /><p>每一线程访问HashEntry存储的数据会占用一个Segment锁, 但不会影响到其他Segment</p><blockquote><p>事实上, JDK会hash两次, 第一次用于定位Segment, 第二次用于HashEntry搜寻</p><p>而且两次哈希能使得数据均匀分布</p></blockquote><h4 id="put操作"><a class="markdownIt-Anchor" href="#put操作"></a> put操作</h4><ol><li>先定位Segment, 并尝试获取Segment锁, 失败会自旋</li><li>获得锁后,判断HashEntry否需要扩容</li><li>将数据插入到HashEntry</li></ol><h4 id="get操作"><a class="markdownIt-Anchor" href="#get操作"></a> get操作</h4><ol><li>Key通过Hash定位到具体Segment</li><li>通过一次Hash定位到具体元素上</li></ol><h4 id="jdk18改进"><a class="markdownIt-Anchor" href="#jdk18改进"></a> JDK1.8改进</h4><p>ConcurrentHashMap变为包含一个Node数组, <mark>每一个Node都为链表结构, 链首</mark>, 且当长度大于一定值会转为红黑树</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-image-20220214211537636.png?raw=true" alt="image-20220214211537636" style="zoom:50%;" /><p>利用synchronized + CAS保证并发安全</p><p>Node数组 == 一个哈希桶, 只要锁住Node头, 不会影响到其他哈希桶数组元素的读写.</p><h4 id="put方法"><a class="markdownIt-Anchor" href="#put方法"></a> Put方法</h4><ol><li>根据put数据key算出hashcode</li><li>遍历table数组, 根据hashcode定位Node<ul><li><mark>Node为空, 表示当前位置可以写入数据, 利用CAS尝试写入</mark></li><li>若Node超出长度, 则对Node扩容</li><li><mark>Node不为空且无需扩容, 用synchronized写入</mark></li></ul></li></ol><h2 id="阻塞队列"><a class="markdownIt-Anchor" href="#阻塞队列"></a> 阻塞队列</h2><p>阻塞 + 队列</p><p>常用操作</p><ul><li><p>阻塞出</p><p>当队列为空, 则会获取元素的线程会一直等待, 直到队列不空</p></li><li><p>阻塞进</p><p>当队列已满, 放入元素的线程会一直等待, 直到队列不满</p></li></ul><p>多用于生产者(阻塞进) + 消费者(阻塞出)</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-image-20220214213430504.png?raw=true" alt="image-20220214213430504" style="zoom:50%;" /><h4 id="有界队列"><a class="markdownIt-Anchor" href="#有界队列"></a> 有界队列</h4><p>队列长度有限称为有界</p><p>反之, 若无界则是允许无限入队</p><h4 id="核心问题"><a class="markdownIt-Anchor" href="#核心问题"></a> 核心问题</h4><p>当队列为空时有新的元素进入队列, 消费者要怎么知道队列内有元素然后苏醒呢?</p><p>利用<code>通知模式</code></p><blockquote><p>通知模式: 当一个线程完成一件事后, 唤醒另一些线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取可中断锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素个数等于队列的最大长度，则调用 notFull.await() 进行等待</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 向队列中插入元素</span></span><br><span class="line">      <span class="comment">// enqueue函数中, 会调用notEmpty.signal()函数唤醒消费者</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 入队成功，释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 获取可中断锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列中没有元素，则调用 notEmpty.await() 进行等待</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="comment">// 从队列中取出元素</span></span><br><span class="line">      <span class="comment">// dequeue函数中, 会调用notFull.signal()函数唤醒生产者</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 出队成功，释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写时复制"><a class="markdownIt-Anchor" href="#写时复制"></a> 写时复制</h2><p>简单而言</p><ul><li>写操作<ol><li>加锁</li><li>复制一份拷贝</li><li>对拷贝进行修改</li><li>修改引用</li><li>解锁</li></ol></li><li>读操作<ol><li>不加锁, 直接读</li></ol></li></ul><h4 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h4><ul><li><p>优点</p><ul><li>并发度更高, 写操作不会影响到读操作</li></ul></li><li><p>缺点</p><ul><li><p>不能保证时刻都满足一致性</p><blockquote><p>比如线程A在进行写操作, 由于是对copy进行修改, 所以此时线程B读操作, 仍读的是之前的数据</p></blockquote></li><li><p>面对写操作较高的场景, 会占用大量内存.</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">100000</span>;</span><br><span class="line">    Thread threadWrite = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counter; i++) &#123;</span><br><span class="line">            arrayList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread threadRead = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counter; ++i) &#123;</span><br><span class="line">            System.out.println(arrayList.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    threadWrite.start();</span><br><span class="line">    threadRead.start();</span><br><span class="line">    threadWrite.join();</span><br><span class="line">    threadRead.join();</span><br><span class="line">  <span class="comment">// 可以发现,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h2><p>线程的创建和销毁是需要开销的, 若一个线程使用完毕, 应该先存着, 留着下次用. 而不是直接销毁.</p><p>预先将多个线程存在一个<code>池子</code>里, 称为<code>线程池</code></p><blockquote><p>记得 调用shutdown()才能使得程序终止</p></blockquote><h4 id="好处"><a class="markdownIt-Anchor" href="#好处"></a> 好处</h4><ul><li><p>减小系统开销</p></li><li><p>方便管理线程</p><p>因为线程都由线程池管理</p></li><li><p>提高响应速度</p><p>线程已经创建, 直接使用即可</p></li></ul><h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h3><ul><li><p>线程池</p><p>存储用于执行任务的线程</p></li><li><p>工作队列</p><p>存储将要执行的任务</p><blockquote><p>工作队列的存在是减少创建的线程.</p></blockquote><p>任务放到工作队列中,  线程池会从工作队列取出任务并执行.</p></li></ul><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-image-20220301165457963.png?raw=true" alt="image-20220301165457963" style="zoom:33%;" /><blockquote><p>工作提交器可视为是生产者, 而线程池可视为是消费者, 而任务则可视为食物</p></blockquote><p>当线程池和工作队列都满的情况下, 需要执行<code>饱和策略</code></p><p>有以下方案</p><ul><li>直接抛出异常</li><li>利用调用的线程执行该任务. (调用的线程就阻塞了)</li><li>丢弃队列中最近一个任务</li><li>摆烂, 直接无视提交的任务</li></ul><h3 id="java中的线程池"><a class="markdownIt-Anchor" href="#java中的线程池"></a> Java中的线程池</h3><p>java区分核心线程池与最大线程池.</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-image-20220301164348449.png?raw=true" alt="image-20220301164348449" style="zoom: 33%;" /><blockquote><p>核心线程池用于减少线程的创建.</p><p>可以理解为核心是常用, 而最大线程池是用于处理异常峰值.</p></blockquote><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-image-20220301190859193.png?raw=true" alt="image-20220301190859193" style="zoom:50%;" /><ul><li><p>Executor 接口</p><p>将任务提交和任务执行解耦</p><blockquote><p>Executors 包装多种线程池, 不推荐使用</p><p>Executor接口是用于是实现线程池, 而Thread是单个线程</p></blockquote></li><li><p>ExecutorService 接口</p><ul><li>扩种执行任务能力, 补充异步任务生成Future的方法</li><li>管控线程池</li></ul></li><li><p>ThreadPoolExecutor</p><p>实现</p>  <img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:59-image-20220301191106306.png?raw=true" alt="image-20220301191106306" style="zoom:50%;" /><h4 id="使用-2"><a class="markdownIt-Anchor" href="#使用-2"></a> 使用</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 固定线程池, 线程数为2</span></span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// void无返回</span></span><br><span class="line">        fixedThreadPool.execute(runnable);</span><br><span class="line">        fixedThreadPool.execute(runnable);</span><br><span class="line">        <span class="comment">// 返回一个Future类型, get方法获取返回值, 会阻塞调用get线程, 直到对应线程执行完毕</span></span><br><span class="line">        fixedThreadPool.submit(runnable);</span><br><span class="line">        fixedThreadPool.submit(runnable);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 缓存线程池, 根据任务自动调整线程池大小</span></span><br><span class="line">      ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">      <span class="comment">// 只包含一个线程的线程池, 保证任务先进先出的执行顺序</span></span><br><span class="line">      ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">      <span class="comment">// 抢占式执行线程池, 任务执行顺序不确定</span></span><br><span class="line">      Executors.newWorkStealingPool();</span><br><span class="line">      <span class="comment">// 执行延迟/定时任务的线程池</span></span><br><span class="line">      Executors.newScheduleThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述new Executors底层都是调用ThreadPoolExecutor, 只不过参数不一样.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQuque&lt;Runnable&gt; workQueue)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize 核心线程数</li><li>maximumPoolSize 最大线程数</li><li>keepAliveTime 最大线程可以存活时间</li><li>workQueue 工作队列</li></ul><p><mark>Executors虽然封装许多线程池, 但最好不要使用</mark></p><p>因为, 调用ThreadPoolExecutor的参数太离谱, 最大线程数默认是Integer.MAX_VALUE.</p><blockquote><p>线程数过多会花费大量时间在线程切换中, 且也会消耗大量资源</p></blockquote></li></ul><h4 id="threadpoolexecutor参数配置"><a class="markdownIt-Anchor" href="#threadpoolexecutor参数配置"></a> ThreadPoolExecutor参数配置</h4><p>一共有</p><ol><li><p>核心线程数</p></li><li><p>最大线程数</p></li><li><p>非核心线程存活时间</p></li><li><p>时间单位</p></li><li><p>阻塞队列</p></li><li><p>拒绝策略</p></li><li><p>线程工厂</p><blockquote><p>用于自定义创建线程逻辑</p></blockquote></li></ol><p>重点关注</p><ul><li>corePoolSize 核心线程数</li><li>maximumPoolSize 最大线程数</li><li>workQueue 工作队列</li></ul><h5 id="常用场景"><a class="markdownIt-Anchor" href="#常用场景"></a> 常用场景</h5><ul><li><p>CPU密集型任务</p><p>任务会长时间占用CPU, 而I/O, 读写, 网络传输的操作较少</p><ul><li><p>建议</p><p>充分利用CPU, corePoolSize = CPU数 + 1, 同时减少线程上下文切换</p></li></ul></li><li><p>IO密集型任务</p><p>I/O, 读写, 网络传输多, CPU大部分在等待I/O.</p><ul><li><p>建议</p><p>corePoolSize = CPU数 * 2.  减少CPU等待时间</p></li></ul></li></ul><p>workQueue设置大小最好与corePoolSize相近.</p><ul><li>workQueue过小, 会频繁调用拒绝策略</li><li>workQueue过大, 过多任务会堆积在一起</li></ul><h4 id="threadpoolexecutor使用样例"><a class="markdownIt-Anchor" href="#threadpoolexecutor使用样例"></a> ThreadPoolExecutor使用样例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryInitMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>, <span class="number">32</span>, <span class="number">100</span>, TimeUnit.NANOSECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;I am thread %s\n&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 记得调用shutdown, 不然程序无法停止</span></span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> ThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该句柄是线程独享的, 一般而言, 对象是放在堆中, 而堆是共享的, 但ThreadLocal下的对象是线程独享的, </span></span><br><span class="line"><span class="comment">// 每一个线程都会有一个新的对象</span></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processUser</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 设置对象</span></span><br><span class="line">        threadLocalUser.set(user);</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 结束使用, 将空间返还, 并清除状态. 下一次线程执行该任务时, 会获得一个全新的user</span></span><br><span class="line">        threadLocalUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全的单例模式"><a class="markdownIt-Anchor" href="#线程安全的单例模式"></a> 线程安全的单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySignleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 添加volatile保证可见性, 强制在共享内存中查看</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> MySignleton instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 禁止调用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MySignleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="comment">// 单例类传统</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySignleton <span class="title">getSignleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// double检查, 加一层检查是缩短时间, 若instance已经不为null, 则不用等待锁, 直接获取</span></span><br><span class="line">     <span class="comment">// 若没有这一层, 也是线程安全, 但速度慢. </span></span><br><span class="line">     <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(MySingleton.class) &#123;</span><br><span class="line">            <span class="comment">// 如果只有外面一层检查, 那么可能会有多个线程进到该区域, 同时new出多个MySignleton</span></span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">              instance = <span class="keyword">new</span> MySignleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li>《Java 并发编程实践》</li><li><a href="https://leetcode-cn.com/leetbook/detail/concurrency/">大话并发</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java线程与操作系统的线程区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java线程与操作系统的线程区别&quot;&gt;&lt;/a&gt; Java线程与操作系统的线程区别&lt;/h2&gt;
&lt;p&gt;内存通常分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户空间&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="Java" scheme="https://chenyuanzhen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>求解线性同余方程</title>
    <link href="https://chenyuanzhen.github.io/2021/09/14/uploadMd/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/"/>
    <id>https://chenyuanzhen.github.io/2021/09/14/uploadMd/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</id>
    <published>2021-09-14T08:32:22.000Z</published>
    <updated>2022-04-14T03:20:39.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求解ax-equiv-cmod-quad-b"><a class="markdownIt-Anchor" href="#求解ax-equiv-cmod-quad-b"></a> 求解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mi>c</mi><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"></mspace><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax \equiv c(mod \quad b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></h2><p>求解该方程<mark>等同于</mark>求解一个二元一次方程</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by = c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>.</p><p>该方程有解的条件是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">gcd(a, b) | c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord mathdefault">c</span></span></span></span> ,   即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">除</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">gcd(a,b)可以整除c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">除</span><span class="mord mathdefault">c</span></span></span></span></p><p>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>互质 即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">gcd(a, b)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>. 那么该方程一定有解, 而且该方程的任意解都可以表示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub><mo>+</mo><mi>b</mi><mi>t</mi><mo separator="true">,</mo><mi>y</mi><mo>=</mo><msub><mi>y</mi><mn>0</mn></msub><mo>−</mo><mi>a</mi><mi>t</mi><mo separator="true">,</mo><mi>t</mi><mo>∈</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">x=x_0 + bt, y=y_0-at, t \in Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mi mathvariant="normal">和</mi><msub><mi>y</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0和y_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为一个特解,即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">ax+by=c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>的一组解​.</p><p>怎么求一个特解呢? 需要用到扩展欧几里得算法.</p><h2 id="扩展欧几里得算法"><a class="markdownIt-Anchor" href="#扩展欧几里得算法"></a> 扩展欧几里得算法</h2><p>先看欧几里得算法, 该算法用于求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 代码很简洁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x一定要大于y 而且 y 不能为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">  <span class="keyword">if</span>(x % y == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> y;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>扩展欧几里得算法是用于求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">gcd(x, y)=ax+by</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 中的a和b. 即用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>表示出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>的最小公倍数. 本质是欧几里得算法的逆过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 要大于 y 且 y不能等于0 使用引用将a, b作为函数结果返回回来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>{</span><br><span class="line">  <span class="comment">// 得到答案gcd(x, y)后, 再递归一步初始化好a和b</span></span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>){</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">      b = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// d是gcd(a, b)</span></span><br><span class="line">  <span class="keyword">int</span> d = <span class="built_in">ex_gcd</span>(y, x % y, a, b);</span><br><span class="line">  <span class="keyword">int</span> tmp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = tmp - x / y * b;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="解释"><a class="markdownIt-Anchor" href="#解释"></a> 解释</h3><p>我们有欧几里得算法可知<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">%</mi><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a, b) =gcd(b, a\%b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>的</p><p>也就是说</p><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="31.124ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 13757 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(477, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(910, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1430, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1819, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(2391, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2835.7, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3325.7, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(3992.4, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(5048.2, 0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(529, -150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mi" transform="translate(5980.8, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(6775, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msub" transform="translate(7775.2, 0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mn" transform="translate(429, -150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mi" transform="translate(8607.8, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(9375.6, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(10431.3, 0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(10908.3, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(11341.3, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(11861.3, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(12250.3, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(12740.3, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(13185, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></p><blockquote><p>此处的除法为计算机中的整数除法</p></blockquote><p>整理一下上述式子</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>0</mn></msub><mi>y</mi><mo>=</mo><msub><mi>b</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>−</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">a_0x+b_0y=b_1x+(a_1 - b_1(x/y))y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub><mi>y</mi><mo>=</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">a_{i}x+b_{i}y=b_{i+1}x+(a_{i+1} - b_{i+1}(x/y))y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p><p>可以看到</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mspace linebreak="newline"></mspace><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">/</mi><mi>y</mi><mo stretchy="false">)</mo><msub><mi>b</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_i = b_{i+1}\\b_{i} = a_{i+1} - (x/y)b_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p><p>正好对应代码里的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmp = a(i+1)</span></span><br><span class="line"><span class="keyword">int</span> tmp = a;</span><br><span class="line"><span class="comment">// ai = b(i+1)  此时的b即是b0</span></span><br><span class="line">a = b;</span><br><span class="line"><span class="comment">// bi = a(i+1) - x / y * b(i+1)</span></span><br><span class="line">b = tmp - x / y * b;</span><br><span class="line"><span class="comment">// 到此ai和bi已经更新完毕, 递归回去后求出ai-1之前的和bi-1直到求出a0与b0</span></span><br></pre></td></tr></table></figure><p>也就是说我们可以利用这个式子, 进行递归用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1, b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>反推<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">a_0, b_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>到此, 可以得到</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">gcd(x, y) = ax + by</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 以及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">gcd(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></p><p>那么只要再次加工一番</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>=</mo><mfrac><mrow><mi>a</mi><mi>x</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>b</mi><mi>y</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">1 = \frac{ax}{gcd(x,y)} + \frac{by}{gcd(x,y)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.215392em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.452216em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>两边同时乘一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mfrac><mrow><mi>c</mi><mi>a</mi><mi>x</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mi>c</mi><mi>b</mi><mi>y</mi></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">c = \frac{cax}{gcd(x,y)} + \frac{cby}{gcd(x,y)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.215392em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.452216em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>有了上述的步骤, 我们令上述式子中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x=a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> . 利用扩展欧几里得算法求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mi>a</mi><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><mi>b</mi></mrow><annotation encoding="application/x-tex">gcd(a,b)=a_1a + b_1b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">b</span></span></span></span> . 此时的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>即为原式子ax+by=c中对应x和y的特解.</p><p>我们的最终目的就是求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的可能取值. 即</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mi>c</mi><msub><mi>a</mi><mn>1</mn></msub></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mi>b</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">x=\frac{ca_1}{gcd(a,b)} + bt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2314919999999998em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7114919999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span></span></span></span></p><p>很多时候我们求得是x的最小整数解,</p><ul><li><p>假设求到的特解是负数的, 那么只需加上一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 即当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时.得到的解, 一定会为正的.</p></li><li><p>如果求到的特解是整数, 那么该特解就最小正整数解.</p></li><li><p>以上条件, <mark>仅限于</mark>是使用扩展欧几里德得到的特解.</p></li></ul><p>当然最好还是使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设特解为 x0, ax%c =1  </span></span><br><span class="line"><span class="keyword">int</span> minPostive = (x0 % t + t) % t;</span><br></pre></td></tr></table></figure><p>解释一下上述式子</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mi>c</mi><msub><mi>a</mi><mn>1</mn></msub></mrow><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mi>b</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">x=\frac{ca_1}{gcd(a,b)} + bt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2314919999999998em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7114919999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span></span></span></span></p><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mfrac><mi>b</mi><mrow><mi>g</mi><mi>c</mi><mi>d</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">t = \frac{b}{gcd(a,b)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">a</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">b</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p></blockquote><p>如果得到的特解 &gt;0. 要求最小正的特解, 让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">bt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span></span></span></span>来表达目前特解的一部分, 对应<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mi mathvariant="normal">%</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">x_0\%t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">%</span><span class="mord mathdefault">t</span></span></span></span>. 此时, 已经是正确的了.</p><p>如果得到的特解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">&lt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>, 也让<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">bt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span></span></span></span>来表达目前特解的一部分, 对应<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mi mathvariant="normal">%</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">x_0\%t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">%</span><span class="mord mathdefault">t</span></span></span></span>. 但此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>仍为负数. 加一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 让其变正. 对应 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mi mathvariant="normal">%</mi><mi>t</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0 \% t + t )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">%</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>.</p><p>最后加一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">%</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\%t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">%</span><span class="mord mathdefault">t</span></span></span></span>, 仅仅是让其不用判断正负分别执行罢了</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>x</mi><mo>≡</mo><mn>1</mn><mo stretchy="false">(</mo><mi>m</mi><mi>o</mi><mi>d</mi><mspace width="1em"></mspace><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ax\equiv1(mod \quad c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span></p><p>练习</p><p><a href="https://www.luogu.com.cn/problem/P1082">P1082 [NOIP2012 提高组] 同余方程</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="comment">// x一定要大于y</span></span><br><span class="line"><span class="comment">// x 要大于 y 且 y不能等于0 使用引用将a, b作为函数结果返回回来</span></span><br><span class="line"><span class="function">ll <span class="title">ex_gcd</span><span class="params">(ll x, ll y, ll &amp;a, ll &amp;b)</span></span>{</span><br><span class="line">    <span class="comment">// 得到答案gcd(x, y)后, 再递归一步并初始化好a和b</span></span><br><span class="line">    <span class="keyword">if</span>(y == <span class="number">0</span>){</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// d为gcd(a, b)</span></span><br><span class="line">    ll d = <span class="built_in">ex_gcd</span>(y, x % y, a, b);</span><br><span class="line">    ll tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp - x / y * b;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    ll a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    ll a1, b1, gcd;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b){</span><br><span class="line">        gcd = <span class="built_in">ex_gcd</span>(b, a, b1, a1);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        gcd = <span class="built_in">ex_gcd</span>(a, b, a1, b1);</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 题目求x的最小整数解, 如果对应的x0是&lt;0, 那么只能加一个b</span></span><br><span class="line">    <span class="keyword">if</span>(a1 &lt; <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; b + a1 / gcd;</span><br><span class="line">  <span class="comment">// 如果x0&gt;0, 那么就不用+b了</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; a1;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;求解ax-equiv-cmod-quad-b&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#求解ax-equiv-cmod-quad-b&quot;&gt;&lt;/a&gt; 求解&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-ma</summary>
      
    
    
    
    
    <category term="算法" scheme="https://chenyuanzhen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快慢指针</title>
    <link href="https://chenyuanzhen.github.io/2021/08/28/uploadMd/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    <id>https://chenyuanzhen.github.io/2021/08/28/uploadMd/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</id>
    <published>2021-08-28T08:41:14.000Z</published>
    <updated>2022-04-13T02:11:43.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环形链表-ii"><a class="markdownIt-Anchor" href="#环形链表-ii"></a> <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">环形链表 II</a></h3><h3 id="快慢指针法"><a class="markdownIt-Anchor" href="#快慢指针法"></a> 快慢指针法</h3><p>作用: 判断链表中是否有环</p><p>或者说用于特殊图中</p><h3 id="推论"><a class="markdownIt-Anchor" href="#推论"></a> 推论</h3><p>假设一个链表中一定有环</p><ul><li>a: head到环起点的距离</li><li>b+a 为slow指针所走的距离 (直到fast与slow相遇)</li><li>设fast已经在圈内走n圈, 所得距离为 a + n( b+ c) + b</li></ul><p>由因为fast的移动速度是slow的两倍, 所以</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi><mo>=</mo><mn>2</mn><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>a</mi><mo>=</mo><mi>c</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a+n(b+c)+b = 2(a+b)\\a=c+(n-1)(b+c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span></span></p><p>距离a = (n - 1)圈长度 + c.</p><p>也就意味着若设一个指针ptr从head出发, 同时slow也往后走, 当两者碰面时, 为圈起点.</p><blockquote><p>slow会在圈内走 n - 1圈回到 fast与slow相遇点, 后再走 c步, 在圈起点与ptr相遇</p></blockquote><h4 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 注意fast是跑两步检测, 不是跑一步检测一次, 不然就不符合上述的推理</span></span><br><span class="line">          <span class="comment">// 若为一步一检, fast的距离可能不是slow的两倍. 不满足前提</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                <span class="keyword">while</span>(ptr != slow)&#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;环形链表-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#环形链表-ii&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii/&quot;&gt;环形链表 II&lt;</summary>
      
    
    
    
    
    <category term="算法" scheme="https://chenyuanzhen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三数之和</title>
    <link href="https://chenyuanzhen.github.io/2021/08/06/uploadMd/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://chenyuanzhen.github.io/2021/08/06/uploadMd/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2021-08-06T03:30:00.000Z</published>
    <updated>2022-04-13T02:11:43.432Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源</p><p><a href="https://leetcode-cn.com/problems/3sum/">leetcode</a></p><h3 id="题目简述"><a class="markdownIt-Anchor" href="#题目简述"></a> 题目简述</h3><p>给定一个数组, 找出三元组, 使得三元组三个元素a, b c, 满足 a + b + c = 0.</p><h4 id="要求"><a class="markdownIt-Anchor" href="#要求"></a> 要求</h4><p>三元组不得重复 (顺序调换也算重复 )</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>首先, 若没有重复的限制, 最简单的想法某过于直接三重循环. 时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​. 枚举a, b, c. 然后校验是否为0即可. 但最后一个c当a, b已经确定的情况下, c取什么值也已经确定.  只需检查数组中是否有即可.</p><p>接着需要解决重复问题. <mark>当我们按照某种规律去选择时, 自然而然也就解决重复</mark>. 这里我们规定 三元组需满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leq b \leq c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>​​​. 如此一来, 解决 如[1, 0, 2]与[2, 0, 1]的重复问题.</p><blockquote><p>根据上面的操作, 我们是需要先对数组进行排序的.</p></blockquote><p>但 万一存在 a = b 或者 b = c 或者 a =b = c等情况, 如数组 [-2, -2, 0, 2, 2]. 中三元组 [-2, 0, 2]有很多种选择 (下标不同). 为避免这样的重复, <mark>我们只需保证枚举a 与 b时, 不要枚举重复的元素.</mark> 由于数组排序后, 重复的元素也会连在一起.</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 效率不高, 但较为清晰</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">// 对数组排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 枚举a</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">          <span class="comment">// 避免重复枚举. </span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>] == nums[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 这里是很关键, 是枚举c的范围 (j, k]</span></span><br><span class="line">            <span class="comment">// 当a确定后, c = - a - b 那么b越往后枚举会越大, </span></span><br><span class="line">            <span class="comment">// 对应的 c只会越小, 所以不是在枚举完b后才确定枚举c的范围, 而是在确定a后确定</span></span><br><span class="line">            <span class="keyword">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 枚举b</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">               <span class="comment">// 避免处重复枚举, </span></span><br><span class="line">              <span class="comment">//不要尝试用记录上一个[j]值来避免, 当j执行完后, 上一个[j]值 = nums[nums.size() - 1]. 当下一轮再枚举j时, 本应该是比较 nums[j-1]的, 却是跟比较nums[nums.size() - 1]比较</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 确定c值, 只要在(j, k]的范围内查找c值即可</span></span><br><span class="line">                <span class="keyword">int</span> c = -nums[i] - nums[j];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(; k &gt; j ; k--)&#123;</span><br><span class="line">                  <span class="comment">// nums[k]表示查找范围的最大值, 若还小于 c. 那已经不可能满足条件</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[k] &lt; c)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(nums[k] == c)&#123;</span><br><span class="line">                        vector&lt;<span class="keyword">int</span>&gt; tmp = &#123;nums[i], nums[j], nums[k]&#125;;</span><br><span class="line">                        result.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目来源&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot;&gt;leetcode&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题目简述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#题目简述&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="算法" scheme="https://chenyuanzhen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>鸟哥Linux私房菜第四版 笔记</title>
    <link href="https://chenyuanzhen.github.io/2021/07/24/uploadMd/%E9%B8%9F%E5%93%A5Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0/"/>
    <id>https://chenyuanzhen.github.io/2021/07/24/uploadMd/%E9%B8%9F%E5%93%A5Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-23T16:00:00.000Z</published>
    <updated>2022-04-13T02:08:44.152Z</updated>
    
    <content type="html"><![CDATA[<p><mark>Linux下无论什么都是一个文件</mark></p><h2 id="linux安装前提需知"><a class="markdownIt-Anchor" href="#linux安装前提需知"></a> Linux安装前提需知</h2><h3 id="硬件设备在linux中的文件名"><a class="markdownIt-Anchor" href="#硬件设备在linux中的文件名"></a> 硬件设备在linux中的文件名</h3><p>几乎所有的硬件设备文件都位于 /dev 目录下</p><blockquote><p>如SATA接口的硬盘的文件名为 /dev/sd[a-d]</p><p>但若是虚拟机则会使用 /dev/vd[a-p]</p></blockquote><h3 id="磁盘分区"><a class="markdownIt-Anchor" href="#磁盘分区"></a> 磁盘分区</h3><p>磁盘接口有两种SATA与SAS接口.  分区时, 单位是柱面</p><p>操作系统中的磁盘, 因容量过大, 需要分区管理. 而分区有两种格式</p><ul><li><p>MSDOS分区表格式<br><mark>开机管理程序记录区</mark>与<mark>分区表</mark>均放在磁盘第一扇区.</p><ul><li><p>主要开机记录区 安装开机管理程序的地方  446bytes</p></li><li><p>分区表 记录整颗磁盘分区的状态, 有64bytes</p><ul><li><p>能写入4组分区信息( 主要分区或延伸分区)</p></li><li><p>分区可在设备文件名中体现</p><blockquote><p>/dev/sda3 与 /dev/sda4 通常用于主要分区和延伸分区记录存储 不可见<br>而1~4都会给与主分区+延伸分区. (加起来最多4个)</p></blockquote><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724152807685.png?raw=true" alt="image-20210724152807685"></p></li><li><p>最小单位通常为柱面.</p><blockquote><p>通过延伸分区所指向的磁盘空间, 记录其余分区情况, 使得磁盘可以分为多个区</p></blockquote></li></ul></li></ul><p>若第一个扇区崩了, 整个磁盘都救不得</p></li><li><p>GUID GPT磁盘分区表</p><p>过去一个扇区大小为512Bytes, 而如今有更大的bytes扇区出现. 为统一, 将扇区用==逻辑区块位址(LBA)==进行管理. GPT便是以LBA(默认512Bytes)进行规划. LBA0, LBA1…</p><p>用34个LBA区块记录分区信息<br><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724153254882.png?raw=true" alt="image-20210724153254882" style="zoom:50%;"></p><ul><li>LBA0 相容区块, 存储第一阶段的开机管理程序. 并告知硬件管理程序, 是GPT格式</li><li>LBA1 GPT表头记录<ul><li>备份用的GPT分区放置的位置. 前34个空余LBA可用于备份</li><li>分区表的检验机制码CRC32. 判断该GPT是否正确</li></ul></li><li>LBA2-33 实际记录分区信息<ul><li>每个LBA可记录4个分区记录</li></ul></li></ul></li></ul><h3 id="开机流程中的bios与uefi开机检测程序"><a class="markdownIt-Anchor" href="#开机流程中的bios与uefi开机检测程序"></a> 开机流程中的BIOS与UEFI开机检测程序</h3><h4 id="bios-mbrgpt开机流程"><a class="markdownIt-Anchor" href="#bios-mbrgpt开机流程"></a> BIOS + MBR/GPT开机流程</h4><p>BIOS 一个写入到主板上的软件程序. (计算机系统主动执行的第一个程序)</p><p>该程序会读取MBR ( MSDOS分区第一个分区 )的信息, 执行最基本的开机管理程序.</p><p>流程:</p><ol><li><p>执行BIOS</p></li><li><p>读取MBR, 获取开机管理程序</p><blockquote><p>若为GPT格式从LBA0读取<br>MBR的任务</p><ul><li>提供菜单</li><li>载入核心文件</li><li>将开机管理功能转交给其他分区的开机扇区负责.<br>实现不同分区装载不同的系统, 而可以通过选择不同的开机扇区, 启动不同的系统</li></ul></blockquote></li><li><p>开机管理程序, 读取并执行核心文件</p></li><li><p>核心文件执行开始操作系统的功能</p></li></ol><h4 id="uefi-bios搭配gpt开机的流程"><a class="markdownIt-Anchor" href="#uefi-bios搭配gpt开机的流程"></a> UEFI BIOS搭配GPT开机的流程</h4><p>部分BIOS由于是16位程序, 而GPT是支持64bit寻址的. 为解决该问题, UEFI诞生了.</p><blockquote><p>UEFI BIOS 可以说是BIOS的升级版</p></blockquote><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724160820764.png?raw=true" alt="image-20210724160820764"></p><h3 id="linux安装中的磁盘分区选择"><a class="markdownIt-Anchor" href="#linux安装中的磁盘分区选择"></a> Linux安装中的磁盘分区选择</h3><p>windows将磁盘分区以C盘, D盘管理文件. 而Linux是以目录树管理文件.</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724161110732.png?raw=true" alt="image-20210724161110732" style="zoom:50%;"><p>所有的文件都是有根目录 / 衍生出来</p><h4 id="挂载-解决将磁盘内的数据转化为目录树的架构"><a class="markdownIt-Anchor" href="#挂载-解决将磁盘内的数据转化为目录树的架构"></a> 挂载 解决将磁盘内的数据转化为目录树的架构</h4><p>进入到一个特定目录可以读取某个特定分区的信息. 这个动作叫挂载</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724161334879.png?raw=true" alt="image-20210724161334879" style="zoom:50%;"><blockquote><p>/home以下的目录数据都放置到分区2, 而非/home目录下的, 全放置到分区1</p></blockquote><p>安装linux时, 需考虑磁盘分区与目录树的挂载</p><h2 id="linux安装规划"><a class="markdownIt-Anchor" href="#linux安装规划"></a> Linux安装规划</h2><p>Linux有许多的发行版, 而核心都是一致的, 各有一些小差异.</p><h3 id="软件-软件选择"><a class="markdownIt-Anchor" href="#软件-软件选择"></a> 软件 软件选择</h3><ul><li>最小安装<br>没有图形gui, 需要自己一步步搭建, 仅安装最简单的功能</li><li>含GUI的服务器</li><li>GNOME桌面环境 Linux常见的图形接口</li></ul><h3 id="系统-安装位置"><a class="markdownIt-Anchor" href="#系统-安装位置"></a> 系统 安装位置</h3><p>设备类型 管理分区方法</p><ul><li>标准分区  普通的分区, 与上面的相同</li><li>LVM          可弹性增加或削减文件系统容量的设备管理</li><li>LVM进阶版</li></ul><p>文件系统</p><ul><li>ext2/ext3/ext4 Linux早期适用的文件系统类型.</li><li>swap 磁盘仿真为内存, 不使用目录树的挂载, 无需指定挂载点</li><li>BIOS Boot GPT分区使用</li><li>xfs 默认CentOS文件系统, 用于大容量磁盘管理</li><li>vfat 同时被Linux与Windows支持</li></ul><h4 id="系统-kdump"><a class="markdownIt-Anchor" href="#系统-kdump"></a> 系统 KDUMP</h4><p>默认开启, 当核心机制崩溃时, 会记录当前系统信息</p><h4 id="系统-网络配置"><a class="markdownIt-Anchor" href="#系统-网络配置"></a> 系统 网络配置</h4><p>读取网卡配置,</p><h4 id="创建用户"><a class="markdownIt-Anchor" href="#创建用户"></a> 创建用户</h4><p>默认会创建一个root用户, 有最高权限.</p><p>而也可创建一个新用户, 若勾选将此用户作为管理员, 说明该用户可转变拥有最高权限</p><h2 id="linux系统常用"><a class="markdownIt-Anchor" href="#linux系统常用"></a> Linux系统常用</h2><p>终端编码查看</p><p>locale命令</p><blockquote><p>若是在linux的默认终端中,  哪怕编码正确, 也无法显示, 需要加入中文化接口软件</p></blockquote><ul><li>终端模式与GUI模式切换<ul><li>GUI ctrl + alt + f1</li><li>终端 ctrl + alt + f2~f6 一共有5个默认终端</li></ul></li></ul><p>每一个GUI都是配备一个终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启GUI, 确保该终端没有开其他GUI Xwindow</span></span><br><span class="line">startx</span><br></pre></td></tr></table></figure><h3 id="bash命令"><a class="markdownIt-Anchor" href="#bash命令"></a> bash命令</h3><h4 id="需知"><a class="markdownIt-Anchor" href="#需知"></a> 需知</h4><ul><li>Linux英文大小字母区分</li><li>换行用 \</li><li>多余空格都视为一格. 用于区分命令参数</li></ul><h3 id="基础命令"><a class="markdownIt-Anchor" href="#基础命令"></a> 基础命令</h3><ul><li><p>显示日期和时间 date</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 格式化输出 2015/05/29</span></span><br><span class="line">date +%Y/%m/%d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 时间</span></span><br><span class="line">date +%H:%M</span><br></pre></td></tr></table></figure></li><li><p>日历 cal</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cal </span><br><span class="line">cal [年份]</span><br></pre></td></tr></table></figure></li><li><p>计算器 bc</p><p>quit退出</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scale=小数位数</span><br></pre></td></tr></table></figure></li><li><p>man 命令<br>操作说明</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [命令名称]</span><br></pre></td></tr></table></figure><p>man后第一行会出现命令名称 + ([数字])</p><p>若数字为</p><ul><li><p>1 shell中可操作的指令或可执行  <mark>记住</mark></p></li><li><p>2 系统核心调用的函数与工具</p></li><li><p>3 常用函数或函数库</p></li><li><p>4 设备文件说明</p></li><li><p>5 配置文件或某些文件格式 <mark>记住</mark></p></li><li><p>6 游戏</p></li><li><p>7 协定与惯例</p></li><li><p>8 系统管理员可用的管理指令 <mark>记住</mark></p><p>查询 /string 向下查询  ?string向上查询<br>n为向下查询,  N为往上查询</p></li></ul><p>其余说明的文件<br>/usr/share/doc/软件名  该路径存储说明文件<br>或者 命令名称 --help也可查询命令</p></li><li><p>info命令<br>与man相同</p></li></ul><h4 id="nano-文本编辑器"><a class="markdownIt-Anchor" href="#nano-文本编辑器"></a> nano 文本编辑器</h4><p>比较简单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano </span><br></pre></td></tr></table></figure><h3 id="常用热键"><a class="markdownIt-Anchor" href="#常用热键"></a> 常用热键</h3><ul><li><p>tab 自动补全</p><ul><li><p>接在一串指令的第一个字后, 命令补全</p></li><li><p>一串指令的第二个字以后, 为文件补全</p></li><li><p>连续按两次, 列出以当前输入字母为开头的所有命令</p></li><li><p>命令 --按tab两次, 列出所有全名参数    -按tab一次, 列出简写</p></li></ul></li><li><p>ctrl + c<br>停止程序</p></li><li><p>ctrl + d<br>表示键盘输入结束. 可视为输入exit</p></li><li><p>shift + 上下键 为翻页</p></li></ul><h4 id="关机方法"><a class="markdownIt-Anchor" href="#关机方法"></a> 关机方法</h4><p>需要关注有无网络用户在与主机发生交互  who 指令, netstat -a指令 看连线状态</p><p>shutdown( 关机 ) 与 reboot( 重启 ) 两个指令.  需要root才有权限执行, 若有GUI, 也可由普通用户执行</p><p>sync 数据同步写入磁盘</p><h3 id="linux的文件权限与目录配置"><a class="markdownIt-Anchor" href="#linux的文件权限与目录配置"></a> Linux的文件权限与目录配置</h3><p>任何一个文件都具有 User, Group, Others三种身份权限. root可随意访问任何文件</p><p>切换为root身份 su -  可使用exit返回原身份</p><h4 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h4><p>drwxr-xr-x+ 87 chenyuanzhen staff  2784 7 25 21:48 .</p><ul><li><p>d rwx rwx —</p><p>最前面的d表示为文件夹 目录  -为文件, l为连接文件, b为可存储设备, c为外设</p><ul><li>前三组 rwx 表示文件拥有者的权限<ul><li>r 读</li><li>w 写</li><li>x 执行(进入目录也算执行动作) linux有x标记, 才可执行</li></ul></li><li>中间三组 表示与文件拥有者同一个group下</li><li>后三组 为others身份的权限</li></ul><p>无权限为 -</p></li><li><p>87 表示多少个文件名链接到此节点</p></li><li><p>chenyuanzhen 表示为文件拥有者</p></li><li><p>staff 为拥有者所属群组</p></li><li><p>2784 容量大小 默认单位为bytes</p></li><li><p>7 25 21:48 为最近修改日期</p></li></ul><p>root拥有所有文件的 rwx权限. 不受系统限制</p><h3 id="改变文件属性"><a class="markdownIt-Anchor" href="#改变文件属性"></a> 改变文件属性</h3><ul><li><p>chgrp 改变文件所属群组</p><p>要被改变的群组名称必须要在 /etc/group文件内存在才可</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp groupName filepath</span><br></pre></td></tr></table></figure></li><li><p>chown 改变文件拥有者</p><p>必须有该用户才可变成为该用户, /etc/passwd 中文件有记录才能改变</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown userName filepath</span><br></pre></td></tr></table></figure><p>修改所属小组 用 : 区分 或 . 区分</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown userName:groupName filepat h</span><br><span class="line">chown .小组名 filepath </span><br></pre></td></tr></table></figure></li><li><p>chmod 改变文件的权限</p><p><mark>只有文件所有者和超级用户可以修改文件或目录的权限</mark></p><p>rwx rwx rwx 分为三组,<br>r: 4分   w: 2分  x: 1分. 单独计算分数</p><blockquote><p>如若要开启所有权限, 则对应分数为 777</p><p>而只想拥有者拥有所有权限为 700</p></blockquote>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 filepath</span><br><span class="line">chmod 700 filepath</span><br></pre></td></tr></table></figure><p>或者</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> u表示拥有者, 后跟着的为权限编号, go表示为所属群</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a表示所有人 chomd a+x filepath 令所有人都可执行</span></span><br><span class="line">chmod u=rwx,go=rx,o=r filepath</span><br><span class="line"><span class="meta">#</span><span class="bash"> = 号可替换为 + 附加, -为除去</span></span><br><span class="line">chmod u+rwx,go-rx,o-r filepath</span><br></pre></td></tr></table></figure><p>拥有rwx都不代表一定能删除该文件,  仅能修改其中的内容.<br>rwx对于目录而言</p><ul><li>r  读取该目录下的文件名数据</li><li>w 可在新的目录下创建文件与目录, 可删除已经存在的文件与目录( 无视该文件权限), 改名, 移动文件与目录位置</li><li>x 可进入该目录同时可作为工作目录 最好能同时给与rx. 没有r也能取数据, 但无法补全名字</li></ul></li></ul><h3 id="linux文件种类与扩展名"><a class="markdownIt-Anchor" href="#linux文件种类与扩展名"></a> Linux文件种类与扩展名</h3><p>文件种类</p><ul><li>正规文件</li><li>纯文本文件</li><li>二进制档 binary</li><li>数据格式文件  data</li><li>目录</li><li>链接文件 link   快捷方程式</li><li>设备与设备文件   与系统周边与储存等相关的文件, 位于/dev目录下<ul><li>区块设备文件 block  支持随机存储 如硬盘与软盘</li><li>字符设备文件  character  一次性读取, 不支持随机读取  如鼠标与键盘</li></ul></li><li>数据耳机口文件 sockets</li><li>数据输送档 FIFO    解决多个进程同时读写一个文件</li></ul><p>linux的后缀名仅用于让使用这了解文件的可能用途. x权限决定一个文件是否能被执行</p><h3 id="linux目录配置"><a class="markdownIt-Anchor" href="#linux目录配置"></a> Linux目录配置</h3><p>FHS Filesystem Hierarchy Standard. 规定每个特定的目录下应该要放置什么数据.</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210726150703393.png?raw=true" alt="image-20210726150703393"></p><p>不变的: 表示放置的文件不会经常变动, 函数库, 文件说明文档等</p><ul><li><p>/ (root, 根目录) 与开机系统有关</p><blockquote><p>根目录应该越小越好, 由于记录特定开机文件, 核心文件, 开机所需程序等</p></blockquote><ul><li>/bin      放置可执行文件的目录</li><li>/boot  开机会使用的文件</li><li>/dev   任何与外设有关的设备都以文件的形态放置到该文件夹中</li><li>/etc 系统主要的配置文件  如人员的账号密码档</li><li>/lib  仅放置开机会用到的函数库以及/bin或/sbin下指令会调用到的函数库</li><li>/media  可移除设备</li><li>/mnt 挂载某些额外的设备</li><li>/opt 第三方协力软件</li><li>/run 开机后产生的各项信息</li><li>/sbin 开机中所需的指令,<ul><li>/usr/sibn 放置服务器软件程序</li><li>/usr/local/sbin 放置安装软件所产生的系统可执行文件</li></ul></li><li>/srv 网络服务文件</li><li>/tmp 暂时存储</li><li>/usr  Unix Software Resource. 操作系统软件资源  软件开发者将系统数据放置到该文件夹下. 所有系统默认软件到放置在/usr下面<ul><li>/usr/bin/ 用户能使用的指令</li><li>/usr/lib/   与上/lib相同, 仅仅是链接</li><li>/usr/local  系统管理员在本机自行安装下载的软件</li><li>/usr/sbin  非系统正常运行所需的系统指令  也可链接</li><li>/usr/share 文字文件</li></ul></li><li>/var  放置经常变动的文件<ul><li>/var/run 放置服务的PID 与/run相同, 链接</li></ul></li></ul><p>以上不同的发行版会有小改变</p></li></ul><h3 id="目录树"><a class="markdownIt-Anchor" href="#目录树"></a> 目录树</h3><p>绝对路径   /</p><p>相对路径  ./ 当前目录(等同于 . )   …上级目录</p><h2 id="linux文件与目录管理"><a class="markdownIt-Anchor" href="#linux文件与目录管理"></a> Linux文件与目录管理</h2><p>特殊目录: 可直接cd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.  当前目录</span><br><span class="line">.. 上级目录</span><br><span class="line">~  目前使用者的主文件夹</span><br><span class="line">~account  account账户的主文件夹</span><br></pre></td></tr></table></figure><p>目录指令</p><ul><li><p>cd 变换当前目录</p></li><li><p>pwd 显示目前的目录</p></li><li><p>mkdir 创建一个新的目录</p></li><li><p>rmdir 删除一个<mark>空的</mark>目录</p><blockquote><p>可使用 rmdir -r 目录名 删除目录下所有文件</p></blockquote></li></ul><h4 id="可执行文件路径的变量-path"><a class="markdownIt-Anchor" href="#可执行文件路径的变量-path"></a> 可执行文件路径的变量 $PATH</h4><p>环境变量 PATH   echo $PATH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由:区分</span></span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure><p>系统会根据PATH的设置, 在<mark>每个PATH定义的目录下搜寻指令名称的可执行文件</mark></p><h3 id="文件与目录管理"><a class="markdownIt-Anchor" href="#文件与目录管理"></a> 文件与目录管理</h3><ul><li><p>文件与目录的检视 ls</p></li><li><p>复制 cp</p><blockquote><p>默认cp文件, 会将文件的拥有者和所属群组修改为执行cp的使用者</p><p>cp -p  可将文件的属性一起复制过去,<br>但没有rw权限与chmod执行权限的用户, 仍不可执行cp -p 操作</p><p>cp -a 等同于 -p -r  将目录下的所有文件保留文件属性.</p></blockquote></li><li><p>删除 rm</p><ul><li><p>rm -r 递归删除</p></li><li><p>rm -i 询问删除, 每删除都会显示文件名</p></li><li><p>若文件名有特殊字符, 可将其写为 ./ + 文件名</p></li></ul></li><li><p>移动( 更名 ) mv</p><p>若移动多个文件或目录, 则最后一个目标文件一定是目录</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv [options] source1, source2, source3 ... directory</span><br><span class="line">mv [options] source destination</span><br></pre></td></tr></table></figure><ul><li>-f 强制, 若文件已经存在, 会直接覆盖</li><li>-i 若文件已经存在, 则会询问是否覆盖</li><li>-u 若文件名已经存在, 较新的才会覆盖</li></ul></li><li><p>取得路径的文件名与目录名</p><ul><li>basename filePath   获取文件名 (去掉路径)</li><li>direname  dirPath 获取目录名 (去掉路径)</li></ul></li></ul><h3 id="文件内容查阅"><a class="markdownIt-Anchor" href="#文件内容查阅"></a> 文件内容查阅</h3><ul><li>cat 由第一行开始显示文件内容  -v 列出一些看不出的特殊字符</li><li>tac 从最后一行开始显示</li><li>nl 显示时 顺道输出行号</li><li>more 一页一页的显示文件内容</li><li>od 以二进制方式读取文件内容<br>将二进制文件都以不同进制读取</li></ul><h4 id="读取部分内容"><a class="markdownIt-Anchor" href="#读取部分内容"></a> 读取部分内容</h4><ul><li>head 从头部取<br>head filepath 默认10行, 可加head -n 数字 filepath</li><li>tail 从尾部读取</li></ul><h3 id="修改文件时间或创建新文件-touch"><a class="markdownIt-Anchor" href="#修改文件时间或创建新文件-touch"></a> 修改文件时间或创建新文件 touch</h3><p>mtime 最近一次修改内容的时间</p><p>atime 最近一次读取时间</p><h4 id="文件与目录的隐藏权限"><a class="markdownIt-Anchor" href="#文件与目录的隐藏权限"></a> 文件与目录的隐藏权限</h4><p>除了 3个rwx 外, 还有其他权限</p><p>传统的Ext2/Ext3/Ext4文件系统有隐藏属性, chattr 设置, lsattr查看. 可设置其不可修改的特性. 但xfs文件系统仅支持部分chattr参数.</p><table><thead><tr><th>属性名字</th><th>作用</th></tr></thead><tbody><tr><td>A</td><td>存取时间atime不会被修改</td></tr><tr><td>a</td><td>文件只能增加数据, 不能删除也不能修改 (root专属)</td></tr><tr><td>d</td><td>文件或目录不能被dump备份</td></tr><tr><td>i</td><td>文件不能更名, 删除, 无法写入或新增. (root专属)</td></tr><tr><td>s</td><td>文件被删除时, 会被完全的移除出磁盘空间</td></tr></tbody></table><p>哇, macos不支持. centos支持</p><h4 id="特殊权限"><a class="markdownIt-Anchor" href="#特殊权限"></a> 特殊权限</h4><ul><li><p>SUID</p><ul><li>仅对二进制程序 (命令) 有效</li><li>执行者对于该程序需要具有 x 的可执行权限；</li><li>本权限仅在执行该程序的过程中有效</li><li>执行这<mark>具有该程序拥有者的权限</mark></li></ul><p>常见, Linux系统的账号密码记录在 /etc/shadow文件中, 权限是仅有root可读和root强制写入</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210801160759274.png?raw=true" alt="image-20210801160759274"></p><p>但不同用户可执行passwd, 修改自己的密码,</p><p>步骤</p><ul><li>用户A对于 /usr/bin/passwd该命令有x权限, 表示A能执行passwd</li><li>passwd的拥有者是root</li><li>A执行passwd过程中, 会暂时获得root权限</li><li>/etc/shadow就可被A所执行的passwd所修改</li></ul></li></ul><h4 id="默认权限"><a class="markdownIt-Anchor" href="#默认权限"></a> 默认权限</h4><p>当创建一个新的文件或目录, 其默认权限与umask命令有关. 建议使用umask -s</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210801153941787.png?raw=true" alt="image-20210801153941787"></p><p>umask的二进制表示是 该rwx = 7 - umask的二进制表示.</p><p>如上</p><ul><li>u = rwx = 7 - 0 = 7</li><li>g = r-x = 5 = 7 - 2</li><li>o = r-x = 5 = 7 - 2</li></ul><p>umask可以设置默认权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 表示 g = --- 与 o = ---</span></span><br><span class="line">umask 077 </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="观察文件类型file命令"><a class="markdownIt-Anchor" href="#观察文件类型file命令"></a> 观察文件类型file命令</h4><p>当一个文件属于ASCII文件或data文件, 或binary文件, 且没用到动态函数库, 可用file判断文件格式</p><h4 id="指令路径搜索-which"><a class="markdownIt-Anchor" href="#指令路径搜索-which"></a> 指令路径搜索 which</h4><p>which命令  寻找可执行文件</p><p>which + 命令名 输出该命令的完整文件名</p><h4 id="文件名搜寻"><a class="markdownIt-Anchor" href="#文件名搜寻"></a> 文件名搜寻</h4><p>whereis 从系统中一些特定的目录中寻找文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bmsu] 文件或目录名</span><br><span class="line">-b :只找binary格式文件</span><br><span class="line">-m : 只在说明文档manual路径下的文件</span><br><span class="line">-s :只找source来源文件</span><br></pre></td></tr></table></figure><p>locate指令</p><p>尽在已创建的数据库 /var/lib/mlocate/里面的数据中搜寻. 速度快</p><p>centos每一天更新一次, 可用updatedb强制刷新, 但花时较长</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> locate [-0Scims] [-l <span class="built_in">limit</span>] [-d database] pattern ...</span></span><br><span class="line">locate [-ir] keyword</span><br><span class="line">-i : 忽略大小写</span><br><span class="line">-c : 不输出文件名, 仅计算找到文件数量</span><br><span class="line">-l : 仅输出几行</span><br><span class="line">-S : 输出locate所使用的数据库文件的相关信息</span><br><span class="line">-r : 后面接正则表达式</span><br></pre></td></tr></table></figure><p>find指令</p><p>遍历硬盘查找</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br><span class="line">在PATH目录下寻找</span><br></pre></td></tr></table></figure><p>有许多选项, 如 归属使用者, 更改日期, 文件大小, 文件特殊属性等限制</p><p>action</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-exec command : command为其他指令</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从path中找到py文件, 并执行 ls -l ..</span></span><br><span class="line">find path -name '*.py' -exec ls -l {} \;</span><br></pre></td></tr></table></figure><p>find的额外动作从 -exec 到 ; 结束  \是转义字符</p><h3 id="第七章-linux磁盘与文件系统管理"><a class="markdownIt-Anchor" href="#第七章-linux磁盘与文件系统管理"></a> 第七章 Linux磁盘与文件系统管理</h3><p>Centos7 默认使用xfs文件系统</p><p>往往一个磁盘分区只被格式化为一个文件系统. 而如今利用LVM与软件磁盘阵列技术, 使得一个分区可被格式化为多个文件系统. 当然, 多个分区可以合为一个文件系统.</p><p>一个文件系统通常有 (索引式文件系统)</p><ul><li>superblock 记录文件系统的整体信息</li><li>inode 记录文件属性, 一个文件占用一个inode, 同时记录该文件所在block号码</li><li>block 记录文件的内容</li></ul><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210801225436151.png?raw=true" alt="image-20210801225436151" style="zoom:50%;"><p><mark>通常inode和block是提前规划好的, 不变动的</mark></p><blockquote><p>Ext2 在block大小有 1K, 2K, 4K三种.</p></blockquote><p>FAT格式是链表式文件系统</p><p>无inode, block等</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210801225446441.png?raw=true" alt="image-20210801225446441" style="zoom:50%;"><h4 id="ext2"><a class="markdownIt-Anchor" href="#ext2"></a> EXT2</h4><p>采用索引式文件系统. 不过若文件系统容量高达数百GB. 将所有indoe和block管理是困难的. 所以格式化会将分成多个区块群组. 每个群组有独立的inode/superblock/block系统.</p><p>Ext2的block有如下限制</p><ul><li>block的大小与数量在格式化后不会再变动</li><li>每一个block内最多放置一个文件的数据 (会有碎片产生)</li><li>一个文件若过大, 会占用多个block</li></ul><blockquote><p>若一块block的大小越小, 那么indoe会变多, 文件系统性能也会下降. 通常, 是设置到4K</p></blockquote><p>EXt2的inode信息</p><ul><li>文件的存取模式</li><li>文件拥有者与群组</li><li>文件容量</li><li>占用block号</li></ul><p>特点</p><ul><li><p>一个文件仅占用一个inode,</p></li><li><p>每个inode固定128Bytes (Ext2)</p></li></ul><p>superblock超级区块</p><p>记录整个filesystem</p><p>记录信息</p><ul><li>block与inode总量</li><li>未使用block与inode数量</li><li>文件系统挂载时间等</li></ul><p>block bitmap 与 inode bitmap</p><p>记录剩余的block号与inode号.</p><h4 id="与目录树的关系"><a class="markdownIt-Anchor" href="#与目录树的关系"></a> 与目录树的关系</h4><ul><li>目录<br>在Linux下的文件系统创建一个目录, 文件系统会分配一个inode与至少一块block给目录</li><li>文件<br>ext2会分配一个inode与相对于该文件大小的block数量给文件</li></ul><p>目录里的block会记录文件的inode.</p><h4 id="新增步骤"><a class="markdownIt-Anchor" href="#新增步骤"></a> 新增步骤</h4><ol><li>确定是否有w + x权限</li><li>根据inode bitmap找到没有使用inode号码, 写入权限</li><li>根据block bitmap找到没有使用的block号码, 写入block中, 并更新inode里的block指向</li><li>将写入的inode与block同步更新到inode bitmap与blockmap中, 更新superblock</li></ol><h4 id="日志式文件系统"><a class="markdownIt-Anchor" href="#日志式文件系统"></a> 日志式文件系统</h4><p>避免不一致问题</p><blockquote><p>登记某个block已经被分配, 但实际因为某些原因, 并没有分配</p></blockquote><p>一个区块, 用于记录写入或修改文件时的步骤</p><ol><li>预备                     准备写入</li><li>实际写入             开始写入文件的权限与数据</li><li>结束                     文件完成在区块的记录</li></ol><h3 id="linux文件系统的运行"><a class="markdownIt-Anchor" href="#linux文件系统的运行"></a> Linux文件系统的运行</h3><p>所有数据要写入到内存后, CPU才能进行处理. 而磁盘读写速度太慢, 效率过低. Linux的解决方法是 <mark>非同步处理</mark></p><p>若内存中的文件没有被修改过, 无需写入. 若文件被修改, 则会一段时间后, 统一写回磁盘 (sync命令强制写回磁盘 ).</p><h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h4><ul><li>Linux的实体内存一般而言会被用完, 加速系统性能.</li><li>若不正常关机, 某些在内存里修改的文件但没写回到磁盘中, 会丢失修改.</li></ul><h3 id="挂载点的意义"><a class="markdownIt-Anchor" href="#挂载点的意义"></a> 挂载点的意义</h3><p>每个文件系统都有独立 inode / block / superblock信息, 但需要链接到目录树才能被使用.</p><p><mark>文件系统与目录树结合的动作为挂载</mark>.</p><h3 id="其余linux支持的文件系统与vfs"><a class="markdownIt-Anchor" href="#其余linux支持的文件系统与vfs"></a> 其余Linux支持的文件系统与VFS</h3><p>Linux支持 ext2 /ext3 /ext4文件系统格式. NFS/ SMBFS/ FAT ( Windows支持 ) 等也支持</p><p>VFS管理文件系统. 对于不同的文件系统, VFS可以抽象一个统一的接口.</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210802094729046.png?raw=true" alt="image-20210802094729046" style="zoom:50%;"><h3 id="xfs文件系统简介"><a class="markdownIt-Anchor" href="#xfs文件系统简介"></a> XFS文件系统简介</h3><p>EXT系列支持度最广, 但格式化慢. 由于事先规划处所有的inode/block/metadata等数据. 硬盘越大, 划分所花费时间越多.</p><h4 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h4><p>数据区 + 文件系统活动登录区 + 实时运行区</p><ul><li><p>数据区<br>包含 inode/ data block/ super block等数据, 当系统要用时, 才会动态生成</p></li><li><p>文件系统活动登录区<br>记录文件系统的变化, 日志区. 文件变化会被记录在此地.</p></li><li><p>实时运行区</p><p>extent区块的大小在格式化时需要制定, 4K ~ 1G. 当文件被创建时, xfs会在该区段寻找extent区块, 将文件放置在内. 当分配完, 再写入到data section ( 数据区 )的inode与block.</p><p>与实体磁盘性能相关.</p></li></ul><h3 id="文件系统简单操作"><a class="markdownIt-Anchor" href="#文件系统简单操作"></a> 文件系统简单操作</h3><h4 id="查看磁盘与目录的容量"><a class="markdownIt-Anchor" href="#查看磁盘与目录的容量"></a> 查看磁盘与目录的容量</h4><p>查看superblock区块与inode的数据</p><ul><li>df: 列出文件系统的整体使用量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df [-ahikHTm] [目录或文件名]</span><br><span class="line">-a : 列出所有文件系统</span><br><span class="line">-k : 以KBytes的容量显示各个文件系统</span><br><span class="line">-m : 以MBytes的容量显示各个文件系统</span><br></pre></td></tr></table></figure><p>Mounted on 挂载点</p><ul><li>du: 评估文件系统的磁盘使用量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du [-ahskm] 文件或目录path</span><br><span class="line">-a 列出所有文件与目录容量</span><br><span class="line">-s 仅列出总量</span><br></pre></td></tr></table></figure><h4 id="实体链接与符号链接-ln"><a class="markdownIt-Anchor" href="#实体链接与符号链接-ln"></a> 实体链接与符号链接 ln</h4><p>种类</p><ul><li><p>Windows的捷径功能 符号链接</p><p>新建一个独立文件, 而该文件会让数据的读取指向link的文件名. 当源文件被删除, 那么符号链接会无法打开文件.</p></li><li><p>inode链接  实体链接</p><p>允许多个文件占用同一个inode号码. 只是<mark>在某一个目录下新增一笔文件名链接到某inode号码的管理记录</mark>而已.</p><p>好处</p><ul><li>安全, 当将链接中任一个文件名删除, inode与block仍是存在</li><li>耗费小</li></ul><p>限制</p><ul><li>不能跨文件系统</li><li>不能link目录<br>过于复杂, link一个目录, 还需要link目录下的所有文件 (还有新建的文件)</li></ul></li></ul><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803150716163.png?raw=true" alt="image-20210803150716163"></p><blockquote><p>实体链接可以说与fileSave权限是相同的, 但符号链接不是, 对所有人都是rwx</p><p>第二列的数字是该文件所拥有的链接数目</p></blockquote><p>创建命令 ln</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> centos中默认创建实体链接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认是实体链接</span></span><br><span class="line">ln 文件path link的path</span><br></pre></td></tr></table></figure><h3 id="磁盘的分区-格式化-检验与挂载"><a class="markdownIt-Anchor" href="#磁盘的分区-格式化-检验与挂载"></a> 磁盘的分区, 格式化, 检验与挂载</h3><p>新增一个硬盘的动作</p><ol><li>对磁盘进行分区, 创建可用分区</li><li>对分区格式化, 创建 文件系统</li><li>可对文件系统进行检验</li><li>进行挂载</li></ol><h4 id="观察磁盘分区状态"><a class="markdownIt-Anchor" href="#观察磁盘分区状态"></a> 观察磁盘分区状态</h4><p>磁盘分区有 MBR与GPT格式. 所用的分区工具也不同</p><h4 id="lsblk-列出所有储备设备"><a class="markdownIt-Anchor" href="#lsblk-列出所有储备设备"></a> lsblk  列出所有储备设备</h4><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803153244395.png?raw=true" alt="image-20210803153244395"></p><ul><li><p>MAJ:MIN 主要:次要设备代码</p></li><li><p>RM: 0为不可卸载设备</p></li><li><p>RO: 1为只读设备</p></li><li><p>TYPE:</p><ul><li>disk 磁盘</li><li>part 分区</li><li>rom 只读</li></ul></li></ul><h4 id="lsblk-f"><a class="markdownIt-Anchor" href="#lsblk-f"></a> lsblk -f</h4><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803153518944.png?raw=true" alt="image-20210803153518944"></p><p>UUID 全域单一识别码</p><p>直接使用blkid找出设备的UUID. 用于挂载或者使用这个设备使用</p><h4 id="blkid"><a class="markdownIt-Anchor" href="#blkid"></a> blkid</h4><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803154536125.png?raw=true" alt="image-20210803154536125"></p><p>列出设备的UUID等参数, 也<mark>包括设备名称device_name, 文件系统类型</mark></p><h4 id="parted-device_name-print"><a class="markdownIt-Anchor" href="#parted-device_name-print"></a> parted device_name print</h4><p>列出磁盘的相关数据</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803154852801.png?raw=true" alt="image-20210803154852801"></p><ul><li><p>Model 磁盘的模块名称</p></li><li><p>Disk 磁盘总容量</p></li><li><p>Sector size 扇区容量</p></li><li><p>Partition Table 分区表格式  MBR/ GPT / loop</p><blockquote><p>loop (循环) 表示, 在另一个文件系统中包含虚拟文件系统的文件。</p></blockquote></li></ul><h4 id="磁盘分区-2"><a class="markdownIt-Anchor" href="#磁盘分区-2"></a> 磁盘分区</h4><p>磁盘分区命令</p><ul><li>gdisk      GPT分区</li><li>fdisk       MBR分区</li></ul><h4 id="gdisk"><a class="markdownIt-Anchor" href="#gdisk"></a> gdisk</h4><h4 id="新增分区"><a class="markdownIt-Anchor" href="#新增分区"></a> 新增分区</h4><p>进行GPT分区.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 后面为对应磁盘总目录名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不要加数字, 加数字表示分区, 而gdisk操作的单位是整块硬盘</span></span><br><span class="line">gdisk /dev/sda</span><br></pre></td></tr></table></figure><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803160641615.png?raw=true" alt="image-20210803160641615"></p><ul><li><p>? 可获得所用的可用命令</p></li><li><p>p输出当前磁盘的信息</p></li></ul><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803160439083.png?raw=true" alt="image-20210803160439083"></p><p>Logical sector size 扇区大小</p><ul><li>n为创建新的GPT分区<br><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803161129787.png?raw=true" alt="image-20210803161129787"><ul><li>partition number 分区号</li><li>First sector 首扇区号</li><li>Last sector 尾扇区号 可以使用 +1G自动算出所需扇区 +500M</li><li>Hex code or GUID  选择未来这个分区预计使用的文件系统</li></ul></li></ul><p>完成</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803161708306.png?raw=true" alt="image-20210803161708306"></p><p>按 w写入</p><p>需要更新分区表 partprobe指令</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803161919501.png?raw=true" alt="image-20210803161919501"></p><p>新增 sda4, sda5, sda6分区</p><h4 id="删除分区"><a class="markdownIt-Anchor" href="#删除分区"></a> 删除分区</h4><ol><li><p>使用gdisk + 硬盘文件</p></li><li><p>输入 d</p></li><li><p>再输入 p 检查</p></li><li><p>w退出</p></li><li><p>partprobe 更新分区表</p></li></ol><p><mark>不要删除一个使用中的分区</mark>, 需要先卸载</p><h3 id="磁盘格式化"><a class="markdownIt-Anchor" href="#磁盘格式化"></a> 磁盘格式化</h3><p>创建文件系统, 分区完毕, 需要对该分区进行文件系统格式化</p><p>mkfs [tab][tab] 会列出支持的文件系统</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803165924333.png?raw=true" alt="image-20210803165924333"></p><h4 id="xfs系统-mkfsxfs"><a class="markdownIt-Anchor" href="#xfs系统-mkfsxfs"></a> xfs系统 mkfs.xfs</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 后面为分区文件路径</span></span><br><span class="line">mkfs.xfs /dev/sda3</span><br></pre></td></tr></table></figure><p>可使用默认配置, 也可有额外参数可选</p><h3 id="文件系统挂载与卸载"><a class="markdownIt-Anchor" href="#文件系统挂载与卸载"></a> 文件系统挂载与卸载</h3><p>当分区完毕 + 文件系统格式化. 最后一步是挂载目录.</p><p>首先需确定</p><ul><li><p>单一文件系统不应该被重复挂载在不同的挂载点中</p></li><li><p>单一目录不应该重复挂载多个文件系统</p></li><li><p>挂载点的目录应该为空目录</p><blockquote><p>若挂载的目录不空, 那么挂载后, 原目录下的文件会被隐藏, 当新分区被卸载后, 文件才会显现</p></blockquote></li></ul><h4 id="mount"><a class="markdownIt-Anchor" href="#mount"></a> mount</h4><p><mark>重启系统后, 需要自己重新挂载, 除非设置开机自挂载</mark></p><p>Linux系统自动分析文件系统驱动, 也可-t指定文件系统.</p><blockquote><p>通过分析superblock打在Linux自动的驱动程序测试挂载. 获取文件系统类型</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找对应的UUID</span></span><br><span class="line">blkid 分区文件路径 /dev/sda3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载到path上</span></span><br><span class="line">mount UUID="...." path</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">df path --block-size=1M path</span><br></pre></td></tr></table></figure><p>同样方法可以挂载CD或DVD等</p><h4 id="重新挂载"><a class="markdownIt-Anchor" href="#重新挂载"></a> 重新挂载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 / 即根目录重新挂载, 并设为读写</span></span><br><span class="line">mount -o remount,rw,auto /</span><br></pre></td></tr></table></figure><p>可利用mount暂时额外的挂载到另一个目录</p><p>功能与符号链接类似</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将var暂时挂载在/data/var上</span></span><br><span class="line">mount --bind /var /data/var</span><br></pre></td></tr></table></figure><h4 id="卸载"><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h4><p>卸载umount 将设备文件卸载. 要推出U盘, 也要先卸载再推出. 需要没有使用的情况下, 才可卸载. -f 除外</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看挂载点</span></span><br><span class="line">mount</span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载</span></span><br><span class="line">umount 挂载点(或设备文件名)</span><br></pre></td></tr></table></figure><h3 id="磁盘文件系统参数修订"><a class="markdownIt-Anchor" href="#磁盘文件系统参数修订"></a> 磁盘/文件系统参数修订</h3><p>一切皆文件, 那么一个文件需要满足什么条件才能代表是一个设备呢?</p><p>通过文件的major与minor数值</p><blockquote><p>主要设备代码major</p><p>次要设备代码minor</p></blockquote><p>手动处理设备文件</p><p>mknod指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mknod 设备文件名 [bcp] [Major] [Minor]</span><br><span class="line">b : 磁盘, 储存设备文件</span><br><span class="line">c : 输入设备文件</span><br><span class="line">p : FIFO文件</span><br></pre></td></tr></table></figure><p>ll命令查看 major与minor</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210804152451197.png?raw=true" alt="image-20210804152451197"></p><p>8为major</p><p>0为minor</p><p>修改UUID与labelname</p><p>xfs_admin命令 修改xfs文件系统的UUID</p><p>uuidgen 生成新的UUID</p><h3 id="开机自动挂载"><a class="markdownIt-Anchor" href="#开机自动挂载"></a> 开机自动挂载</h3><p>限制</p><ul><li>根目录必须挂载, 且第一个被挂载</li><li>其余挂载点必须创建</li><li>所有分区和挂载点同一个时刻只能挂载一次</li><li><mark>卸载时, 必须将工作目录移除到 挂载点之外 (也不能再其子目录)</mark></li></ul><p>修改 /etc/fstab文件 即可.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设备名称或文件            <span class="comment"># 挂载点               #文件系统  # 文件参数    # 1为dump备份 # 1为fsck文件系统检验</span></span></span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=5ad4d814-4c9a-4f94-a561-b8101bf35f28 /boot xfs     defaults        0 0</span><br><span class="line">UUID=DF5A-5CE3          /boot/efi               vfat    umask=0077,shortname=winnt 0 0</span><br><span class="line">/dev/mapper/centos-home /home                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>文件系统参数</p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210804153920573.png?raw=true" alt="image-20210804153920573" style="zoom:50%;"><p>fsck检查扇区默认不开启, 因为xfs会自动检验</p><h4 id="特殊设备挂载-loop"><a class="markdownIt-Anchor" href="#特殊设备挂载-loop"></a> 特殊设备挂载 loop</h4><p>镜像文件不烧录直接挂载使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop .iso路径 挂载目录</span><br></pre></td></tr></table></figure><h3 id="内存交换空间swap"><a class="markdownIt-Anchor" href="#内存交换空间swap"></a> 内存交换空间swap</h3><p>虚拟内存, 用磁盘空间模拟内存. 即创建 swap分区</p><p>步骤</p><ol><li>分区 gdisk 分区</li><li>格式化 mkswap 设备文件名</li><li>使用 swapon 设备文件名</li><li>检查 free 与swapon -s 观察内存的容量</li></ol><h2 id="vim使用"><a class="markdownIt-Anchor" href="#vim使用"></a> vim使用</h2><p>三种模式</p><ol><li><p>一般指令模式<br>打开文件直接进入一般指令模式, 上下左右移动光标,</p><ul><li>dd 删除一整列</li><li>u 撤销</li><li>[ctrl] + r 重做</li></ul></li><li><p>编辑模式<br><mark>按 “i, I, o, O, a, A, r, R”, 左下方出现INSERT字样</mark>, 进行编辑 按ESC退回一般模式</p></li><li><p>命令行命令模式<br>在一般模式下, <mark>输入 “: / ?” 三个中的任何一个按钮</mark>, 将光标移动到最下面一列, 可提供搜寻数据的动作. 离开vi, 显示行号等功能</p><ul><li><p>退出<br>在一般指令下, 输入: 后, 输入wq 回车即可. 可加 wq! 强制写入</p></li><li><p>搜寻<br>/word 在光标之下寻找一个word字串</p><p>?word 在光标之上寻找</p></li></ul></li></ol><h2 id="bash"><a class="markdownIt-Anchor" href="#bash"></a> BASH</h2><p>kernel 核心 是不允许直接访问的, 需要通过shell进行沟通. bash是shell的一种</p><p>位于 /bin/bash</p><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><ul><li><p>记录执行命令历史</p><p>在文件~/.bash_history内, 每关闭一次终端, 都会将写过的命令记录到该文件内.</p></li><li><p>命令补全<br>一个字母 + tab 是补全命令<br>第二个字母及以后 + tab 是补全文件</p></li><li><p>别名设置 alias<br>用别名代替其他命令名 alias name=command<br>使用时 无需$</p></li><li><p>工作控制</p></li><li><p>程序化脚本<br>shell scripts</p></li><li><p>万用字符<br>*</p></li></ul><h4 id="type指令"><a class="markdownIt-Anchor" href="#type指令"></a> type指令</h4><p>用于区分一个指令到底是否为bash内置</p><h4 id="换行"><a class="markdownIt-Anchor" href="#换行"></a> 换行</h4><p>\ + [enter]键</p><h4 id="变量功能"><a class="markdownIt-Anchor" href="#变量功能"></a> 变量功能</h4><ul><li><p>取用echo</p><p>变量被使用时必须 + $</p><ul><li>双引号含特殊字符会进行变量对变量值的转化</li><li>单引号含特殊字符会被视为一般字符</li><li>可用转移字符 \ 将其一般化</li></ul></li><li><p>变量设置</p><p>varName=varVal</p><ul><li>不能有空白字符</li><li>只能是英文字符, 数字, 但开头字符不能是数字</li></ul></li><li><p>变量 -&gt; 环境变量 (全局变量) 子程序也能使用</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH</span><br></pre></td></tr></table></figure></li><li><p>unset 取消变量</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset valName</span><br></pre></td></tr></table></figure><p>下载网站:</p></li></ul><h3 id="环境变量的功能"><a class="markdownIt-Anchor" href="#环境变量的功能"></a> 环境变量的功能</h3><p>查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前shell环境下的所有环境变量与其内容</span></span><br><span class="line">env</span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察环境变量与自订变量</span></span><br><span class="line">set</span><br></pre></td></tr></table></figure><h4 id="特殊变量"><a class="markdownIt-Anchor" href="#特殊变量"></a> 特殊变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回上一执行命令的返回的错误码, 0为正常, 其余为错误代码</span></span><br><span class="line">echo $? </span><br></pre></td></tr></table></figure><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4><h3 id="bash-shell的操作环境"><a class="markdownIt-Anchor" href="#bash-shell的操作环境"></a> bash shell的操作环境</h3><p>路径与指令搜索顺序</p><ol><li>以相对或绝对路径执行指令</li><li>由alias找到对应指令执行</li><li>bash内置指令</li><li>通过$PATH这个变量的顺序搜索到的第一个指令来执行</li></ol><h4 id="进站与欢迎讯息"><a class="markdownIt-Anchor" href="#进站与欢迎讯息"></a> 进站与欢迎讯息</h4><p>/etc/issue</p><p>修改/etc/issue文件</p><p>在 issue文件中 \ + 英文字符会有特殊函数</p><ul><li>\d 本地端时间的日期</li><li>\l 显示第几个终端机接口</li><li>\n 显示主机网络名称</li><li>\O 显示域名</li></ul><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210806174700947.png?raw=true" alt="image-20210806174700947"></p><p>而 <a href="http://issue.net">issue.net</a> 用于远程访问</p><p>/etc/motd文件</p><p>用于让使用者登录后获取信息</p><h3 id="bash的环境配置文件"><a class="markdownIt-Anchor" href="#bash的环境配置文件"></a> bash的环境配置文件</h3><h4 id="无登录shell-与-有登录shell"><a class="markdownIt-Anchor" href="#无登录shell-与-有登录shell"></a> 无登录shell 与 有登录shell</h4><p>无登录shell</p><p>是基于图形化接口启动终端, 无需输入密码,</p><p>读取 ~/.bashrc文件</p><p>有登录shell</p><p>是开机时即打开shell, 需要密码才可使用</p><p>有登录shell 会读取 /etc/profile (系统整体设置) 与 ~/.bash_profile 使用者个人设置</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210806175218878.png?raw=true" alt="image-20210806175218878"></p><p>login_shell的读取流程</p><p>可用source命令读取配置文件内容</p><h3 id="数据流重导向"><a class="markdownIt-Anchor" href="#数据流重导向"></a> 数据流重导向</h3><p>standard output标准输入</p><p>将原本需要由键盘输入的数据，该由文件内容来代替</p><p>&lt; 输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 file.txt文件, 内容由anotherFile.txt输入</span></span><br><span class="line">cat &gt; file.txt &lt; anotherFile.txt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;&lt; 表示接受的输入字符串。当一行中包含该字符串时, 意味结束, 不包含这一行内容</span></span><br><span class="line">cat &gt; file.txt &lt;&lt; </span><br></pre></td></tr></table></figure><h4 id="standard-error-output标准输出"><a class="markdownIt-Anchor" href="#standard-error-output标准输出"></a> standard error output标准输出</h4><p>默认都为屏幕</p><p>标准输出 stdout &gt; (覆盖) 或者 &gt;&gt; (追加)</p><p>标准错误输出 stderr 2&gt; (覆盖) 或 2&gt;&gt;(追加)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将命令ll重定向输出为 save.txt</span></span><br><span class="line">ll &gt;&gt; save.txt</span><br></pre></td></tr></table></figure><p>/dev/null 垃圾桶黑洞设备 不显示信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name .bashrc 2&gt; /dev/null</span><br></pre></td></tr></table></figure><h4 id="命令执行的判断依据"><a class="markdownIt-Anchor" href="#命令执行的判断依据"></a> 命令执行的判断依据 ; , &amp;&amp; ||</h4><p>与C++相同, 每一个函数都有回传值, 0为正常执行</p><p>cmd1 &amp;&amp; cmd2<br>cmd1执行完毕, 执行cmd2. 若cmd1执行错误,  cmd2不会执行</p><p>cmd1 || cmd2<br>cmd1执行完毕不执行cmd2</p><h3 id="管道命令pipe"><a class="markdownIt-Anchor" href="#管道命令pipe"></a> 管道命令pipe |</h3><p>bash命令执行的有输出数据, 可用pipe | 将输出数据当为其他指令的输入.</p><blockquote><p>其他指令必须能接受标准输入的数据 ( 又称管道指令 ), 错误输出不会处理. 可用 2&gt;&amp;1将错误输出转化为标准输出</p></blockquote><h3 id="截取指令-cut-grep"><a class="markdownIt-Anchor" href="#截取指令-cut-grep"></a> 截取指令 cut, grep</h3><p>cut 对子串进行分割</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cut -d '分割字符' -f fields</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将PATH以:进行分割, 并只显示第5, 6个</span></span><br><span class="line">echo ${PATH} | cut -d ':' -f 5, 6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只显示  每一行[12, end)的字符串</span></span><br><span class="line">export | cut -c 12-</span><br></pre></td></tr></table></figure><ul><li>d后面解分割字符</li><li>f 依据-d的分割, 将信息分区成数段, 用-f取出第几段</li><li>-c 字符区间, 以字符为单位</li></ul><p>grep匹配数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] '搜索的字符串' filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grep [-A] [-B] [--color='auto'] '关键词' filename</span><br><span class="line"></span><br><span class="line">-A：后面可以加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来</span><br><span class="line">-B：后面可以加数字，为 befer 的意思，处理列出该行外，前面的 n 行也列出来</span><br><span class="line">--colort=auto：可将正确的哪个截取数据列出颜色</span><br></pre></td></tr></table></figure><h2 id="shell脚本"><a class="markdownIt-Anchor" href="#shell脚本"></a> SHELL脚本</h2><p><mark>需要注意变量设置不得有空格, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="36.053ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 15935.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(822, 0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1307, 0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2185, 0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3063, 0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(3592, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4192, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(4712, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5378.8, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">为</text><text data-variant="normal" transform="translate(900, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">获</text><text data-variant="normal" transform="translate(1800, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">取</text></g><g data-mml-node="mi" transform="translate(8356.6, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(8789.6, 0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(9274.6, 0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(10152.6, 0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(11030.6, 0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(11559.6, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(12159.6, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(12957.3, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">的</text><text data-variant="normal" transform="translate(900, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">输</text><text data-variant="normal" transform="translate(1800, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">出</text></g><g data-mml-node="mo" transform="translate(15657.3, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g></g></svg></mjx-container>{变量名}为获取变量名的内容</mark></p><p>用于自动执行某些固定的任务</p><p>建议将脚本放置到$PATH中, 那么可以直接使用, 而不是用绝对路径执行. 需要有 rx权限</p><p>注释 #</p><p>使用vim写会有语法 检查与标亮</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 建议格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash    宣告该script使用的shell名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Program:     声明该脚本的作用</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">User inputs his firstname and last name. It will output the full name</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> History:     修改历史</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2015/07/16 authorName First release   日期 作者 版本号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 主要环境变量的宣告</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序部分</span></span><br><span class="line">read -p "Please input your name: " firstname </span><br><span class="line">echo -e "\n Your name is ${firstname}" </span><br><span class="line"><span class="meta">#</span><span class="bash"> 可自订推出号 对应 $?</span> </span><br><span class="line">exit 0 </span><br></pre></td></tr></table></figure><p>启用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在父程序执行, 声明的变量会影响父bash</span></span><br><span class="line">source bashPath</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者 在子程序bash中执行, 声明的变量以及结果, 是不会影响父程序</span></span><br><span class="line">chmod a+x bashPath;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要注意工作目录位于该脚本的所在目录</span></span><br><span class="line">./bashPath</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可将该脚本放置到<span class="variable">$PATH</span>指定的目录中, 可直接输入shell文件名(要加后缀.sh,如源文件有)即可</span></span><br></pre></td></tr></table></figure><p>可利用其他指令的输出为变量赋值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取前两天的日期</span></span><br><span class="line">date1 = ${date --date='2 days ago' + '%Y%m%d'}</span><br><span class="line"><span class="meta">#</span><span class="bash">字符串拼接</span></span><br><span class="line">file1 = ${filename}${date1} </span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建</span></span><br><span class="line">touch "${date1}"</span><br></pre></td></tr></table></figure><h3 id="判断式"><a class="markdownIt-Anchor" href="#判断式"></a> 判断式</h3><h4 id="test指令"><a class="markdownIt-Anchor" href="#test指令"></a> test指令</h4><p>test指令的测试功能, 可用于测试文件或文件夹是否存在, 如存在则返回0, 不存在返回非0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 文件是否存在, 存在返回0, 配合&amp;&amp; 触发<span class="built_in">echo</span> <span class="string">"exist"</span></span></span><br><span class="line">test -e filename &amp;&amp; echo "exist" || echo "no exist"</span><br><span class="line">-e 文件名是否存在</span><br><span class="line">-f 文件名是否存在且是否为文件</span><br><span class="line">-d 文件名是否为目录</span><br><span class="line">-b 文件名是否为一个block device设备</span><br><span class="line"></span><br><span class="line">两个文件的比较</span><br><span class="line">test file1 -nt file2</span><br><span class="line">-nt file1是否比file2新</span><br><span class="line">-ot file1是否比file2旧</span><br><span class="line">-ef 是否为同一文件, 若指向同一个inode,则是</span><br><span class="line"></span><br><span class="line">整数之间的判定</span><br><span class="line">test n1 -eq n2</span><br><span class="line">-eq 两数值相等</span><br><span class="line">-ne 不等</span><br><span class="line">-gt 大于</span><br><span class="line">-lt 小于</span><br><span class="line">-ge 大于等于</span><br><span class="line">-le 小于等于</span><br><span class="line"></span><br><span class="line">字符串</span><br><span class="line">test -z string 字串是否为空, 空返回0</span><br><span class="line">-n 非空 为0</span><br><span class="line">test str1 == str2 是否等于</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判断符号"><a class="markdownIt-Anchor" href="#判断符号"></a> 判断符号 []</h4><p>主义中括号两端须有空白字符分隔</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 判断 HOME变量是否为空</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -选项与 <span class="built_in">test</span>中相同</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -z <span class="string">"<span class="variable">${HOME}</span>"</span> ];</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回上一个表单式的返回值</span></span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><h4 id="if判断"><a class="markdownIt-Anchor" href="#if判断"></a> if判断</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件表达式 ]; then</span><br><span class="line">做点啥</span><br><span class="line">elif [ 条件表达式 ]; then</span><br><span class="line">做点啥</span><br><span class="line">else</span><br><span class="line">做点啥</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span></span><br><span class="line">if [ "${yn}" == "Y" ] || [ "${yn}" == "y" ]; then</span><br><span class="line">        echo "Ok，continue"</span><br><span class="line">        exit 0</span><br><span class="line">else</span><br><span class="line">        echo "Oh，interrupt！"</span><br><span class="line">        exit 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结尾用 <span class="keyword">if</span>倒着写表示</span></span><br><span class="line">fi</span><br><span class="line">echo "I don't know what your choice is" &amp;&amp; exit 0</span><br></pre></td></tr></table></figure><h3 id="case-esac判断"><a class="markdownIt-Anchor" href="#case-esac判断"></a> case esac判断</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关键词为 <span class="keyword">case</span> 还有 变量前的 $ 符号</span></span><br><span class="line">case $变量名称 in</span><br><span class="line"><span class="meta">#</span><span class="bash"> 每个变量内容建议用双引号括起来，关键词则为小括号</span></span><br><span class="line">“变量内容 1”)</span><br><span class="line"> 程序段</span><br><span class="line"> ;; </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 使用两个连续的分号来结尾</span></span><br><span class="line">“变量内容 2”)</span><br><span class="line"> 程序段</span><br><span class="line"> ;;</span><br><span class="line"><span class="meta"> #</span><span class="bash"> 最后一个变量内容需要用 * 来代表所有其他值</span></span><br><span class="line">*)   </span><br><span class="line">程序段</span><br><span class="line"> ;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最终的 <span class="keyword">case</span> 结尾，就是反过来拼写的字符 <span class="keyword">esac</span></span></span><br><span class="line">esac  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case "$1" in</span><br><span class="line">    stop) stop ;;</span><br><span class="line">    status) status ;;</span><br><span class="line">    start|restart|reload|force-reload) restart ;;</span><br><span class="line">    condrestart) condrestart ;;</span><br><span class="line">    *) usage ;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="shell-script自带参数"><a class="markdownIt-Anchor" href="#shell-script自带参数"></a> shell script自带参数</h3><ul><li>$# 参数个数</li><li>$@ 全部参数内容</li><li>$0 程序文件名</li><li>$1 第一个参数</li><li>$2 第二个参数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shift</span>1<span class="comment"># 偏移指令, 参数列表首往后移一个</span></span><br><span class="line"><span class="built_in">shift</span> 10 <span class="comment"># 后移10个, 剩余参数列表长度&gt;10 才有效</span></span><br></pre></td></tr></table></figure><h3 id="shell-function"><a class="markdownIt-Anchor" href="#shell-function"></a> shell function</h3><p>一定要现在程序最前面, 执行方式是从上到下, 从左到右</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fucName(){</span><br><span class="line">程序段</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><mark>function的自带参数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 778 860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(500, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g></g></svg></mjx-container>2与程序的参数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 778 860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(500, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g></g></svg></mjx-container>2 是不同的, 是独立的</mark></p><h3 id="循环loop"><a class="markdownIt-Anchor" href="#循环loop"></a> 循环loop</h3><h4 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [condition]</span><br><span class="line">do </span><br><span class="line">程度段</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> for循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 循环con1, con2, con3</span></span><br><span class="line">for var in con1 con2 con3...</span><br><span class="line">do</span><br><span class="line">循环体</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数值处理</span></span><br><span class="line">for ((初始值;限制值;执行步骤))</span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">total=0</span><br><span class="line">for((i=1; i&lt;=5;i++))</span><br><span class="line">do</span><br><span class="line">total = $((${total} + ${i}))</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先定义一个网域的前部分</span></span><br><span class="line">network="192.168.0"</span><br><span class="line"><span class="meta">#</span><span class="bash"> seq 为 sequence 连续的意思</span></span><br><span class="line">for sitenu in $(seq 1 100)</span><br><span class="line">do</span><br><span class="line"><span class="meta">#</span><span class="bash"> ping -c 1 -w 1 192.168.0.101 &amp;&gt; /dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">"1"</span> || <span class="built_in">echo</span> <span class="string">"0"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &amp;&gt; /dev/null 将标准错误流重定向到黑洞 即不显示执行结果，并获取命令是否执行成功</span></span><br><span class="line">ping -c 1 -w 1 ${network}.${sitenu} &amp;&gt; /dev/null &amp;&amp; result=0 || result=1</span><br><span class="line">if [ "${result}" == 0 ]; then</span><br><span class="line">echo "${network}.${sitenu} is up"</span><br><span class="line">else</span><br><span class="line">echo "${network}.${sitenu} is down"</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="shell-script的debug"><a class="markdownIt-Anchor" href="#shell-script的debug"></a> Shell Script的DEBUG</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh [-nvx] scripts.sh</span><br><span class="line">-n 不执行script, 仅检查语法问题</span><br><span class="line">-v: 将script内容输出屏幕后, 执行</span><br><span class="line">-x: 将执行到script内容显示到屏幕上</span><br></pre></td></tr></table></figure><h2 id="程序与进程"><a class="markdownIt-Anchor" href="#程序与进程"></a> 程序与进程</h2><p>查看命令 ps -l</p><p>触发任何一个事件, 系统都会将他定义为一个程序, 并给与该程序一个ID, PID</p><p>program 一般为 二进制文件 binary file</p><p>不同用户执行程序有不同的权限, 对应同一个程序的不同进程的PID也不同</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:44-image-20210813214305166.png?raw=true" alt="image-20210813214305166"></p><ul><li><p>程序program: 二进制文件, 放置到存储媒介中</p></li><li><p>进程process: program被触发后, 根据执行者的权限与属性, 所需数据等载入内存, 并获得PID</p></li><li><p>子进程与父进程</p><p>通过PPID判断, 子进程可以获取父进程的环境比那辆</p></li></ul><h3 id="fork-and-exec-进程呼叫的流程"><a class="markdownIt-Anchor" href="#fork-and-exec-进程呼叫的流程"></a> fork and exec 进程呼叫的流程</h3><p>由父进程复制fork的方式产生一个一模一样的子进程A, 子进程A在以exec方式执行要进行的程序</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:44-image-20210814091059094.png?raw=true" alt="image-20210814091059094"></p><h3 id="常驻在内存的进程"><a class="markdownIt-Anchor" href="#常驻在内存的进程"></a> 常驻在内存的进程</h3><p>系统或网络服务. 一直运行的程序. 这些常驻程序被称为服务</p><h3 id="进程与程序"><a class="markdownIt-Anchor" href="#进程与程序"></a> 进程与程序</h3><p>执行一个程序或指令,</p><h2 id="工作管理"><a class="markdownIt-Anchor" href="#工作管理"></a> 工作管理</h2><p>终端机接口分为前台与后台, 放入前台执行的进程会出现提示字符与人交互, 而放入后台执行的进程, 不能与人交互.</p><h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意:</h4><ul><li>这些工作所触发的进程必须来自于你的 shell 的子进程（只管理自己的 bash）</li><li>前景 foreground：你可以控制与下达指令的环境</li><li>背景：可以自动运行的工作，你无法使用 ctrl + c 终止它，可以使用 bg、fg 呼叫该工作</li><li>背景中<strong>执行</strong>的进程不能等待 terminal/shell 的输入（input）</li></ul><p>在执行命令时, 可在后面 + &amp; 表示在后台运行</p><p>将 目前的工作丢到背景中_暂停_：ctrl+z</p><h3 id="观察目前的背景工作状态jobs"><a class="markdownIt-Anchor" href="#观察目前的背景工作状态jobs"></a> 观察目前的背景工作状态：jobs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs [-lrs]</span><br><span class="line">-l 列出PID</span><br><span class="line">-r 仅列出背景run的工作</span><br><span class="line">-s 仅列出正在背景中暂停的工作</span><br></pre></td></tr></table></figure><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:44-image-20210814092530116.png?raw=true" alt="image-20210814092530116"></p><p>+表示最近被放到前台工作</p><p>-最后第二个被放置到前台工作</p><p>最左边为[1]为工作号码</p><h4 id="fg将背景工作放置到前景处理"><a class="markdownIt-Anchor" href="#fg将背景工作放置到前景处理"></a> fg将背景工作放置到前景处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg 工作号码</span><br></pre></td></tr></table></figure><h4 id="bg让工作在背景下的状态变成运行中"><a class="markdownIt-Anchor" href="#bg让工作在背景下的状态变成运行中"></a> bg让工作在背景下的状态变成运行中</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg 工作号码</span><br></pre></td></tr></table></figure><h3 id="kill移除工作"><a class="markdownIt-Anchor" href="#kill移除工作"></a> kill移除工作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kill -signal $jobnumber</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出<span class="built_in">kill</span>能使用的信号</span></span><br><span class="line">kill -l </span><br><span class="line">-1：重新读取一次参数的配置文件（类似 reload）</span><br><span class="line">-2：代表与由键盘输入 ctrl+c 同样的动作</span><br><span class="line">-9：立刻强制删除一个工作</span><br><span class="line">-15：已正常的进程方式终止一项工作。与  -9 是不一样的</span><br></pre></td></tr></table></figure><p>使用vim会暂时产生一个 .filename.swp文件, 完整结束后会被移除. 若以-9结束, 那么.filename.swp不会被移除.</p><table><thead><tr><th>代号</th><th>名称</th><th>名义</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>启动被终止的进程, 重新启动</td></tr><tr><td>2</td><td>SIGINT</td><td>等同于ctrl + c 终止一个进程</td></tr><tr><td>9</td><td>SIGKILL</td><td>强制终止一个进程的运行</td></tr><tr><td>15</td><td>SIGTERM</td><td>以正常的方式终止进程, 对已经发生问题的进程无效</td></tr><tr><td>19</td><td>SIGSTOP</td><td>等同于ctrl - z暂停一个进程</td></tr></tbody></table><h3 id="脱机管理问题"><a class="markdownIt-Anchor" href="#脱机管理问题"></a> 脱机管理问题</h3><p>上面介绍的前台和后台, 仅局限于bash, 而不是整个系统, 若bash关闭, 那么无论前台还是后台, 工作都会被终止.</p><h2 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ps aux# 观察系统所有的进程数据</span><br><span class="line">ps -l # 观察与当前终端机相关的进程</span><br><span class="line">ps -lA # 观察系统所有的进程数据（显示内容项同 ps -l 的项一样，只不过是系统所有进程）</span><br><span class="line">ps axjf# 连同部分进程树状态</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-A：所有的 process 都显示出来，与 -e 具有同样的效果</span><br><span class="line">-a：不与 terminal 有关的所有 process</span><br><span class="line">-u：有效使用者（effective user）相关的 process</span><br><span class="line">x：通常与 a 一起使用，可列出完整信息</span><br><span class="line">输出格式规划：</span><br><span class="line">l：较长、较详细的将该 PID 的信息列出</span><br><span class="line">j：工作的格式（jobs format）</span><br><span class="line">-f：做一个更为完整的输出</span><br></pre></td></tr></table></figure><p>一般常用</p><p>ps -l     仅查询自己bash的进程</p><p>ps aux  查询系统所有运行的进程</p><ul><li><p>USER<br>用户</p></li><li><p>PID<br>进程识别符</p></li><li><p>%CPU<br>占用CPU率</p></li><li><p>%MEM<br>占用内存率</p></li><li><p>VSZ</p></li><li><p>RSS</p></li><li><p>TTY<br>用户的终端机位置</p></li><li><p>STAT<br>目前状态</p><ul><li>R 运行中</li><li>S 睡眠状态, 可被唤醒</li><li>D 不可被唤醒</li><li>T 停止状态</li><li>Z 僵尸状态, 进程已经终止但无法移除出内存</li></ul></li><li><p>STARTED</p></li><li><p>TIME<br>进程实际花费CPU运行的时间</p></li><li><p>COMMAND</p></li></ul><h4 id="僵尸进程"><a class="markdownIt-Anchor" href="#僵尸进程"></a> 僵尸进程</h4><p>进程中的表示后面有 &lt;defunct&gt;标识</p><p>该进程的父进程无法完整的结束该进程, 而一直在内存中, 一般僵尸进程都会交给systemd程序负责, 而systemd是所有程序的父进程, 无法杀死该进程. 只能通过重启解决.</p><h3 id="top动态观察进程变化"><a class="markdownIt-Anchor" href="#top动态观察进程变化"></a> top动态观察进程变化</h3><p>top可以持续侦测进程运行状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">top [-d 数字] | top [-bnp]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-d：后面可以接秒数，整个进程画面更新的秒数，预设是 5 秒更新一次</span><br><span class="line">-b：以批次的方式执行 top，还有更多的参数可以使用（莫名其妙啊，啥参数？），通常会搭配数据流重导向来将批次的结果输出为文件</span><br><span class="line">-n：与 -b 搭配，需要进行几次 top 的输出</span><br><span class="line">-p：指定某些 PID 来进行观察</span><br><span class="line"></span><br><span class="line">在 top 执行过程中可以使用的按键指令：</span><br><span class="line">？：显示在 top 中可以输入的按键指令</span><br><span class="line">P：以 CPU 的使用资源排序显示</span><br><span class="line">M：以 Memory 的使用资源排序显示</span><br><span class="line">N：以 PID 排序</span><br><span class="line">T：由该进程使用 CPU 时间累积（TIME+）排序</span><br><span class="line">k：给予某个 PID 一个信号（signal）</span><br><span class="line">r：给予某个 PID 重新制定一个 nice 值</span><br><span class="line">q：离开 top 软件的按键</span><br><span class="line">E：切换单位显示，比如从 KB 切换为 G 显示</span><br><span class="line">c：切换 COMMAND 的信息，name/完成指令</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="kill杀死进程"><a class="markdownIt-Anchor" href="#kill杀死进程"></a> kill杀死进程</h3><table><thead><tr><th>代号</th><th>名称</th><th>名义</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>启动被终止的进程, 重新启动</td></tr><tr><td>2</td><td>SIGINT</td><td>等同于ctrl + c 终止一个进程</td></tr><tr><td>9</td><td>SIGKILL</td><td>强制终止一个进程的运行</td></tr><tr><td>15</td><td>SIGTERM</td><td>以正常的方式终止进程, 对已经发生问题的进程无效</td></tr><tr><td>19</td><td>SIGSTOP</td><td>等同于ctrl - z暂停一个进程</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用ps + grep找到对应PID</span></span><br><span class="line">kill -SIGHUP $(ps aux|grep 'processName'|grep -v 'grep'|awk '{print $2}')</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否重启, 需要看日记</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅看后五行</span></span><br><span class="line"> tail -5 /var/log/messages</span><br></pre></td></tr></table></figure><h3 id="进程的执行顺序"><a class="markdownIt-Anchor" href="#进程的执行顺序"></a> 进程的执行顺序</h3><p>哪个进程被优先执行, 取决于优先级 priority与CPU排程. PRI值由系统动态调整</p><p>PRI值低优先级高,  用户不可调整pri值(优先级), 但可通过NI值干涉, PRI(new) = PRI(old) + nice (NI值)</p><h4 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h4><ul><li>nice 值范围是 -20~19</li><li>root 可随意调整自己或他人进程的 Nice 值，且范围为 -20~19</li><li>一般使用者仅可调整自己进程的 Nice 值，且范围仅为 0~19（避免一般用户抢占系统资源）</li><li>一般使用者仅可将 nice 值越调越高；比如 nice 为 5，则未来仅能调整到大于 5；</li></ul><h4 id="调整ni值"><a class="markdownIt-Anchor" href="#调整ni值"></a> 调整ni值</h4><ul><li>启动时给与nice值, 用nice指令</li><li>调整某个已经存在的PID的nice值, renice指令</li></ul><h3 id="free内存查看指令"><a class="markdownIt-Anchor" href="#free内存查看指令"></a> free内存查看指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-b：单位参数；默认是用 k，其他单位对应 bytes、Mbytes、Kbytes、Gbytes</span><br><span class="line">-t: 输出的最终结果，显示物理内存与 swap 的总量</span><br><span class="line">-s：可以让系统每几秒输出一次，不间断输出；</span><br><span class="line">-c：与 -s 同时处理，让 free 列出几次</span><br></pre></td></tr></table></figure><p>系统会把空闲内存拿来做缓冲区之用，所以你系统没有那么繁忙的时候，也会显示内存被用的多的原因，这个是正常的，需要注意的是 swap，swap 最好不要被使用，而且使用超过 20% 以上, 表示物理内存不够.</p><h3 id="查询系统与核心相关信息"><a class="markdownIt-Anchor" href="#查询系统与核心相关信息"></a> 查询系统与核心相关信息</h3><p>uname指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uname [-asrmpi]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-a：所有系统相关的，都列出来</span><br><span class="line">-s：系统核心名称</span><br><span class="line">-r：核心的版本</span><br><span class="line">-m：本系统的硬件名称，例如 i686 或 x86_64</span><br><span class="line">-p：CPU 的类型，与 -m 类似</span><br><span class="line">-i：硬件的平台（ix86）</span><br></pre></td></tr></table></figure><p>其余指令<br><a href="https://zq99299.github.io/linux-tutorial/tutorial-basis/16/03.html#">介绍</a></p><ul><li>netstat 追踪网络有关的进程或数据</li><li>vmstat：侦测系统资源变化</li></ul><h3 id="特殊文件与进程"><a class="markdownIt-Anchor" href="#特殊文件与进程"></a> 特殊文件与进程</h3><p>具有SUID, SGID权限的指令执行状态</p><p>SUID权限仅对二进制查程序有效.</p><blockquote><p>SUID可以让执行者可以具有程序拥有者的权限, 在程序变成进程时</p></blockquote><p>fuser: 由文件找出正在使用该文件的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fuser [-umv] [-k [i] [signal]] file/dir</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-u：除了进程的 PID 之外，同时列出该进程的拥有者</span><br><span class="line">-m：后面接的文件名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效</span><br><span class="line">-v：可以列出每个文件与进程还有指令的完整相关性</span><br><span class="line">-k：找出使用该文件/目录的 PID，并试图以 SIGKILL 这个信号给予该 PID</span><br><span class="line">-i：必须与 -k 配合使用，在删除 PID 之前会先询问使用者</span><br><span class="line">-signal：例如 -1 -15 等，若不加的话，预设是 -9：SIGKILL</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>lsof 查询进程开启或使用的文件与装置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br><span class="line">COMMAND     PID         USER   FD      TYPE             DEVICE   SIZE/OFF                NODE NAME</span><br><span class="line">loginwind   135 chenyuanzhen  cwd       DIR                1,4        640                   2 /</span><br><span class="line">loginwind   135 chenyuanzhen  txt       REG                1,4    2672336 1152921500312203831 /System/Library/CoreServices/loginwindow.app/Contents/MacOS/login</span><br></pre></td></tr></table></figure><h3 id="selinux"><a class="markdownIt-Anchor" href="#selinux"></a> SELinux</h3><p>非常完备的核心模块</p><p>安全强化的Linux.</p><p>DAC自主式访问控制, 根据用户的权限决定进程的权限.</p><p>避免root被窃取, 导致所有资源丢失, 委任式访问控制 MAC避免DAC的缺点.</p><p><mark>针对特定的进程与特定的文件资源来进行权限的控制</mark>. 使得黑客哪怕黑进网站, 而网站被限定只能读取某个目录下的文件, 那黑客能访问的范围也只有该目录</p><h2 id="例行性工作调度"><a class="markdownIt-Anchor" href="#例行性工作调度"></a> 例行性工作调度</h2><p>能在指定时间执行任务(一次 或 多次)</p><h4 id="工作调度种类"><a class="markdownIt-Anchor" href="#工作调度种类"></a> 工作调度种类</h4><ul><li>例行性, 每隔一定的周期要来办的事项</li><li>突发性 做完一次就没有</li></ul><p>对应命令</p><h4 id="at"><a class="markdownIt-Anchor" href="#at"></a> at</h4><p>处理仅执行一次就结束调度</p><blockquote><p>需要开启atd服务</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新启动std这个服务</span></span><br><span class="line">systemctl restart atd;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启</span></span><br><span class="line">systemctl enable atd;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查阅atd状态</span></span><br><span class="line">systemctl status atd;</span><br></pre></td></tr></table></figure><p>执行步骤</p><ol><li>使用at指令产生所要执行的工作</li><li>将工作也文本方式写入 /var/spool/at/目录内 即可</li><li>atd服务,取用和执行</li></ol><h4 id="at使用限制"><a class="markdownIt-Anchor" href="#at使用限制"></a> at使用限制</h4><ol><li>/etc/at.allow 写在该文件中的使用者才可使用at</li><li>/etc/at.allow不在, 则看 /etc/at.deny/ 在deny文件内则不能使用</li><li>若两个文件不存在, 仅有root才可使用</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">at [-mldv] TIME</span><br><span class="line">-m: 当at完成工作后, 即时没输出讯息, 也使用email方式通知使用者</span><br><span class="line">-l: 列出该使用者的at调度</span><br><span class="line"></span><br><span class="line">at -c 工作号码</span><br><span class="line"></span><br><span class="line">TIME：时间格式，定义什么时候要进行 at 工作的时间，格式有：</span><br><span class="line">HH:MM如 4:00，在今日 4 点执行，若该时刻已过，则在明天的 4 点执行</span><br><span class="line">HH:MM YYYY-MM-DD如 4:00 2020-03-06 ，就在该时间点执行</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">at now + 5 minutes# 按回车后，输入要执行的指令</span><br><span class="line"><span class="meta">at&gt;</span><span class="bash"> /bin/mail -s <span class="string">"testing at job"</span> root &lt; /root/.bashrc</span></span><br><span class="line"><span class="meta">at&gt;</span><span class="bash"> &lt;EOT&gt;<span class="comment"># 需要使用 ctrl + d 结束输入</span></span></span><br></pre></td></tr></table></figure><h4 id="crontab"><a class="markdownIt-Anchor" href="#crontab"></a> crontab</h4><p>设置的工作将会循环的一直进行下去</p><blockquote><p>需要开启crond服务</p></blockquote><h4 id="linux系统常见例行化任务"><a class="markdownIt-Anchor" href="#linux系统常见例行化任务"></a> Linux系统常见例行化任务</h4><ul><li>进行登录文件的轮替<br>将旧的登录数据放置到其他地方</li><li>系统分析logwatch文件, 用于分析软件问题, 硬件错误等</li><li>创建locate数据库</li><li>man page查询数据库创建</li></ul><h2 id="linux系统服务"><a class="markdownIt-Anchor" href="#linux系统服务"></a> Linux系统服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">systemctl [option] {command}</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动单一服务</span></span><br><span class="line">systemctl start [unit]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭服务</span></span><br><span class="line">systemctl stop [unit]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启</span></span><br><span class="line">systemctl enable [unit]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 状态查看</span></span><br><span class="line">systemctl status [unit]</span><br><span class="line"></span><br><span class="line">Loaded状态</span><br><span class="line">- enabled 开机自启</span><br><span class="line">- disabled 非开机自启</span><br><span class="line"></span><br><span class="line">Active状态</span><br><span class="line">- active(running) 启动</span><br><span class="line">- active(exited) 仅执行一次就正常结束</span><br><span class="line"></span><br><span class="line">- static 这个服务不能自己启动, 仅能被其他服务调用</span><br><span class="line">- mask 该服务无论如何都不可启动 systemctl unmask 恢复</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出正在运行的服务</span></span><br><span class="line">systemctl list-units</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有的服务</span> </span><br><span class="line">systemctl list-units -all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据 /usr/lib/systemd/system/ 内文件列出所有安装的unit</span></span><br><span class="line">systemctl list-unit-files</span><br></pre></td></tr></table></figure><p>每一个unit, 都会有一个unit文件, 用于告知系统如何启动该unit.</p><p>存放目录</p><ul><li>/usr/lib/systemd/system:</li><li>/run/systemd/system:  系统执行过程中所产生的服务脚本，比上面目录优先运行</li><li>/etc/systemd/system  （优先级别最高）:</li></ul><h4 id="enable话语disable"><a class="markdownIt-Anchor" href="#enable话语disable"></a> enable话语disable</h4><p>是否开机自启是基于<mark>软连接和文件夹</mark>的方式实现</p><ol><li><p>开机会读取开机文件夹中的unit文件 /etc/systemd/system</p></li><li><p><mark>开机文件夹其实存放一个软连接</mark>, 真正存放unit文件的地方是在/usr/lib/systemd/system或/run/sy…,</p></li></ol><p>例子:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable sshd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除软连接</span></span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/sshd.service.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启开机自启</span></span><br><span class="line">systemctl enable sshd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建软连接</span></span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/sshd.service to /usr/lib/systemd/system/sshd.service.</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;mark&gt;Linux下无论什么都是一个文件&lt;/mark&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux安装前提需知&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#linux安装前提需知&quot;&gt;&lt;/a&gt; Linux安装前提需知&lt;/h2&gt;
&lt;h3 id=&quot;硬件设</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://chenyuanzhen.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>完美的代价</title>
    <link href="https://chenyuanzhen.github.io/2021/04/15/uploadMd/page-1/"/>
    <id>https://chenyuanzhen.github.io/2021/04/15/uploadMd/page-1/</id>
    <published>2021-04-15T10:40:01.000Z</published>
    <updated>2022-04-13T02:11:43.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="完美的代价"><a class="markdownIt-Anchor" href="#完美的代价"></a> <a href="http://oj.ecustacm.cn/problem.php?id=1418">完美的代价</a></h2><h3 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词:</h3><p>模拟 + 贪心</p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>回文串, 真的是令人着迷.</p><p>不得不说的是, 回文串有一个特点</p><p>第一个等于倒数第一个, 第二个等于倒数第二个…</p><p>但是!</p><p>对于<mark>奇数</mark>长度的回文串, 最中间的字符是不遵守这个法则.</p><p>这就导致, 很多涉及到回文串的题目, 都需要考虑一下, 奇数长度的字符串到底要不要特殊处理变成一般情况处理. 而对于该题, 是要的.</p><p>一般涉及到字符串更改的, 都会让我想到动态规划. 例如</p><ul><li>给出一个字符串, 求增添多少个字符可以变成回文.</li><li>给出两个字符串, 允许增删改, 求最少对一个字符串操作多少次, 能整个两个一样<br>等</li></ul><p>所以, 自然的, 一开始, 我也认为该题是动态规划, 而且还要求最少的交换次数. 对于上述问题中, 都不会进行模拟, 比如问题二中, 无论是增删改三个操作, 对应仅仅是索引的变化, 而不会对原字符串真的做出增删改. 而该题不行, 需要实实在在的进行模拟. 原因也很简单, 对于上述两个问题中, 在考虑问题时, 都无需考虑之前所进行的操作. 对该状态进行抉择时, 仅仅只是关注值的大小, 至于这个值怎么来的, 是不在意的. 而该问题, 是需要考虑之前状态做过的操作( 即交换过的字符 ), 当然, 这个也取决于<mark>状态的定义</mark>. 而该问题的状态定义怎么来的, 下文会说.</p><p>缩小子问题, 对第一件事可以肯定是缩小子问题.</p><ul><li>从内往外走, 即从字符串中间出发, 不断处理两边, 通过交换操作, 使其变成回文, 是一个方向. 但不可靠, 因为交换操作时, 会移动中间原本已经是回文的子串, 而移动后, 大概率使得中间子串<mark>丢失</mark>回文的属性, 所以不行</li><li>从两边往内走. 即先让开头和结尾构成回文, 再通过交换操作, 一步步往中间走变成回文. 这个思路的话, 交换操作并不会改变开头和结尾已经是回文的子串. 所以, 以这个思路.思考</li></ul><p>从两头出发, 如果发现两头字符不同, 则检查左右两边的字符, 谁的交换次数少, 则变成谁的样子.  我们先从简单的情况思考, 字符串长度为偶数.</p><blockquote><p>例如 mamazz</p><p>操作1: 将尾字母通过交换操作, 变成m. 交换次数,3次</p><p>操作2: 将首字母, 通过交换操作变成z. 交换次数, 4次.</p><p>那么我们先选择操作1</p><p>maazzm</p><p>接着是又有两个操作可以选择.</p><p>操作1: 将字母a通过交换操作, 变成z. 交换次数, 2次</p><p>操作2: 将字母z, 通过交换操作变成a. 交换次数, 2次.</p><p>emm.这里其实可以操作2或者1都没所谓, 按照动态规划的思路, 这里状态就明显了,</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi>A</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[字符串A][i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord mathdefault">A</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> : 表示子串<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, i], [j, length)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span> 已经是回文而且字符串为A所需要的最小交换次数</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi>A</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi>B</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>B</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">成</mi><mi>A</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">交</mi><mi mathvariant="normal">换</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi><mo separator="true">,</mo><mo stretchy="false">[</mo><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi>C</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>C</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">成</mi><mi>A</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">交</mi><mi mathvariant="normal">换</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[字符串A][i][j] = min([字符串B][i-1][j]+B变成A的交换次数, [字符串C][i][j+1]+ C变成A的交换次数)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord mathdefault">A</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">成</span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">交</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">串</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">成</span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">交</span><span class="mord cjk_fallback">换</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span><span class="mclose">)</span></span></span></span></p><p>但很明显, 很难表示字符串状态. 而且我们也需要字符串的状态, 因为构成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, i],[j, length)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>是回文的子串有很多种. 而且我们要根据<mark>先前</mark>字符串比较当前字符串才能得到交换的次数, 而且不同的先前字符串还不同. 哇~, 动态规划不行呀, 考虑的东西太多了, 状态还难表示.</p></blockquote><p>但题目还是要做的. <s>上网查询知</s>, 该题是<mark>贪心</mark>, 说实话, 难以想象. 不过贪心的作法, 很难证明, 跟该思路很相近. 也是从两头往中间靠, 同时也说明, 对于样例不管你选左边还是右边, 只要遵循一个准则, 那就是每一次选择, 都选择离当前字母最远的相同字母.</p><blockquote><p>例子 aabba<mark>a</mark>cc</p><p>如果将末尾的c用a换掉, 肯定是选择最靠近末尾的a, 即aabba<mark>a</mark>cc.</p></blockquote><p>而该准则, 在上述过程中, 得到交换次数的方法是一致的. 也就说, 按照此守则, 穷举例子 mamazz的选择方案, 你会发现, 不论每一次是选左边还是右边, 最终的到的结果都是一样的. 想要发现这个规律 除了穷举例子, 暂时还想不到什么办法.</p><h3 id="注意项"><a class="markdownIt-Anchor" href="#注意项"></a> 注意项</h3><ul><li>题目不保证一定可以构成回文<ul><li>偶数长度, 每一种字母个数都必须是偶数,</li><li>奇数长度, 有且仅有一种字母个数是奇数, 其余必须都是偶数</li></ul></li><li>对于奇数长度中, 有一个字符是必须要在中间的, 例如mdama. 得到的结果应该是2. 对于这种情况, 当发现右边找不到相同的, 说明处理到该字符, 直接将其移动到中间, 并记录步数. 而代码中, 采取是忽视, 即不移动到中间, 只加交换次数, 加完后, 就等于把这个中间字符删除了.</li></ul><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> O2;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll save[<span class="number">27</span>];</span><br><span class="line"><span class="keyword">char</span> nums[<span class="number">8100</span>];</span><br><span class="line">ll counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, (nums+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> end = n + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 检查是否可以构成回文</span></span><br><span class="line">    <span class="comment">// 统计字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; end; ++i) {</span><br><span class="line">        ++save[nums[i] - <span class="string">'a'</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 偶数长度</span></span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>){</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) {</span><br><span class="line">            <span class="keyword">if</span>(save[i] % <span class="number">2</span> != <span class="number">0</span>){</span><br><span class="line">                cout &lt;&lt; <span class="string">"Impossible"</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 奇数长度</span></span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) {</span><br><span class="line">            <span class="keyword">if</span>(save[i] % <span class="number">2</span> != <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(flag){</span><br><span class="line">                    cout &lt;&lt; <span class="string">"Impossible"</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>; start &lt; end; ++start) {</span><br><span class="line">        <span class="comment">// 找到与[start]相同的字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = end - <span class="number">1</span>; j &gt;= start; --j) {</span><br><span class="line">            <span class="comment">// 将中间字符转移到最中间 假装将奇数字符移到中间, 但不进行实际的转移</span></span><br><span class="line">            <span class="keyword">if</span>(start == j){</span><br><span class="line">                counter += n / <span class="number">2</span> - start + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[j] == nums[start]){</span><br><span class="line">                <span class="comment">// 将其转移到end - 1上 模拟</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; end - <span class="number">1</span>; ++k) {</span><br><span class="line">                    <span class="built_in">swap</span>(nums[k], nums[k + <span class="number">1</span>]);</span><br><span class="line">                    ++counter;</span><br><span class="line">                }</span><br><span class="line">                --end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; counter;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;完美的代价&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#完美的代价&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://oj.ecustacm.cn/problem.php?id=1418&quot;&gt;完美的代价&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;关键</summary>
      
    
    
    
    
    <category term="蓝桥杯" scheme="https://chenyuanzhen.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>密码脱离</title>
    <link href="https://chenyuanzhen.github.io/2021/04/14/uploadMd/page/"/>
    <id>https://chenyuanzhen.github.io/2021/04/14/uploadMd/page/</id>
    <published>2021-04-14T07:27:00.000Z</published>
    <updated>2022-04-13T02:11:43.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="密码脱落"><a class="markdownIt-Anchor" href="#密码脱落"></a> <a href="https://www.acwing.com/problem/content/1224/">密码脱落</a></h2><h3 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词:</h3><p>区间DP, 记忆化搜索</p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>该题可以转化为, 给出一个字符串, 问最少增加几个字符, 才能将其变成回文串;</p><p>对于样例分析</p><p>ABDCDCBABC</p><p>插入</p><p><mark>CB</mark>AB<mark>C</mark>DCDCBABC.</p><p>对于这种问题, 不管用什么思维思考: 暴力, 递归, 迭代, 还是分治, 或者动态规划. 很多时候我们都会想把问题的<mark>规模进行缩小</mark>., 想象一下, 如果限定字符串长度为2. 解决问题应该会很简单.</p><p>假设字符串长度为 length, 问题为最少增加几个字符, 才能将其变成回文串</p><ul><li><p>第一步 缩小问题</p><p>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, length - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的子串… 先求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>子串问题,</p></li><li><p>第二步 回推<br>求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的子问题答案, 假设我们已经知道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, k], k \in[0,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>的问题答案, 如何求?<br>其实<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>表示前面已经是回文串了, 那么对于新进来了字符<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>. 有多少种处理办法?</p><p>只有一种方法, 那就是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>之前添加字符<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p><blockquote><p>例子: 字符串 : AABA</p><ol><li>A</li><li>AAA</li><li><mark>BA</mark>AAB</li><li><mark>ABA</mark>ABA</li></ol></blockquote></li></ul><p>但很明显不可靠, 因为要求解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的结果, 不能或者不会依赖<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的结果.<br>例如 ABAA. 最少一步构成回文. A<mark>A</mark>BAA, 或者ABA<mark>B</mark>A.</p><p>缩小问题规模的方式还有一种, 先将解决所有长度为1的子串的问题, 再基于此求所有长度为2的子串的问题, …直到解决所有长度为length问题( 即原字符串 )</p><ul><li><p>初始状态<br>当长度为1的子串, 都是回文子串, 问题的解都是0.</p></li><li><p>递推 根据长度为k-1的子串, 推出长度为k的子串<br>假设已知所有长度为k的子串的答案, 求所有长度为k+1的长度.<br>如何表示一个子串呢? 用数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> (定义在下面). 那么涉及到该问题的状态有. 子串A<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i + 1, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 与 子串B<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i, j - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><ul><li>子串A选择将左边的字符加入其中</li><li>子串B选择将右边的字符加入其中</li></ul><p>从上述选择操作最小的 + 1. 当然如果子串两头本来就相等, 就等于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i+1]dp[j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p><blockquote><p>ABAA</p><ol><li><p>例如求 A<mark>BA</mark>A 下标从1开始</p><p>是基于 原字符串B + A, 还是原字符串A + B. 当然对应的答案.</p><p>​AABAA.         或者        ABABA</p><p>从中选最小, 不过这里两个都一致, 选哪个都无所谓. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[1][2] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p></li></ol></blockquote></li></ul><h4 id="方程定义"><a class="markdownIt-Anchor" href="#方程定义"></a> 方程定义</h4><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>: 表示字符串[i, j]变成回文字符串所插入所需的最小字符</p><h4 id="转移"><a class="markdownIt-Anchor" href="#转移"></a> 转移</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择左边加, 还是右边加</span></span><br><span class="line"><span class="keyword">if</span>(input[i] != input[j])</span><br><span class="line">    dp[i][j] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 加了之后本身就是回文串.就本身就是回文 在开头和结尾 加两个相同的字符, 则无需修改</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line">ll dp[MAXSIZE][MAXSIZE];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line"></span><br><span class="line">    input.<span class="built_in">insert</span>(input.<span class="built_in">begin</span>(), <span class="string">'\0'</span>);</span><br><span class="line"><span class="comment">// 长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; input.<span class="built_in">size</span>() - <span class="number">1</span>; ++len) {</span><br><span class="line">      <span class="comment">// 子串开头   长度 + 子串开头 = 子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; input.<span class="built_in">size</span>() - len; ++i) {</span><br><span class="line">            <span class="keyword">int</span> j = len + i;</span><br><span class="line">            <span class="keyword">if</span>(input[i] != input[j])</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][input.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;密码脱落&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#密码脱落&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://www.acwing.com/problem/content/1224/&quot;&gt;密码脱落&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;关键</summary>
      
    
    
    
    
    <category term="蓝桥杯" scheme="https://chenyuanzhen.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>子串分值</title>
    <link href="https://chenyuanzhen.github.io/2021/04/11/uploadMd/index/"/>
    <id>https://chenyuanzhen.github.io/2021/04/11/uploadMd/index/</id>
    <published>2021-04-11T06:45:57.000Z</published>
    <updated>2022-04-13T02:11:43.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子串分值"><a class="markdownIt-Anchor" href="#子串分值"></a> <a href="https://www.acwing.com/problem/content/description/2871/">子串分值</a></h2><h3 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h3><p>排列组合, 连续子串</p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>题目样例大小是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1 \leq n \leq 100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>. 对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>算法而言, <mark>不可能</mark>通过所有的评测用例.但初步观察, 是很容易得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>算法</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20210411145826835.png?raw=true" alt="image-20210411145826835"></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>枚举出所有的子串, 然后可基于上一个子串的唯一字符数, 可<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>内完成子串中唯一字符数的统计.</p><p>此时, 如果要追求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>算法, 步骤中是不可能包含列出子串这一过程, 应该是寻找一种方法, 直接根据字符当前的位置, 直接得出该字符对答案的贡献.</p><p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20210411150259473.png?raw=true" alt="image-20210411150259473"></p><p>借用<a href="https://www.bilibili.com/video/BV1az4y1178E?from=search&amp;seid=17856993350375137450">蓝桥杯直播公开网课</a>中的图, 可以看出</p><table><thead><tr><th>位置</th><th>贡献</th></tr></thead><tbody><tr><td>(1, A)</td><td>2</td></tr><tr><td>(2, B)</td><td>4</td></tr><tr><td>(3, A)</td><td>6</td></tr></tbody></table><p>等</p><h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3><p>先考虑这样一个问题, 假设一个字符串XXAXX.  问包含子串A有多少种?</p><p>首先子串一定是<mark>连续</mark>的, 而对于连续的, 只要<mark>确定其开头和结尾</mark>就可<mark>唯一</mark>确定一个子串. 开头可选择 XXA中任意一个字符, 而结尾也可以从AXX中任意选择一个字符. 所以, 包含A的子串有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>∗</mo><mn>3</mn><mo>=</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">3 * 3 = 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span>种. (排列和组合)</p><p>回到题目中, 为了保证子串中唯一出现一个字符, 我们必须在<mark>开头字符和结尾字符</mark>中做出适当的修改. 例如ABABC中的, 第二个A. 只含有一个A的子串, 开头只能在 BA(自身)做出选择, 而对于结尾在 A(自身)BC中做出选择. 所以答案是 2 * 3 = 6.</p><p>到此, 我们已经有一种办法, 可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>计算出. 一个位置上的字符对答案的贡献.</p><p>贡献为:</p><p><strong>下标从0开始</strong></p><p>( 当前X的位置 - 上一个X的位置) * (下一个X的位置 - 当前X的位置)</p><blockquote><p>上一个X的位置: 默认为-1  (可以带入具体事例, 尝试一下)</p><p>下一个X的位置: 默认为 字符串长度</p></blockquote><h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3><ol><li>统计每一个字符出现的位置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>算法每一个位置字符对答案的贡献 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ol><p>总时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">posChar</span>(<span class="number">26</span>);</span><br><span class="line">    string input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    <span class="comment">// 初始化, 每一个都先扔-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item: posChar)</span><br><span class="line">        item.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 扔位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>() ; ++i){</span><br><span class="line">        posChar[input[i] - <span class="string">'a'</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 扔末尾位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item: posChar)</span><br><span class="line">        item.<span class="built_in">push_back</span>(input.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 统计答案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item: posChar){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (ll)item.<span class="built_in">size</span>() - <span class="number">1</span>; ++i){</span><br><span class="line">            ans += (item[i] - item[i<span class="number">-1</span>]) * (item[i + <span class="number">1</span>] - item[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子串分值&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#子串分值&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://www.acwing.com/problem/content/description/2871/&quot;&gt;子串分值&lt;/a&gt;&lt;/h2</summary>
      
    
    
    
    
    <category term="蓝桥杯" scheme="https://chenyuanzhen.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>正则问题</title>
    <link href="https://chenyuanzhen.github.io/2021/04/08/uploadMd/%E6%AD%A3%E5%88%99%E9%97%AE%E9%A2%98/"/>
    <id>https://chenyuanzhen.github.io/2021/04/08/uploadMd/%E6%AD%A3%E5%88%99%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-08T02:18:51.000Z</published>
    <updated>2022-04-14T03:18:09.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则问题"><a class="markdownIt-Anchor" href="#正则问题"></a> <a href="https://www.acwing.com/problem/content/1227/">正则问题</a></h2><h3 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h3><p>栈, 递归, 正则表达式</p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><ul><li><p>每一个括号都代表一个x的长度, 而 | 则表示, 要从左边和右边中选择1个较长的.  接着,</p></li><li><p>括号决定了处理顺序, 如果一个括号中<mark>包含</mark>另一个括号, 那么需要<mark>先处理完里面的括号</mark>, 才能去处理外面的括号. 而每一个括号的<mark>处理方式是一致</mark>的.</p><p>至此, 题目分析已经可以用递归去做了. 但看到这道题时, 让我想起用栈做过的一道经典题, 中缀表达式计算. 一个栈存符号, 一个栈存数字. 该题有熟悉的感觉. 所以打算用栈解决该问题.</p></li></ul><h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3><p>先说一下递归的步骤吧</p><p>需要一个递归函数, 根据当前的正则表达式索引, 返回一个该括号能容纳x的个数?</p><ol><li><p>见到左括号, 说明包含一个括号, 需要优先处理该括号( 递归处理 )</p></li><li><p>见到 | , 说明需要做出选择, 假设目前已经当前括号内知道左边的最大x个数, 要求右边的最大x个数, 进行递归处理.</p></li><li><p>见到 x, 当前拥有x个数++.</p></li><li><p>见到 ) . 需要返回当前的x个数.<br>因为 ) 表示一个括号的结束, 需要得到一个结果</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using namespace 和头文件略去</span></span><br><span class="line"><span class="keyword">int</span> indexes = <span class="number">-1</span>;</span><br><span class="line">string input;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">( )</span></span>{</span><br><span class="line">    ++indexes;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(indexes &lt; input.<span class="built_in">size</span>() &amp;&amp; (input[indexes] == <span class="string">'x'</span> || input[indexes] == <span class="string">'('</span>)){</span><br><span class="line">      <span class="comment">// 见到 x, 当前拥有x个数++. </span></span><br><span class="line">        <span class="keyword">if</span>(input[indexes] == <span class="string">'x'</span>) {</span><br><span class="line">            ++counter;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">          <span class="comment">// 见到左括号, 说明包含一个括号, 需要优先处理该括号( 递归处理 )</span></span><br><span class="line">            counter += <span class="built_in">dfs</span>();</span><br><span class="line">        }</span><br><span class="line">        ++indexes;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 防止抹去符号</span></span><br><span class="line">    <span class="keyword">char</span> tmp = input[indexes];</span><br><span class="line">  <span class="comment">// 见到 ) . 需要返回当前的x个数. </span></span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="string">')'</span>) {</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 见到 | , 说明需要做出选择</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tmp == <span class="string">'|'</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(counter, <span class="built_in">dfs</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">getline</span>(cin , input);</span><br><span class="line">  <span class="comment">// 在最外围添加(), 保证整个式子是一个括号()</span></span><br><span class="line">    input.<span class="built_in">insert</span>(input.<span class="built_in">begin</span>(), <span class="string">'('</span>);</span><br><span class="line">    input.<span class="built_in">insert</span>(input.<span class="built_in">end</span>(), <span class="string">')'</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>();</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非递归, 迭代作法</p><p>((xx|xxx)x|(x|xx))xx</p><p>将上述式子转化为</p><p>(((2|3)1|(1|2))2)</p><p>步骤执行:</p><ol><li>(((3)1|(1|2))2)</li><li>((4|(1|2))2)</li><li>((4|(2))2)</li><li>(((4)2))</li><li>(6)</li></ol><p>其中的数字为, B所存放的元素.</p><p>可见非迭代也是优先处理括号里的括号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把递归的solve换成该solve, 再补上头文件stack即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>{</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input);</span><br><span class="line">    input.<span class="built_in">insert</span>(input.<span class="built_in">begin</span>(), <span class="string">'('</span>);</span><br><span class="line">    input.<span class="built_in">insert</span>(input.<span class="built_in">end</span>(), <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; stackA;</span><br><span class="line">  <span class="comment">// stackB表示的 当前括号 的最大x长度</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stackB;</span><br><span class="line">  <span class="comment">// 防止栈B空了 +0 对结果不会有影响</span></span><br><span class="line">    stackB.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i) {</span><br><span class="line"><span class="comment">// 符号入栈</span></span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">'('</span> || input[i] == <span class="string">')'</span> || input[i] == <span class="string">'|'</span>)</span><br><span class="line">            stackA.<span class="built_in">push</span>(input[i]);</span><br><span class="line"><span class="comment">// 见到符号) 表示需要清算了</span></span><br><span class="line">        <span class="keyword">if</span> (!stackA.<span class="built_in">empty</span>() &amp;&amp; stackA.<span class="built_in">top</span>() == <span class="string">')'</span>) {</span><br><span class="line">            stackA.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span> (stackA.<span class="built_in">top</span>() != <span class="string">'('</span>) {</span><br><span class="line"><span class="comment">// 从后往前处理选择|</span></span><br><span class="line">                <span class="keyword">if</span> (stackA.<span class="built_in">top</span>() == <span class="string">'|'</span>) {</span><br><span class="line">                    <span class="keyword">int</span> tmp1 = stackB.<span class="built_in">top</span>();</span><br><span class="line">                    stackB.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">int</span> tmp2 = stackB.<span class="built_in">top</span>();</span><br><span class="line">                    stackB.<span class="built_in">pop</span>();</span><br><span class="line">                    stackB.<span class="built_in">push</span>(<span class="built_in">max</span>(tmp2, tmp1));</span><br><span class="line">                }</span><br><span class="line">                stackA.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 处理完|后, 直接和前面汇合</span></span><br><span class="line">            <span class="keyword">int</span> tmp1 = stackB.<span class="built_in">top</span>();</span><br><span class="line">            stackB.<span class="built_in">pop</span>();</span><br><span class="line">            stackB.<span class="built_in">top</span>() += tmp1;</span><br><span class="line">            stackA.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不管是(还是|, 说明需要重新计算一个括号</span></span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">'('</span> || input[i] == <span class="string">'|'</span>) {</span><br><span class="line">            stackB.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (input[i] == <span class="string">'x'</span>) {</span><br><span class="line">            ++stackB.<span class="built_in">top</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; stackB.<span class="built_in">top</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;正则问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#正则问题&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://www.acwing.com/problem/content/1227/&quot;&gt;正则问题&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;关键</summary>
      
    
    
    
    
    <category term="蓝桥杯" scheme="https://chenyuanzhen.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>波动数列</title>
    <link href="https://chenyuanzhen.github.io/2021/04/02/uploadMd/post/"/>
    <id>https://chenyuanzhen.github.io/2021/04/02/uploadMd/post/</id>
    <published>2021-04-02T04:07:29.000Z</published>
    <updated>2022-04-13T02:11:43.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="蓝桥杯2014初赛波动数列"><a class="markdownIt-Anchor" href="#蓝桥杯2014初赛波动数列"></a> <a href="https://www.acwing.com/problem/content/description/1216/">[蓝桥杯2014初赛]波动数列</a></h3><h3 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字:</h3><p>动态规划(01背包问题) + 数学推理</p><h3 id="题目分析"><a class="markdownIt-Anchor" href="#题目分析"></a> 题目分析</h3><p>数列题, 当首项确定下来之后, 之后的所有项都可以被表示出来</p><p>假定首项为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>, 要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">+a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord mathdefault">a</span></span></span></span>, 要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">b</span></span></span></span>. 将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">+a,-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">+</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord mathdefault">b</span></span></span></span>统称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>.</p><p>那么波动数列就可以表示为</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>x</mi><mo>+</mo><mi>k</mi><mo separator="true">,</mo><mi>x</mi><mo>+</mo><mn>2</mn><mi>k</mi><mo separator="true">,</mo><mi>x</mi><mo>+</mo><mn>3</mn><mi>k</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">x,x+k,x+2k,x+3k...,x+(n-1)k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></p><p>整理一手</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3...</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>k</mi><mo>=</mo><mi>s</mi><mspace linebreak="newline"></mspace><mi>n</mi><mi>x</mi><mo>+</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mi>k</mi><mo>=</mo><mi>s</mi><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><mfrac><mrow><mi>s</mi><mo>−</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><mi>n</mi></mfrac><mspace linebreak="newline"></mspace><mi>x</mi><mo>=</mo><mfrac><mrow><mi>s</mi><mo>−</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>3</mn><mi>k</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">nx + (1 + 2 + 3...n-1)k = s\\nx + \frac{n(n-1)}{2}k=s\\ x = \frac{s-n(n-1)k/2}{n}\\ x = \frac{s-(k+2k+3k...+(n-1)k)}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>至此, 其实对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的约束条件只有一个, 那就是为整数</p><p>也就是说只要保证</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>−</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>3</mn><mi>k</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s-(k+2k+3k...+(n-1)k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></p><p>可以被 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>整除即可</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>−</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>3</mn><mi>k</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo>=</mo><mo>=</mo><mn>0</mn><mspace linebreak="newline"></mspace><mo stretchy="false">(</mo><mi>s</mi><mo>−</mo><mi>k</mi><mo>−</mo><mn>2</mn><mi>k</mi><mo>−</mo><mn>3</mn><mi>k</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>k</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(s-(k+2k+3k...+(n-1)k))\%n == 0\\ (s - k - 2k - 3k... - (n-1)k) \% n == 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>题目转化为上述式子中, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">种</mi><mo separator="true">,</mo><mo>+</mo><mi>a</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">k的取值有两种,+a或者-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">种</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>有多少种可能</p><p>那么接下来就是动态规划的时间了</p><p>对于每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>有两种选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord mathdefault">b</span></span></span></span></p><h3 id="状态方程"><a class="markdownIt-Anchor" href="#状态方程"></a> 状态方程</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>:</mo><mi mathvariant="normal">第</mi><mi>i</mi><mi mathvariant="normal">项</mi><mo stretchy="false">(</mo><mi mathvariant="normal">从</mi><mi mathvariant="normal">第</mi><mn>0</mn><mi mathvariant="normal">项</mi><mi mathvariant="normal">开</mi><mi mathvariant="normal">始</mi><mi mathvariant="normal">即</mi><mi>s</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">余</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">为</mi><mi>j</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">案</mi><mi mathvariant="normal">数</mi></mrow><annotation encoding="application/x-tex">dp[i][j]: 第i项(从第0项开始即s),余数为j的方案数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">第</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">项</span><span class="mopen">(</span><span class="mord cjk_fallback">从</span><span class="mord cjk_fallback">第</span><span class="mord">0</span><span class="mord cjk_fallback">项</span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">始</span><span class="mord cjk_fallback">即</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">案</span><span class="mord cjk_fallback">数</span></span></span></span></p><p>如何想出来的呢?</p><p>现在的问题是, 求和为s, 第n项, 余数为0的方案数. 那么描述<mark>唯一</mark>的一个状态的变量可能有</p><ul><li>和</li><li>项</li><li>余数</li></ul><p>但是此时, 和已经是固定的, 不会因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">+a,-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">+</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord mathdefault">b</span></span></span></span>而影响到和. 况且和的范围太大了, 所以和, 对描述一个状态而言, 没用. 那么就只剩项数和余数了.</p><h3 id="动态转移方程"><a class="markdownIt-Anchor" href="#动态转移方程"></a> 动态转移方程</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mi>i</mi><mo>∗</mo><mi>a</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mi>i</mi><mo>∗</mo><mi>b</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i-1]dp[(j+ i*a)\%n] + dp[i - 1][((j + i * b)\%n + n) \% n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span></p><p>可以这么理解, 加上第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>项后的余数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>, 因为当前项只有可能选择<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi mathvariant="normal">或</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">+a,或-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">+</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">或</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>, 但</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>−</mo><mi>k</mi><mo>−</mo><mn>2</mn><mi>k</mi><mo>−</mo><mn>3</mn><mi>k</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>−</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>k</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(s - k - 2k - 3k... - (n-1)k) \% n == 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p>数学公式中的k负号.</p><p>得到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>项后的余数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>, 可能有第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>项, 余数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>+</mo><mi>i</mi><mo>∗</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">j + i * a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>, 那么当前项, 选择 + a</p><p>则余数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>+</mo><mi>i</mi><mo>∗</mo><mi>a</mi><mo>−</mo><mi>i</mi><mo>∗</mo><mi>a</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">j + i * a - i * a = j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>. 了. 另一个同理</p><p>当然还要加上取余万能式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">%</mi><mi>n</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((x\%n + n) \% n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">%</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>. 有效处理负数和正数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">ll n, s, a, b;</span><br><span class="line">ll mod = <span class="number">100000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="comment">// 初始化条件别忘了, 那就是一开始和为s的状态.</span></span><br><span class="line">   dp[<span class="number">0</span>][(s%n + n) % n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][((j - i * a)%n + n) % n];</span><br><span class="line">            dp[i][j] %= mod;</span><br><span class="line">            dp[i][j] += dp[i - <span class="number">1</span>][( (j + i * b)%n + n) % n];</span><br><span class="line">            dp[i][j] %= mod;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 由于是从第0项开始推, 而题目是从第1项开始推, 所以调整一手</span></span><br><span class="line">    cout &lt;&lt; dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;蓝桥杯2014初赛波动数列&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#蓝桥杯2014初赛波动数列&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://www.acwing.com/problem/content/description/1</summary>
      
    
    
    
    
    <category term="蓝桥杯" scheme="https://chenyuanzhen.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>判断连通性</title>
    <link href="https://chenyuanzhen.github.io/2021/04/01/uploadMd/%E5%88%A4%E6%96%AD%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
    <id>https://chenyuanzhen.github.io/2021/04/01/uploadMd/%E5%88%A4%E6%96%AD%E8%BF%9E%E9%80%9A%E6%80%A7/</id>
    <published>2021-03-31T16:00:00.000Z</published>
    <updated>2022-04-13T02:11:43.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断连通性"><a class="markdownIt-Anchor" href="#判断连通性"></a> 判断连通性</h2><p>介绍三种办法</p><ul><li><p>深度优先dfs<br>伪代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Node node;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span></span>{</span><br><span class="line">  标记node已经访问过;</span><br><span class="line">  <span class="keyword">for</span> child in node的孩子:</span><br><span class="line">  <span class="keyword">if</span> child没有被访问过</span><br><span class="line">   <span class="built_in">dfs</span>(child);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">主函数:</span><br><span class="line"><span class="built_in">dfs</span>(任意一个结点);</span><br><span class="line"><span class="keyword">for</span> node in 图中</span><br><span class="line"><span class="keyword">if</span> node没有被访问过</span><br><span class="line">          得出图不连通</span><br><span class="line">    得到图连通</span><br></pre></td></tr></table></figure></li><li><p>广度优先bfs</p><p>选择任意一个节点, 使用队列, 广度搜索.<br>搜索完之后, 如果发现有结点没有被访问过, 则不连通. 否则, 连通</p></li><li><p>并查集</p><p>father数组. 如果最后发现有多个father, 那就不连通, 否则, 为连通</p></li></ul><h3 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h3><p><a href="http://oj.ecustacm.cn/problem.php?id=1286">[蓝桥杯2016初赛]剪邮票</a></p><p>这道题巧妙的是, 使用C++中的全排列函数, <mark>枚举12张邮票选择任意5张</mark>所有的情况. 然后对每一个情况, 使用上述任意一个算法判断是否连通. 代码中, 我使用的dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="comment">// 是否访问过</span></span><br><span class="line"><span class="keyword">bool</span> isVisit[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">// true为选择的邮票</span></span><br><span class="line"><span class="keyword">bool</span> stamp[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 上下左右</span></span><br><span class="line"><span class="keyword">int</span> row[]={<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line"><span class="keyword">int</span> col[]={<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>};</span><br><span class="line"><span class="comment">// 检查连通邮票的个数</span></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 检查越界</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBounds</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(y &lt; <span class="number">0</span> || y &gt;= <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs检查图是否连通</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    isVisit[x][y] = <span class="literal">true</span>;</span><br><span class="line">    ++counter;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) {</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isBounds</span>(x+row[i], y+col[i]) &amp;&amp; !isVisit[x + row[i]][y + col[i]] &amp;&amp; stamp[x + row[i]][y + col[i]]){</span><br><span class="line">            <span class="built_in">dfs</span>(x+row[i], y+col[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 12位数字 5个1的全排列枚举所有情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 利用全排列 </span></span><br><span class="line">    <span class="keyword">int</span> status[] = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>};</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(isVisit, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(isVisit));</span><br><span class="line">        <span class="built_in">memset</span>(stamp, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(stamp));</span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="comment">// 登记选择的邮票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) {</span><br><span class="line">            cout &lt;&lt; status[i];</span><br><span class="line">            <span class="keyword">if</span>(status[i] == <span class="number">1</span>){</span><br><span class="line">                stamp[i / <span class="number">4</span>][i % <span class="number">4</span>] = <span class="literal">true</span>;</span><br><span class="line">                x = i / <span class="number">4</span>;</span><br><span class="line">                y = i % <span class="number">4</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出选择5张邮票的样子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) {</span><br><span class="line">                cout &lt;&lt; stamp[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            }</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line"><span class="comment">// 判断连通性</span></span><br><span class="line">        <span class="built_in">dfs</span>(x, y);</span><br><span class="line">      <span class="comment">// 如果连通的邮票超过5张</span></span><br><span class="line">        <span class="keyword">if</span>(counter == <span class="number">5</span>) {</span><br><span class="line">            ++ans;</span><br><span class="line">            cout &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 全排列</span></span><br><span class="line">    }<span class="keyword">while</span> (<span class="built_in">next_permutation</span>(status, status+<span class="number">12</span>));</span><br><span class="line">  <span class="comment">// 输出答案</span></span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>答案: 116</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;判断连通性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#判断连通性&quot;&gt;&lt;/a&gt; 判断连通性&lt;/h2&gt;
&lt;p&gt;介绍三种办法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;深度优先dfs&lt;br&gt;
伪代码&lt;/p&gt;
&lt;figure class=&quot;high</summary>
      
    
    
    
    
    <category term="算法" scheme="https://chenyuanzhen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
