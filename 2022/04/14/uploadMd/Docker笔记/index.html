<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Docker | 笔记仓库</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">笔记仓库</a><span class="subtitle">知道为什么比知道怎么做更重要</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>Docker</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2022-04-14</div><div class="post-tags"><a class="post-tag-none-link" href="/tags/Docker/" rel="tag">Docker</a></div></div></div><article><div class="container post"><h2 id="docker"><a class="markdownIt-Anchor" href="#docker"></a> Docker</h2>
<p>使用您提供的应用程序或服务的本地容器在标准化环境中工作.</p>
<blockquote>
<p>我的理解是为每一个应用程序或服务单独配置环境</p>
</blockquote>
<h2 id="基于技术"><a class="markdownIt-Anchor" href="#基于技术"></a> 基于技术</h2>
<p>基于 <strong>Linux 内核</strong> 提供的 CGroup 功能和 namespace 来实现的</p>
<h2 id="container"><a class="markdownIt-Anchor" href="#container"></a> Container</h2>
<p>包括以下的东西</p>
<ul>
<li>
<p>Cgroup</p>
<p>限制container所用的资源</p>
</li>
<li>
<p>namespace</p>
<p>限制container所能看到的文件, 如PID, 文件都是新的, container无法看见本机的进程PID</p>
<p>目的是隔离内核资源</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32775594/why-does-docker-need-a-union-file-system">Union File System</a></p>
<p>可以把多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的。UnionFS允许只读和可读写目录并存. 具有写时复制功能</p>
<p>docker采用的是 AUFS, 即Another UFS.  AUFS 里有分层的概念, 对只读权限的分支修改, 仅会记录其中不同的部分.</p>
</li>
</ul>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20220330095852699.png?raw=true" alt="image-20220330095852699" style="zoom:50%;">
<blockquote>
<p>batch目录下存储一个个cgroup</p>
<ul>
<li>bitcoins是一个cgroup</li>
<li>hadoop也是一个cgroup</li>
</ul>
<p>cgroup = 进程组</p>
<p>进程组内只能看到组内的情况, 有命名空间的限制</p>
</blockquote>
<h4 id="cgroup"><a class="markdownIt-Anchor" href="#cgroup"></a> cgroup</h4>
<p>cgroup 是绑定到一组进程的集合, 通过 cgroup 文件系统定义的限制或参数</p>
<h4 id="cgroups"><a class="markdownIt-Anchor" href="#cgroups"></a> cgroups</h4>
<p>cgroups 全称<code>control groups</code>, Linux内核功能，允许将<mark>进程资源</mark>组织成分层组，然后可以限制和监视各种资源的使用。</p>
<h4 id="子系统subsystem"><a class="markdownIt-Anchor" href="#子系统subsystem"></a> 子系统subsystem</h4>
<p>子系统<code>subsystem</code> 一个内核组件</p>
<blockquote>
<p><code>subsystem</code>又被成为资源控制器, 简称控制器</p>
</blockquote>
<p>为每种可控制的资源定义一个子系统</p>
<p>已有的子系统</p>
<ul>
<li>cpu子系统 限制进程CPU使用率</li>
<li>memory子系统 限制进程memory使用量</li>
<li>net_cls子系统 标记cgroups中进程的网络数据包, 用tc模块对数据包控制</li>
<li>freezer子系统 挂起或恢复cgroups中的进程</li>
</ul>
<p>cgroup需要与子系统支持才能获得资源, (如CPU或内存等),</p>
<blockquote>
<p>由子系统实现对cgroup中进程资源的限制和跟踪</p>
</blockquote>
<h4 id="层级-hierarchy"><a class="markdownIt-Anchor" href="#层级-hierarchy"></a> 层级 hierarchy</h4>
<p>每一个子系统都可被分为多个层级, 层级的节点表示占用该子系统的资源配额</p>
<p>层次结构中可以定义所使用的资源限制</p>
<p>可以将子系统的资源分成多个层次. 子节点的资源配额, 限制, 监控 继承父节点</p>
<p>一个进程可以从CPU资源层级中挑选一个节点, 获得CPU配额和监控, 同时也可以从memory资源层级中挑选一个, 获得内存配额.</p>
<h4 id="cgroups文件系统"><a class="markdownIt-Anchor" href="#cgroups文件系统"></a> cgroups文件系统</h4>
<p>Linux通过文件的方式，将cgroups的功能和配置暴露给用户，这得益于Linux的虚拟文件系统（VFS）。VFS将具体文件系统的细节隐藏起来，给用户态提供一个统一的文件系统API接口，cgroups和VFS之间的链接部分，称之为cgroups文件系统。</p>
<p>比如挂在 cpu、cpuset、memory 三个子系统到 /cgroups/cpu_mem 目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t cgroup -o cpu,cpuset,memory cpu_mem /cgroups/cpu_mem</span><br></pre></td></tr></table></figure>
<h2 id="与虚拟机的区别"><a class="markdownIt-Anchor" href="#与虚拟机的区别"></a> 与虚拟机的区别</h2>
<ul>
<li>
<p>Docker中的容器, 是共享一套操作系统资源的.</p>
</li>
<li>
<p>虚拟机是虚拟一套硬件, 并在其之上运行一个完整的操作系统.</p>
</li>
</ul>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<h3 id="镜像image"><a class="markdownIt-Anchor" href="#镜像image"></a> 镜像Image</h3>
<p>一个特殊的文件系统. <strong>供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）</strong>. <mark>不包括任何动态数据</mark></p>
<blockquote>
<p>分层存储架构, 由多层文件系统联合</p>
<p><strong>每一层构建后不会有改变</strong></p>
</blockquote>
<h3 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h3>
<p>镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p>
<blockquote>
<p>理解为镜像是类, 而容器是实例</p>
</blockquote>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间</p>
<h3 id="与虚拟机的差别"><a class="markdownIt-Anchor" href="#与虚拟机的差别"></a> 与虚拟机的差别</h3>
<p>虚拟机占用巨量内存, 完全的模拟一台计算机, 从硬件到软件.</p>
<p>而Docker是共享操作系统内核, 有更少的抽象层</p>
<p><mark>docker容器, 在使用层面可视为一个独立的linux (或其他)的系统, (虽然实现不是)</mark>, 有自己的防火墙等</p>
<h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h3>
<p>Docker守护进程: 管理所有的docker容器, 可直接与主操作系统进行通信</p>
<p>docker容器: 由docker镜像创建的一个实例</p>
<p>docker常用于隔离不同的应用, 能充分的发挥硬件的性能.</p>
<h4 id="dockerhub"><a class="markdownIt-Anchor" href="#dockerhub"></a> dockerHub</h4>
<p>与github类似, 用户可以将镜像放置到dockerHub, 供大家下载. 可以使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从dockerHub, 默认是官网,下载镜像名</span></span><br><span class="line">docker pull [OPTION] imageName</span><br></pre></td></tr></table></figure>
<h2 id="镜像常用命令"><a class="markdownIt-Anchor" href="#镜像常用命令"></a> 镜像常用命令</h2>
<h3 id="信息查看"><a class="markdownIt-Anchor" href="#信息查看"></a> 信息查看</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 详细信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一个命令的详细说明</span></span><br><span class="line">docker 命令 --help</span><br></pre></td></tr></table></figure>
<h2 id="容器命令"><a class="markdownIt-Anchor" href="#容器命令"></a> 容器命令</h2>
<h4 id="启动命令"><a class="markdownIt-Anchor" href="#启动命令"></a> 启动命令</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run imageName[:tags (版本, 默认为latest)]</span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 可后台运行 但需要注意 image 要有前台进程执行, 一定要有对外服务, 不然会自动杀死</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -it 使用交互方式运行,进入容器并查看内容</span></span><br></pre></td></tr></table></figure>
<h4 id="查看运行中的容器"><a class="markdownIt-Anchor" href="#查看运行中的容器"></a> 查看运行中的容器</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span><span class="bash"> -a 历史运行的容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -n=? 最近创建的容器</span></span><br></pre></td></tr></table></figure>
<h4 id="进入当前运行的容器"><a class="markdownIt-Anchor" href="#进入当前运行的容器"></a> 进入当前运行的容器</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方式一 /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器开启一个新的终端, 并执行命令</span></span><br><span class="line">docker exec -it 容器ID 执行命令的path</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器正在运行的终端, 不会启动新的进程</span></span><br><span class="line">docker attach 容器id</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很多容器连bash都没有, 可以用</p>
<p>docker exec -ti containerId ls -al</p>
<p>执行命令</p>
</blockquote>
<h4 id="退出容器"><a class="markdownIt-Anchor" href="#退出容器"></a> 退出容器</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit # 直接推出容器, 并终止容器运行</span><br><span class="line">ctrl + P + Q #仅退出, 不终止</span><br></pre></td></tr></table></figure>
<h4 id="删除容器"><a class="markdownIt-Anchor" href="#删除容器"></a> 删除容器</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除指定容器, 容器正在运行不能删除, -f 可无视</span></span><br><span class="line">docker rm 容器id</span><br></pre></td></tr></table></figure>
<h4 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h4>
<p>查看容器到底做了什么</p>
<p>可用 --help 查看用法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br></pre></td></tr></table></figure>
<h4 id="容器进程信息"><a class="markdownIt-Anchor" href="#容器进程信息"></a> 容器进程信息</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top  id</span><br></pre></td></tr></table></figure>
<h4 id="元数据"><a class="markdownIt-Anchor" href="#元数据"></a> 元数据</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect id</span><br></pre></td></tr></table></figure>
<p>详细描述容器的信息</p>
<h4 id="从容器内拷贝文件到主机上"><a class="markdownIt-Anchor" href="#从容器内拷贝文件到主机上"></a> 从容器内拷贝文件到主机上</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp</span><br></pre></td></tr></table></figure>
<h4 id="端口暴露"><a class="markdownIt-Anchor" href="#端口暴露"></a> 端口暴露</h4>
<p>主机本身有端口, 其次是容器自己也有端口. 若要从外网访问主机中容器的服务, 需进行端口暴露</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 3344:80 3344指的是主机开启的端口, 而80指的是容器自己的端口</span></span><br><span class="line">docker run -d --name name -p 3344:80 命令</span><br></pre></td></tr></table></figure>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210729162845231.png?raw=true" alt="image-20210729162845231" style="zoom:50%;">
<h4 id="查看状态"><a class="markdownIt-Anchor" href="#查看状态"></a> 查看状态</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看容器占用内存, CPU等数据, 防止因为容器占用的容量越大, 导致系统卡顿</span></span><br><span class="line">docker stats</span><br></pre></td></tr></table></figure>
<h3 id="联合文件系统"><a class="markdownIt-Anchor" href="#联合文件系统"></a> 联合文件系统</h3>
<p>镜像的文件组成系统</p>
<p>一种分层, 轻量级且高性能的文件系统, 对文件系统的修改作为一次提交来一层层叠加. 可以将不同目录挂载到同一个虚拟文件系统下.</p>
<blockquote>
<p>同时加载多个文件系统, 但联合加载会将各层的文件系统统一为一个文件系统</p>
</blockquote>
<h4 id="bootfs"><a class="markdownIt-Anchor" href="#bootfs"></a> bootfs</h4>
<p>Docker镜像的最底底层, 大部分的Linux系统(发行版)都是一致的, 包含boot加载器和内核. 所有镜像共用的</p>
<h4 id="rootfs"><a class="markdownIt-Anchor" href="#rootfs"></a> rootfs</h4>
<p>在bootfs之上, 包含Linux系统中的 /dev, /proc, /bin, /etc 等标准目录和文件. 不同的发行版有不同</p>
<p>镜像的组成为什么那么小,  是因为bootfs是共用的, 而rootfs只需要包含基本的命令, 工具和程序库即可.</p>
<blockquote>
<p>如在安装 tomcat镜像时, 会执行分层下载.</p>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210731093301824.png?raw=true" alt="image-20210731093301824" style="zoom:50%;">
<p>左边为层号. 若docker中已经下载过的层号, 会直接复用, 不会重复下载.</p>
<p>在tomcat镜像上的操作, 会被认为是新的一层. 可以将操作完的镜像重新打包</p>
</blockquote>
<h3 id="docker-commit"><a class="markdownIt-Anchor" href="#docker-commit"></a> docker commit</h3>
<p>将新的容器变为 一个新的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker commit [OPTIONS] CONTAINER_ID [REPOSITORY[:TAG]]</span></span><br><span class="line">docker commit -m 'message' -a 'authorName' </span><br></pre></td></tr></table></figure>
<h3 id="容器数据卷"><a class="markdownIt-Anchor" href="#容器数据卷"></a> 容器数据卷</h3>
<p>镜像技术实现开发环境的独立, 但是也意味着数据也是独立的. 但我们不希望, 镜像被删除时, 数据也被删除. 且容器间数据共用, 可减少占用空间. 因此, 容器数据卷诞生.</p>
<p><mark>不同的容器可以共用一个容器数据卷</mark> 当容器被删除时, 容器数据卷不会随之删除</p>
<h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4>
<p>将容器的某一个目录同步( 挂载 )到本地主机上的一个目录. 实现容器数据放置到主机上.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v 挂载配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -e 环境变量</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name 容器名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意 这个为指定路径挂载, 除此之外还有 具名挂载, 匿名挂载</span></span><br><span class="line">docker run -it -v 本机目录path:容器目录 -v 第二个目录 imageName</span><br><span class="line">docker run -it imagesName /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看信息 <span class="string">"Mounts"</span></span></span><br><span class="line">docker inspect containerID;</span><br><span class="line"><span class="meta">#</span><span class="bash"> -v 本机目录path:容器目录</span></span><br></pre></td></tr></table></figure>
<p>是双向绑定, 即任何一方有变化, 另一方也有同样的变化</p>
<h3 id="具名挂载与匿名挂载"><a class="markdownIt-Anchor" href="#具名挂载与匿名挂载"></a> 具名挂载与匿名挂载</h3>
<p>在进行容器数据卷挂载时, 可以指定本机目录path, 也可不指定. 不指定则会创建一个新的数据卷, 匿名数据卷位于/var/lib/docker/volumes/xxxx/_data</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v [卷名(若卷名不存在,则自动创建)|本机的绝对路径:]容器目录 imageName</span><br></pre></td></tr></table></figure>
<h4 id="docker-volume"><a class="markdownIt-Anchor" href="#docker-volume"></a> docker volume</h4>
<p>查看目前docker容器所有的容器数据卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect 容器数据卷名</span><br></pre></td></tr></table></figure>
<h3 id="dockerfile"><a class="markdownIt-Anchor" href="#dockerfile"></a> Dockerfile</h3>
<p>构建镜像的配置文件.  定义构建镜像的文件</p>
<p>由命令 + 参数  组成</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="keyword">FROM</span> imageNAME</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'something'</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">'volume1'</span>, <span class="string">'volume2'</span>]</span></span><br></pre></td></tr></table></figure>
<p>执行 docker bulid 命令即可创建</p>
<h4 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h4>
<ol>
<li>编写dockerFile</li>
<li>通过dockerFile构建镜像 docker image</li>
<li>根据镜像启动docker容器</li>
</ol>
<h4 id="常用dockerfile指令"><a class="markdownIt-Anchor" href="#常用dockerfile指令"></a> 常用dockerFile指令</h4>
<ul>
<li>
<p>FROM                   基于的基础镜像</p>
</li>
<li>
<p>MAINTAIER          镜像作者</p>
</li>
<li>
<p>RUN                      镜像构建时需要运行的命令</p>
</li>
<li>
<p>ADD                      需添加的内容</p>
</li>
<li>
<p>WORKDIR             工作目录</p>
</li>
<li>
<p>VOLUME               挂载的目录</p>
</li>
<li>
<p>EXPOSE                 暴露端口配置</p>
</li>
<li>
<p>CMD                      指定容器启动时, 需要执行的命令, 仅最后一个生效</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMD ["ls", "-a"]</span><br><span class="line">CMD commandPath1 &amp;&amp; commandPath2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会自动执行 ls -a, 目录是设定的工作目录</span></span><br><span class="line">docker run imagesName</span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是 会出错, 因为 -l 代替 ls -a</span></span><br><span class="line">docker run imagesName -l</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>ENTRYPOINT       指定容器启动时, 需执行的命令, 可以追加命令</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT["ls", "-a"]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 会执行 ls -l -a</span></span><br><span class="line">docker run iamgesName -l</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>COPY                    与ADD相似, 将文件进行拷贝</p>
</li>
<li>
<p>ENV                       构建时, 设定环境变量</p>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> name&lt;email&gt;</span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> WORKPATH /usr/local</span><br><span class="line"><span class="comment"># 终端打开时默认的目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">  <span class="variable">$WORKPATH</span></span></span><br><span class="line"><span class="comment"># 指定的命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install net-tools</span></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># 执行的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$WORKPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"....."</span></span></span><br><span class="line"><span class="comment"># 默认bash的路径, 运行bash</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure>
<h4 id="docker-build"><a class="markdownIt-Anchor" href="#docker-build"></a> docker build</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Usage:  docker build [OPTIONS] PATH | URL | -</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker build -f dockerFile路径 -t 镜像名:[tag] .(在表示当前目录)</span></span><br><span class="line">docker build -f mydockerfile -t image:0.1(版本号) .</span><br></pre></td></tr></table></figure>
<p>build完后, 会生成一个镜像.</p>
<p><code>docker history imageName</code> 可查看镜像的构建过程</p>
<h3 id="数据卷容器"><a class="markdownIt-Anchor" href="#数据卷容器"></a> 数据卷容器</h3>
<p>若数据卷间, 需要共享数据卷, 则可利用docker run的参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker02与docker01共用docker01的数据卷.</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 两者在数据卷中修改, 两者都可见</span></span><br><span class="line">docker run -it --name dcoker02 --volumes-from docker01 imagesName</span><br></pre></td></tr></table></figure>
<p>只要仍有容器使用数据卷, 那么数据卷不会消失. 与C++中的 shared_ptr的规则相同.</p>
<h2 id="总结图"><a class="markdownIt-Anchor" href="#总结图"></a> 总结图</h2>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210803171519038.png?raw=true" alt="image-20210803171519038"></p>
<p>tarfile: 镜像打包文件</p>
<ul>
<li>docker ps 查看当前容器</li>
<li>docker top 查看当前执行的容器</li>
<li>docker attach 进入当前容器的执行命令 (可能是终端)</li>
<li>docker exec 在该容器, 另其执行一个命令</li>
</ul>
<h2 id="docker-网络"><a class="markdownIt-Anchor" href="#docker-网络"></a> Docker 网络</h2>
<h3 id="信息交互原理"><a class="markdownIt-Anchor" href="#信息交互原理"></a> 信息交互原理</h3>
<p>docker是基于 client - serve. 即客户端 与 服务器.</p>
<p>Docker的守护进程运行在主机上, 通过Socket从客户端访问. 然后Docker守护进程将信息发送给特定的容器</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210729120543992.png?raw=true" alt="image-20210729120543992"></p>
<h3 id="docker-网卡"><a class="markdownIt-Anchor" href="#docker-网卡"></a> Docker 网卡</h3>
<p>docker安装时, 会默认安装一个网桥 <code>docker0</code> , 这个网桥是负责所有容器的信息交互.  同时 Docker 会随机分配一个本地未占用的私有网络段给 docker0. 用于为容器分配 IP 地址.</p>
<p>容器视 <code>docker0</code> 为路由器, <mark>由路由器负责转发给本机, 或者其他容器</mark></p>
<blockquote>
<p>macOS 和 Windows 没有 docker0, 但有其他的解决办法</p>
</blockquote>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20210810102737175.png?raw=true" alt="image-20210810102737175" style="zoom: 33%;">
<blockquote>
<p>Docker网络连接原理示意图</p>
</blockquote>
<p>采用 <code>evth-pair</code> 技术</p>
<p>每注册一个容器, 会创建一个 <code>veth pair</code> 互联接口, 其中</p>
<ul>
<li>
<p>veth 挂载在宿主主机中</p>
</li>
<li>
<p>eth0 则是挂载在容器内</p>
<blockquote>
<p>eth0 是第一个以太网接口, 这种类型的接口通常是通过5类电缆连接到网络的<code>网卡</code>。</p>
<p>eth0 无论在容器还是宿主内, 都应该存在, 不然无法与外网通信 (网卡都没了, 你还能上百度?)</p>
</blockquote>
</li>
</ul>
<p>veth 向 etho0 发送数据时, eth0 会自动收到相同的包. 而 eth0 向 veth 发送也是同理. 用上述技术实现容器和宿主通信.</p>
<h4 id="实际体验"><a class="markdownIt-Anchor" href="#实际体验"></a> 实际体验</h4>
<p>Linux 系统, 在运行 3 个容器</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20220414095510004.png?raw=true" alt="image-20220414095510004"></p>
<p>在宿主机中调用 ifconfig 命令</p>
<blockquote>
<p>ifconfig 命令 <a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man8/ifconfig.8.html">官方文档</a> 给出是列出所有与内核关联的 网络接口</p>
<p>而<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BB%8B%E9%9D%A2">网络接口</a>可以是</p>
<ul>
<li>网卡</li>
<li>一个网络与另一个网络间的互接点</li>
</ul>
</blockquote>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20220414095547656.png?raw=true" alt="image-20220414095547656" style="zoom:50%;">
<p>可以发现真的有三个 veth 虚拟网络设备</p>
<h4 id="实际运用"><a class="markdownIt-Anchor" href="#实际运用"></a> 实际运用</h4>
<p>Linux环境下, 假设有一个 <code>Java</code> 环境容器, 以 <code>bridge</code> 方式运行. 但 <code>Java</code> 环境中的 <code>Spring Boot</code>  服务想访问宿主 <code>MySQL</code> 服务, 那要怎么做呢?</p>
<ol>
<li>
<p>查看 docker0 网卡地址</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shell中输入 ifconfig命令, 搜索docker0虚拟网卡的信息</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-14_11:09:17-image-20220414094156126.png?raw=true" alt="image-20220414094156126"></p>
<ul>
<li>inet是 docker0 的网卡地址 172.17.0.1</li>
</ul>
</li>
<li>
<p>在 SpringBoot 服务中配置 MySQL地址</p>
 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://172.17.0.1:3306</span><br></pre></td></tr></table></figure>
<p>此时 Java 容器便可访问宿主的MySQL服务</p>
<blockquote>
<p>如果还不行, 建议检查 MySQL 是否开启远端服务, 要开启远端服务, 容器才能访问宿主.</p>
<p>因为容器与宿主, <mark>在网络上, 可视为两个独立的主机</mark>. 可以尝试用自己的电脑, 使用 MySQL连接工具, 对服务器上的 MySQL 进行连接, 若能连接成功, 那也意味着容器也能正常访问宿主(服务器)的 MySQL.</p>
</blockquote>
</li>
</ol>
<h3 id="模式"><a class="markdownIt-Anchor" href="#模式"></a> 模式</h3>
<ul>
<li>host</li>
</ul>
<p>容器的网络栈<mark>不会与本机的网络栈隔离</mark>, 容器不会有自己的IP地址. 容器与本机共用网络.</p>
<blockquote>
<p>对应的 -p 选项会被忽视, -p是将容器的端口映射到主机上. 容器用命名空间技术, 将自己的网络栈与主机的网络栈隔离</p>
</blockquote>
<p><code>host</code>网络驱动仅适用于Linux, 其余系统不支持</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx镜像, 用host模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 确保 Docker可以使用相应端口</span></span><br><span class="line">docker run -rm -d --network host --name my_nginx nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>bridge</li>
</ul>
<blockquote>
<p>桥接网络</p>
<p><mark>本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接</mark>, 虚拟网卡与物理网卡<mark>位于同一网段</mark>.</p>
<p>对外看IP地址, 是有两台计算机(主机IP地址 + 虚拟机IP地址)</p>
<p>需手动配置虚拟机的IP地址, 应位于同一网段. docker有默认配置</p>
</blockquote>
<blockquote>
<p>补充NAT模式, 网络地址转换   (与主机访问网关的原理一样. 服务器是无法使用NAT模式, 不然客户端无法找到服务器)</p>
<p>虚拟机的网卡和物理网卡的网络，不在同一个网络.</p>
<p>虚拟机访问网站时, 是用本地主机的IP地址进行访问的, 而收到回复后, 本地网卡根据映射表 + 目的IP地址 + 端口号, 判断该回复是属于本地主机还是虚拟机.</p>
<p>缺点: 只有本地主机能访问到虚拟机, 局域网中其他主机, 无法访问虚拟机. 因为其他主机发送数据包给主机, 主机无法判断要发给主机还是虚拟机. 因为映射表中没有记录.</p>
<p>优点: 无需手动配置IP地址</p>
<p>其他主机认为虚拟机IP地址就是主机的IP地址, 没有办法区别虚拟机与主机的区别</p>
<p>而如果虚拟机先向其他主机发送信息, 虚拟机发送信息时, 主机中网卡将虚拟机的IP地址和端口映射为主机IP地址 + 随机端口号, 并将该映射记录在表中. 主机收到其他主机回复时, 看端口号就可区别是发送给主机还是虚拟机.</p>
</blockquote>
<p>容器的网络栈会被命名空间隔离, 需要通过bridge才能与主机的网络栈信息交互</p>
<blockquote>
<p>没有配置DNS, 除非使用–link选项, 只能使用IP地址沟通</p>
<p>其中bridge便是虚拟网卡. 即docker安装时, 额外安装的一个虚拟网卡.</p>
</blockquote>
<p>打开docker时, 默认的桥接网络会被自动的创建. 新开启的容器会默认自动与其连接</p>
<blockquote>
<p>可以自定义桥接网络, 自定义的桥接优先与默认的网络</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 自定义桥接网络</span></span><br><span class="line">docker network create \</span><br><span class="line">  --driver=bridge \</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 确立子网范围, 需确保虚拟机Ip地址与本机IP地址处于同一网段</span></span><br><span class="line">  --subnet=172.28.0.0/16 \</span><br><span class="line">  --ip-range=172.28.5.0/24 \</span><br><span class="line">  --gateway=172.28.5.254 \</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 该桥接网络名字叫br0</span></span><br><span class="line">  br0</span><br></pre></td></tr></table></figure>
<p>要是采用 docker-compose, 无需配置 link. 默认可以将服务名当成域名, 并进行容器间的访问</p>
<h4 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h4>
<p>有如下 docker-compose.yml</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">nginx:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:80"</span></span><br><span class="line">    <span class="attr">java:</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9000:9000"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>省略许多信息</p>
</blockquote>
<p>若想用 nginx 反向代理给 java 容器</p>
<p>nginx的配置文件可以是</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">http{</span><br><span class="line">    index    index.html index.htm index.php;</span><br><span class="line">    server {</span><br><span class="line">				include /etc/nginx/mime.types;</span><br><span class="line">        # 设立监听端口</span><br><span class="line">        listen 80;</span><br><span class="line">        root /data/www;</span><br><span class="line"></span><br><span class="line">        location / {</span><br><span class="line">            try_files $uri $uri/ /index.html;       </span><br><span class="line">        }</span><br><span class="line">        location ^~ /api/ {</span><br><span class="line">            client_max_body_size 100m;</span><br><span class="line">            # 直接用 java 服务名, 作为域名, 对java容器进行访问</span><br><span class="line">            proxy_pass http://java:9000;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="docker-compose"><a class="markdownIt-Anchor" href="#docker-compose"></a> docker-compose</h2>
<h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4>
<p><mark>高效管理多个容器, 定义并运行多个容器.</mark></p>
<p>service: 容器</p>
<p>project: 一个对外服务的网页或者博客等</p>
<h4 id="步骤-2"><a class="markdownIt-Anchor" href="#步骤-2"></a> 步骤</h4>
<ol>
<li>定义用 dockerfile 定义项目环境, 如环境变量等. 将应用打包为镜像</li>
<li>用 yaml 文件描述需要打开的容器与关联情况等, 定义整个服务, 需要的环境</li>
<li>执行 docker-compose up 命令      需要在目录下有 docker-compose.yml 文件</li>
</ol>
<blockquote>
<p>注意: docker compose 是开源项目, 需要先安装</p>
</blockquote>
<h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3>
<ol>
<li>
<p>下载</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载是国内源 + --output是指定下载地址</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` --output /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>授权<br>
+x权限</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker-compose地址</span></span><br><span class="line">chomd u+x chmod u+x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="例子-2"><a class="markdownIt-Anchor" href="#例子-2"></a> 例子</h3>
<p>利用flask + redis创建一个网页, 显示网页打开的次数, 并利用docker部署</p>
<ol>
<li>编写flask的dockerfile</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP=app.py</span><br><span class="line"><span class="keyword">ENV</span> FLASK_RUN_HOST=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"flask"</span>, <span class="string">"run"</span>]</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编写docker-compose.yml</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体可以写的在命令可 参考官网https://docs.docker.com/compose/compose-file/compose-file-v3/</span></span><br><span class="line"><span class="comment"># docker compose的版本</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"3.9"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="comment"># 等同于build命令构建镜像, 由于命名为Dockerfile, 可省略名字</span></span><br><span class="line">    <span class="comment"># 会扫描当前目录下的Dockerfile文件, 并调用docker build 命令</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5000:5000"</span></span><br><span class="line">    <span class="comment"># 需要注意volumes的目录要支持文件共享 File sharing</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    	<span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">   <span class="comment"># 可用image命令构建镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>执行命令 注意当前工作目录需要有docker-compose.yml文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当docker-compose.yml发生变动, 再次执行会更新</span></span><br></pre></td></tr></table></figure>
<p>关闭 docker-compose down  (要在docker-compose.yml的文件夹里)</p>
<h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4>
<p>若dockerfile或docker-compose.yml更新, 需要清除缓存与清除现有镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Build images before starting containers.</span></span><br><span class="line">docker-compose up --build</span><br><span class="line"><span class="meta">#</span><span class="bash"> Recreate containers even <span class="keyword">if</span> configuration/image hasn<span class="string">'t changed.</span></span></span><br><span class="line">docker-compose up --force-recreate</span><br><span class="line">docker-compose rm -f</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="自动默认操作"><a class="markdownIt-Anchor" href="#自动默认操作"></a> 自动默认操作</h4>
<p>执行完docker-compose.yml后, 会先执行build命令, 根据dockerfile创建或者网上拉取镜像</p>
<ul>
<li>
<p>默认的服务名 文件名_服务名_nums</p>
</li>
<li>
<p>镜像名: 文件名_服务名</p>
</li>
</ul>
<p>nums表示的是副本数量</p>
<h4 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h4>
<p>利用docker compose构建的容器, 都会位于同一子网, 可用域名访问. 而不是IP地址</p>
<h2 id="压缩镜像空间"><a class="markdownIt-Anchor" href="#压缩镜像空间"></a> 压缩镜像空间</h2>
<h3 id="将镜像底层-更换为-alpine"><a class="markdownIt-Anchor" href="#将镜像底层-更换为-alpine"></a> 将镜像底层 更换为 alpine</h3>
<p><code>Alpine</code> 操作系统是一个面向安全的轻型 <code>Linux</code> 发行版。它不同于通常 <code>Linux</code> 发行版, 很小</p>
<blockquote>
<p>代价是缺失很多命令, 出错调试非常难受</p>
</blockquote>
<p>常用于docker底层的镜像系统中</p>
<p>常用底层镜像一览</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG           IMAGE ID          VIRTUAL SIZE</span><br><span class="line">alpine              latest        4e38e38c8ce0      4.799 MB</span><br><span class="line">debian              latest        4d6ce913b130      84.98 MB</span><br><span class="line">ubuntu              latest        b39b81afc8ca      188.3 MB</span><br><span class="line">centos              latest        8efe422e6104      210 MB</span><br></pre></td></tr></table></figure>
<h4 id="alpine镜像-注意点"><a class="markdownIt-Anchor" href="#alpine镜像-注意点"></a> alpine镜像 注意点</h4>
<p>docker alpine镜像执行linux的可执行程序时, 会出现not found报错,</p>
<p>由于alpine镜像使用的是musl libc而不是gnu libc. 这种情况是因为<strong>动态链接库位置错误导致</strong></p>
<h4 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h4>
<ol>
<li>
<p>不用 Alpine，选择和编译环境一致的发行版；或者干脆在 Alpine 下编译运行。</p>
</li>
<li>
<p>给 Alpine 安装一个轻量的 glibc 兼容层 <a target="_blank" rel="noopener" href="https://pkgs.alpinelinux.org/package/edge/main/x86_64/libc6-compat">libc6 compatibility package</a>: <code>apk add libc6-compat</code>。（对于简单的程序，兼容层足够解决问题，但是复杂的程序可能仍然无法正常运行）</p>
</li>
<li>
<p>给 Alpine 安装真正的 glibc。(网上嫖来的 <code>dockerfile</code> 写法)</p>
<blockquote>
<p>Linux系统接口有效</p>
</blockquote>
</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> GLIBC_REPO=https://github.com/sgerrand/alpine-pkg-glibc</span><br><span class="line"><span class="keyword">ENV</span> GLIBC_VERSION=<span class="number">2.30</span>-r0</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -ex &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk --update add libstdc++ curl ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="keyword">for</span> pkg <span class="keyword">in</span> glibc-<span class="variable">${GLIBC_VERSION}</span> glibc-bin-<span class="variable">${GLIBC_VERSION}</span>; \</span></span><br><span class="line"><span class="bash">        <span class="keyword">do</span> curl -sSL <span class="variable">${GLIBC_REPO}</span>/releases/download/<span class="variable">${GLIBC_VERSION}</span>/<span class="variable">${pkg}</span>.apk -o /tmp/<span class="variable">${pkg}</span>.apk; <span class="keyword">done</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --allow-untrusted /tmp/*.apk &amp;&amp; \</span></span><br><span class="line"><span class="bash">    rm -v /tmp/*.apk &amp;&amp; \</span></span><br><span class="line"><span class="bash">    /usr/glibc-compat/sbin/ldconfig /lib /usr/glibc-compat/lib</span></span><br></pre></td></tr></table></figure>
<h2 id="docker出错查看原因"><a class="markdownIt-Anchor" href="#docker出错查看原因"></a> Docker出错查看原因</h2>
<p>docker容器启动秒挂, 咋整 ?</p>
<ol>
<li>利用docker ps -al 命令查看退出code.</li>
<li><mark>利用docker logs + 容器ID查看退出错误日志</mark></li>
</ol>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<ul>
<li>Docker技术入门与实战  第3版</li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1og4y1q7M4?spm_id_from=333.337.search-card.all.click">狂神说Java Docker最新超详细版教程通俗易懂</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/network/">Docker Network官方文档</a></li>
</ul>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:874579938@qq.com" target="_blank"><i class="fa fa-envelope-o"></i></a></div><div class="footer">© 2022 <a href="/" rel="nofollow">镇远</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>