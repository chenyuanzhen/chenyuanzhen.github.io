<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Shell编程 | 笔记仓库</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">笔记仓库</a><span class="subtitle">知道为什么比知道怎么做更重要</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>Shell编程</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2022-04-07</div><div class="post-tags"><a class="post-tag-none-link" href="/tags/Linux/" rel="tag">Linux</a></div></div></div><article><div class="container post"><h2 id="shell概述"><a class="markdownIt-Anchor" href="#shell概述"></a> Shell概述</h2>
<p>Shell是指一个可执行程序, 为用户提供界面访问操作系统内核服务.</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20220407222359742.png?raw=true" alt="image-20220407222359742" /></p>
<blockquote>
<p>一般购买服务器, 都会采用Shell与Linux操作系统内核交互</p>
</blockquote>
<p>Shell编程</p>
<h2 id="shell脚本"><a class="markdownIt-Anchor" href="#shell脚本"></a> Shell脚本</h2>
<p>Shell脚本, 是指运行在shell上的脚本程序. 而平常使用的Shell, 本质也是一个脚本, 写一句执行一句, 而若写成文件 (即脚本), 可理解为在命令行逐行输入命令语句.</p>
<p>例子</p>
<p>编写一个Shell脚本 <a target="_blank" rel="noopener" href="http://helloShell.sh">helloShell.sh</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd public</span><br><span class="line">ls -al</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>
<p>将其放到blog目录下, 执行</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20220407222717209.png?raw=true" alt="image-20220407222717209" /></p>
<blockquote>
<p>记得用<code>chmod +x helloShell.sh</code>命令, 追加执行权限</p>
</blockquote>
<h4 id="为什么要用shell"><a class="markdownIt-Anchor" href="#为什么要用shell"></a> 为什么要用Shell?</h4>
<p>主流操作系统支持shell编程</p>
<blockquote>
<p>Mac OS, Linux默认安装Shell解释器</p>
<p>Windows要安装cygwin或mingw模拟Linux环境</p>
<p><code>sh</code> 标准shell解释器.</p>
<p>bash是<code>sh</code>的替代品</p>
</blockquote>
<h4 id="与python的差别"><a class="markdownIt-Anchor" href="#与python的差别"></a> 与python的差别</h4>
<p>shell的优点</p>
<ul>
<li>最好的环境兼容性, 几乎所有Linux都预装shell运行环境 (<code>sh</code>或<code>bash</code>)</li>
</ul>
<p>shell的缺点</p>
<ul>
<li>不支持面向对象</li>
<li>功能很弱, 解释型, 只能运行到指定一行, 才知道那一行错了</li>
</ul>
<p>若是简单的, 且对兼容性有高要求, Linux中无需预装任何就能运行, 那就用shell</p>
<p>若是复杂的, 那还是建议用python, 装python解释器也不怎么花功夫.</p>
<blockquote>
<p><mark>shell自身提供功能少的可怜, 只有依赖其他可执行程序和命令时, 才会变得强大</mark></p>
</blockquote>
<h3 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 原生bash不支持简单数学运算</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要调用其他命令实现</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> expr 一个C语言程序</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ``为获得命令输出结果</span></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo &quot;两树之和: $val&quot;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">加法</td>
<td style="text-align:left">`expr $a + $b` 结果为 30。</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">减法</td>
<td style="text-align:left">`expr $a - $b` 结果为 -10。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">乘法</td>
<td style="text-align:left">`expr $a * $b` 结果为  200。</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">除法</td>
<td style="text-align:left">`expr $b / $a` 结果为 2。</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">取余</td>
<td style="text-align:left">`expr $b % $a` 结果为 0。</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">赋值</td>
<td style="text-align:left">a=$b 把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">相等。用于比较两个数字，相同则返回 true。</td>
<td style="text-align:left">[ $a == $b ] 返回 false。 ==两边必有空格</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不相等。用于比较两个数字，不相同则返回 true。</td>
<td style="text-align:left">[ $a != $b ] 返回 true</td>
</tr>
</tbody>
</table>
<p><mark>关系运算符仅支持数字, 不支持字符串</mark></p>
<h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义与赋值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 变量名和等号之间不能有空格</span></span><br><span class="line">varibleName=&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用</span></span><br><span class="line">echo $varibleName</span><br><span class="line"><span class="meta">#</span><span class="bash"> 若想限定变量名范围, 可加&#123;&#125;, 最好都加&#123;&#125;</span></span><br><span class="line">echo &quot;$&#123;varibleName&#125;, Hi!&quot;</span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3>
<ul>
<li>
<p>单引号</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单引号字串中不能出现单引号</span></span><br><span class="line">str=&#x27;this is a string&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>双引号</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
</li>
<li>
<p>获取字符串长度</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出：4</span><br></pre></td></tr></table></figure>
<ul>
<li>提取子字符串</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;alibaba is a great company&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; #输出：liba</span><br></pre></td></tr></table></figure>
<ul>
<li>显示命令执行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></table></figure>
<ul>
<li>printf命名 与c语言类似</li>
</ul>
<h3 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h3>
<p><mark>shell的流程控制不可为空</mark></p>
<h4 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">elif condition2</span><br><span class="line">	command</span><br><span class="line">else</span><br><span class="line">	command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h4 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">	command</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">for(( EXP1; EXP2; EXP3 ))</span><br><span class="line">do</span><br><span class="line">	command1</span><br><span class="line">	command2</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">	command</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">until condition</span><br><span class="line">do </span><br><span class="line">	command</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> ;;表示<span class="built_in">break</span> <span class="keyword">case</span>分支用 )</span></span><br><span class="line">case &quot;$&#123;opt&#125;&quot; in</span><br><span class="line">	&quot;condition1&quot; )</span><br><span class="line">		doSomething</span><br><span class="line">	;;</span><br><span class="line">	&quot;condition2&quot; )</span><br><span class="line">		doSomething</span><br><span class="line">	;;</span><br><span class="line">	* ) doDefault</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3>
<p>文件包含</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加载function.sh文件</span></span><br><span class="line">source ./function.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于以下命令</span></span><br><span class="line">. ./function.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 函数定义</span></span><br><span class="line">[ funciton ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">	action;</span><br><span class="line">	[ return int;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用插入的参数</span></span><br><span class="line">funcWithParam()&#123;</span><br><span class="line">	echo &quot;第一个参数$&#123;1&#125;&quot;</span><br><span class="line">	echo &quot;第二个参数$&#123;2&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shell数组"><a class="markdownIt-Anchor" href="#shell数组"></a> Shell数组</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 空格分隔, 括号表示数组, 下标从0开始</span></span><br><span class="line">array_name=(element1 element2 ... elementN)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问数组元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[index]&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 访问所有元素</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[*]&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取长度</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#array_name[*]&#125;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="shell常用命令"><a class="markdownIt-Anchor" href="#shell常用命令"></a> Shell常用命令</h2>
<h3 id="test命令"><a class="markdownIt-Anchor" href="#test命令"></a> test命令</h3>
<blockquote>
<p>test命令本质是一个C语言程序</p>
</blockquote>
<p>用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试. 本身也是一个程序</p>
<ul>
<li>比较</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-eq</td>
<td style="text-align:left">等于则为真</td>
</tr>
<tr>
<td style="text-align:left">-ne</td>
<td style="text-align:left">不等于则为真</td>
</tr>
<tr>
<td style="text-align:left">-gt</td>
<td style="text-align:left">大于则为真</td>
</tr>
<tr>
<td style="text-align:left">-ge</td>
<td style="text-align:left">大于等于则为真</td>
</tr>
<tr>
<td style="text-align:left">-lt</td>
<td style="text-align:left">小于则为真</td>
</tr>
<tr>
<td style="text-align:left">-le</td>
<td style="text-align:left">小于等于则为真</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $&#123;num1&#125; -eq $&#123;num2&#125;</span><br><span class="line">then</span><br><span class="line">	echo &quot;num1 == num2&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;num1 != num2&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<ul>
<li>文件测试</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-e 文件名</td>
<td style="text-align:left">如果文件存在则为真</td>
</tr>
<tr>
<td style="text-align:left">-r 文件名</td>
<td style="text-align:left">如果文件存在且可读则为真</td>
</tr>
<tr>
<td style="text-align:left">-w 文件名</td>
<td style="text-align:left">如果文件存在且可写则为真</td>
</tr>
<tr>
<td style="text-align:left">-x 文件名</td>
<td style="text-align:left">如果文件存在且可执行则为真</td>
</tr>
<tr>
<td style="text-align:left">-s 文件名</td>
<td style="text-align:left">如果文件存在且至少有一个字符则为真</td>
</tr>
<tr>
<td style="text-align:left">-d 文件名</td>
<td style="text-align:left">如果文件存在且为目录则为真</td>
</tr>
<tr>
<td style="text-align:left">-f 文件名</td>
<td style="text-align:left">如果文件存在且为普通文件则为真</td>
</tr>
<tr>
<td style="text-align:left">-c 文件名</td>
<td style="text-align:left">如果文件存在且为字符型特殊文件则为真</td>
</tr>
<tr>
<td style="text-align:left">-b 文件名</td>
<td style="text-align:left">如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">	echo &quot;./bash is exist&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;./bash is not exist&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：</p>
<p><strong>!</strong> 最高， <strong>-a</strong> 次之， <strong>-o</strong> 最低</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">num3=200</span><br><span class="line">if test $&#123;num1&#125; -eq $&#123;num2&#125; -a $&#123;num3&#125; -eq $&#123;num2&#125;</span><br><span class="line">then</span><br><span class="line">	echo &quot;num1 == num2 &amp;&amp; num3 == num2&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;num1 num2 num3不完全相等&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h3 id="grep-查找"><a class="markdownIt-Anchor" href="#grep-查找"></a> grep 查找</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在path/to/file文件中, 检索符合条件的字符, 会将满足条件的行输出出来</span></span><br><span class="line">grep &quot;search_pattern&quot; path/to/file</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一般配合管道使用 管道是什么? 下面会有描述</span></span><br><span class="line">ls -al | grep *.log # 在当前目录中, 找到后缀为.log的文件 </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-grep.html">grep命令参数讲解</a></p>
<h3 id="sed命令-编辑"><a class="markdownIt-Anchor" href="#sed命令-编辑"></a> sed命令 编辑</h3>
<p>stream editor流编辑器.</p>
<p>需要事先提供一组<mark>规则(又称脚本)</mark>, sed会按照该规则编辑数据</p>
<p>处理文本文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e 脚本命令</td>
<td>该选项会将其后跟的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td>-f 脚本命令文件</td>
<td>该选项会将其后文件中的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td>-n</td>
<td>默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。</td>
</tr>
<tr>
<td>-i</td>
<td>此选项会直接修改源文件，要慎用。</td>
</tr>
</tbody>
</table>
<h4 id="script命令"><a class="markdownIt-Anchor" href="#script命令"></a> script命令</h4>
<p>s匹配替换</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定行数, 只会检查该行, 否则检查所有行</span></span><br><span class="line">[行数]s/被替换内容/替换新内容/flag</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>flags 标记</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>1~512 之间的数字</td>
<td>表示指定要替换的字符串出现第几次时才进行替换，<br />例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记；</td>
</tr>
<tr>
<td>g</td>
<td>对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A；</td>
</tr>
<tr>
<td>p</td>
<td>会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。</td>
</tr>
<tr>
<td>w file</td>
<td>将缓冲区中的内容写到指定的 file 文件中；</td>
</tr>
<tr>
<td>&amp;</td>
<td>用正则表达式匹配的内容进行替换；</td>
</tr>
<tr>
<td>\n</td>
<td>匹配第 n 个子串，该子串之前在 pattern 中用 () 指定。</td>
</tr>
<tr>
<td>\</td>
<td>转义（转义替换部分包含：&amp;、\ 等）。</td>
</tr>
</tbody>
</table>
<p>a附加</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若指定行数, 则在指定行后面附加新文件内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 行数可以指定多个 2, 3表示第2, 3行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或从一行到最后一行$  2,$表示从第2行到最后一行</span></span><br><span class="line">[行数]a\新文件内容  </span><br></pre></td></tr></table></figure>
<p>c全部替换</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 若指定行数, 则将那一行修改位替换的新文本</span></span><br><span class="line">[address]c\用于替换的新文本</span><br><span class="line">sed &#x27;3c\the third line will be replaced&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="awk分析"><a class="markdownIt-Anchor" href="#awk分析"></a> awk分析</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">$ awk 动作 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># print表示打印, $0表示所有内容, $1为第一个字段, $2为第二个</span></span><br><span class="line"><span class="comment"># 用-F指明区分字符 </span></span><br><span class="line"><span class="comment"># 按一行行处理</span></span><br><span class="line"><span class="comment"># 用单引号, 不要用双引号, 否则会将转义后的语句传给awk</span></span><br><span class="line"><span class="comment"># 将一行句子以:分隔, $1表示打印第一个  如 root:seed 会被分隔为[root, seed], $1对应root</span></span><br><span class="line">$ awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> demo.txt</span><br></pre></td></tr></table></figure>
<h2 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> |为管道</span></span><br><span class="line">ls -al /etc | less</span><br></pre></td></tr></table></figure>
<p>将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;pattern&quot; path/to/file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 采用管道, 会将cat的输出作为grep的输入</span></span><br><span class="line">cat filename | grep &quot;pattern&quot;</span><br></pre></td></tr></table></figure>
<p>cat filename | grep “pattern” 发生什么?</p>
<ol>
<li>进程装载cat程序, 执行cat程序</li>
<li>打开filename文件, 将内容输出到管道文件中</li>
</ol>
<blockquote>
<p>管道文件: 可视为一个文件, 不过该文件仅会存储在内存中, 不会写入磁盘.</p>
</blockquote>
<ol start="3">
<li>
<p>grep 打开管道文件</p>
<blockquote>
<p>grep命令, 是针对文件的, 需要打开文件, 并读取文件内容. 此处打开的是管道文件</p>
</blockquote>
</li>
<li>
<p>对管道文件内容进行匹配.</p>
</li>
<li>
<p>将匹配结果输出到终端中</p>
</li>
</ol>
<blockquote>
<p>父进程与子进程通信, 也可以通过管道完成</p>
</blockquote>
<h3 id="重定向与管道的差别"><a class="markdownIt-Anchor" href="#重定向与管道的差别"></a> 重定向与管道的差别</h3>
<ul>
<li>
<p>管道: 将标准输出作为标准输入传递给<mark>另一个命令</mark></p>
<blockquote>
<p>具体流程是</p>
<ol>
<li>标准输出重定向到管道文件</li>
<li>将管道文件路径传给下一个命令</li>
</ol>
</blockquote>
</li>
<li>
<p>重定向: 将输出符<mark>指向</mark>文件</p>
</li>
</ul>
<h2 id="信号signal"><a class="markdownIt-Anchor" href="#信号signal"></a> 信号signal</h2>
<p><em>信号(signal)是一种软中断，信号机制是进程间通信的一种方式，采用异步通信方式</em></p>
<h3 id="产生"><a class="markdownIt-Anchor" href="#产生"></a> 产生</h3>
<ul>
<li>
<p>硬件方式</p>
<ul>
<li>
<p>用户输入</p>
<blockquote>
<p>ctrl+C, 产生SIGINT信号</p>
</blockquote>
</li>
<li>
<p>硬件异常</p>
<blockquote>
<p>CPU检测到内存非法访问等异常, 通知内核生成对应信号, 并发送给产生事件的进程</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>软件方式</p>
<ul>
<li>
<p>系统调用, 发送signal信号</p>
<ul>
<li>
<p>alarm调用, 设定一个闹钟. 告诉内核在seconds秒之后给当前进程发送<code>SIGALRM</code>信号</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br><span class="line"> <span class="comment">// 处理SIGALRM信号, 默认是终止进程</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>kill(pid, signal)</code>调用</p>
<p>向pid进程, 发送signal信号</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">kill</span><span class="params">(pid, SYNC_SIG)</span> </span>== <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内核中的信号表示"><a class="markdownIt-Anchor" href="#内核中的信号表示"></a> 内核中的信号表示</h3>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20220330165112082-9343521.png?raw=true" alt="image-20220330165112082" style="zoom:50%;" />
<ul>
<li>
<p>block  信号种类</p>
</li>
<li>
<p>pending</p>
<ul>
<li>1表示已经产生信号, 但信号尚未处理</li>
</ul>
</li>
<li>
<p>handler</p>
<p>处理信号函数</p>
</li>
</ul>
<h3 id="发送信号-kill命令"><a class="markdownIt-Anchor" href="#发送信号-kill命令"></a> 发送信号 kill命令</h3>
<blockquote>
<p>kill – terminate or signal a process</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以查看系统定义的信号列表</span></span><br><span class="line">kill -l </span><br><span class="line"><span class="meta">#</span><span class="bash"> 中断进程 142 与157</span></span><br><span class="line">kill 142 157</span><br><span class="line"><span class="meta">#</span><span class="bash"> 向进程发送SIGHUP信号</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将507进程挂起</span></span><br><span class="line">kill -s HUP 507</span><br></pre></td></tr></table></figure>
<p>shell中可通过按键给前台进程发送信号</p>
<ul>
<li>
<p>ctrl + c 产生SIGINT信号 中断程序</p>
</li>
<li>
<p>ctrl + z 产生SIGTSTP信号 使进程暂停,</p>
<blockquote>
<ul>
<li>SIGSTOP信号 不可以被程序忽视 ctrl / 按了一定会退出</li>
<li>SIGTSTP信号 可以被程序忽视, 若程序修改SIGTSTP信号的处理函数, 那么程序不会退出, 而是改为执行处理函数</li>
</ul>
<p>两者信号的操作都是暂停进程</p>
</blockquote>
</li>
</ul>
<h4 id="种类"><a class="markdownIt-Anchor" href="#种类"></a> 种类</h4>
<p>定义64中信号, 32种可靠信号与32种不可靠信号</p>
<ul>
<li>不可靠信号： 又称非实时信号，不支持排队，信号可能会丢失, 比如发送多次相同的信号, 进程只能收到一次. 信号值取值区间为1~31</li>
<li>可靠信号： 也称为实时信号，支持排队, 信号不会丢失, 发多少次, 就可以收到多少次. 信号值取值区间为32~64</li>
</ul>
<h3 id="信号安装"><a class="markdownIt-Anchor" href="#信号安装"></a> 信号安装</h3>
<p>先要在进程中安装对应信号, 那么才会对信号进行处理.</p>
<p>主要建立信号值和进程相应信息值的动作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta"># sigaction函数可以读取和修改与指定信号相关联的处理动作. 调用成功则返回0，出错则返回-1.</span></span><br><span class="line"># 若act指针非空，则根据act修改该信号的处理动作。</span><br><span class="line"># 若oact指针非空，则通过oact传出该信号原来的处理动作</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signo, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> __<span class="title">sigaction_u</span> __<span class="title">sigaction_u</span>;</span>  <span class="comment">/* signal handler */</span></span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;               <span class="comment">/* signal mask to apply */</span></span><br><span class="line">  <span class="comment">// 默认设为0, 修改信号的行为</span></span><br><span class="line">	<span class="keyword">int</span>     sa_flags;               <span class="comment">/* see signal options below */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 该宏定义将sa_handler视为 __sigaction_u中的函数指针类型, 接受一个整型参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_handler      __sigaction_u.__sa_handler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* union for signal handlers */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> __<span class="title">sigaction_u</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>    (*__sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">	<span class="keyword">void</span>    (*__sa_sigaction)(<span class="keyword">int</span>, struct __siginfo *, <span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="信号阻塞"><a class="markdownIt-Anchor" href="#信号阻塞"></a> 信号阻塞</h3>
<p>进程可以选择阻塞（Block）某个信号。被阻塞的信号产生时将保持在未决状态(pending)，直到进程解除对此信号的阻塞，才执行递达的动作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printsigset</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (sigismember(<span class="built_in">set</span>, i) == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用s和p对信号进行存储</span></span><br><span class="line">    <span class="keyword">sigset_t</span>  s, p;</span><br><span class="line">    <span class="comment">// 初始化s, 将s的每一位置为0</span></span><br><span class="line">    sigemptyset(&amp;s);</span><br><span class="line">    <span class="comment">// 往信号集s中添加SIGINT信号</span></span><br><span class="line">    sigaddset(&amp;s, SIGINT);</span><br><span class="line">    <span class="comment">// 更改进程信号屏蔽字</span></span><br><span class="line">    <span class="comment">// SIG_BLOCK 进行阻塞</span></span><br><span class="line">  	<span class="comment">// 该进程要求对SIG_BLOCK信号进行阻塞</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;s, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回待处理的信号集传递给调用线程</span></span><br><span class="line">        <span class="comment">// 在集合中, 返回未决信号的掩码</span></span><br><span class="line">        sigpending(&amp;p);</span><br><span class="line">        printsigset(&amp;p);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理信号流程"><a class="markdownIt-Anchor" href="#处理信号流程"></a> 处理信号流程</h3>
<ol>
<li>
<p>用户程序注册了<code>SIGQUIT</code>信号的处理函数<code>sighandler</code></p>
</li>
<li>
<p>当前正在执行<code>main</code>函数，这时<mark>发生中断或异常切换到内核态</mark></p>
</li>
<li>
<p>在中断处理完毕后要返回用户态的<code>main</code>函数之前检查到有信号<code>SIGQUIT</code>递达</p>
</li>
<li>
<p>内核决定返回用户态后不是恢复<code>main</code>函数的上下文继续执行，而是执行<code>sighandler</code>函数，<mark><code>sighandler</code>和<code>main</code>函数使用不同的堆栈空间</mark>，它们之间不存在调用和被调用的关系，是两个独立的控制流程</p>
<blockquote>
<p>但允许调用全局变量, 要防止冲突. 信号函数与主函数是异步的, 可以当做考虑并发问题(虽然不是并发, 处理信号函数时, 主函数会暂停)</p>
</blockquote>
</li>
<li>
<p><code>sighandler</code>函数返回后自动执行特殊的系统调用<code>sigreturn</code>再次进入内核态</p>
</li>
<li>
<p>如果没有新的信号要递达，这次再返回用户态就是恢复<code>main</code>函数的上下文继续执行了</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="comment">// signo为信号</span></span><br><span class="line"><span class="comment">// 处理该函数时, 进程原先执行的函数会停止, 该函数会用与原进程不同的堆栈, 但可以通过适当使用全局变量进行交互</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_alrm</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 处理不同的信号 */</span></span><br><span class="line">    <span class="keyword">switch</span> (signo) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGALRM:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SIGALRM is coming %d\n&quot;</span>, signo);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGINT:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;SIGINT is coming %d\n&quot;</span>, signo);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nsecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> unslept;</span><br><span class="line"></span><br><span class="line">    newact.sa_handler = sig_alrm;</span><br><span class="line">    <span class="comment">// 初始化掩码</span></span><br><span class="line">    sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">    newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// oldact为之前处理SIGALRM的行为</span></span><br><span class="line">    sigaction(SIGALRM, &amp;newact, &amp;oldact);</span><br><span class="line">    sigaction(SIGINT, &amp;newact, &amp;oldact);</span><br><span class="line">    <span class="comment">// 告知内核, 在nsecs秒后, 向该进程发送SIGALRM信号</span></span><br><span class="line">    <span class="comment">// 不一定会在nsecs秒处理, 因为那时可能在处理其他信号</span></span><br><span class="line">    alarm(nsecs);</span><br><span class="line">    <span class="comment">// 暂停, 等待信号的来临</span></span><br><span class="line">    pause();</span><br><span class="line">    <span class="comment">// 要求内核停止发送alarm信号</span></span><br><span class="line">    <span class="comment">//  alarm的返回值为调用alarm时timer中剩余的时间, 若之前没有设置timer,则返回0</span></span><br><span class="line">    unslept = alarm(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 恢复为原来的SIGALRM信号处理</span></span><br><span class="line">    sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> unslept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        mysleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="volatile限定符"><a class="markdownIt-Anchor" href="#volatile限定符"></a> volatile限定符</h4>
<p>若该进程对变量没有修改, 若该变量被信号处理函数或非该进程修改, 进程在执行时, 该值是不会被修改的 (哪怕被信号处理函数修改过, 回到主程序查看, 值并没有被修改)</p>
<blockquote>
<p>这样做是出于效率考虑</p>
</blockquote>
<p>若进程需要和信号处理函数共用一个变量, 那么需要添加<code>volatile</code>关键字, 防止优化.</p>
<h3 id="信号竞争"><a class="markdownIt-Anchor" href="#信号竞争"></a> 信号竞争</h3>
<p>进程必须要占用处理器时, 才能处理信号.</p>
<p>假设以下情景</p>
<ol>
<li>
<p>进程A调用<code>alaram(nesc)</code>函数, 设定闹钟,</p>
</li>
<li>
<p>但因进程调度, A不再占有CPU,</p>
</li>
<li>
<p>过了<code>nesc秒</code>后, <code>SIGALRM</code>信号发送, 但进程A没有获得CPU,  处于<code>Pending</code>状态.</p>
</li>
<li>
<p>当A重新获得CPU时, 会优先处理<code>SIGALRM</code>信号.</p>
<p>此时问题来了</p>
</li>
<li>
<p>处理完后<code>SIGALRM</code>信号后, 回到主函数中,</p>
</li>
<li>
<p>此时主函数调用<code>pause</code>函数, 等待信号. 这个时候信号已经处理完了, <code>pause</code>已经失去作用. 导致进程无法继续执行.</p>
</li>
</ol>
<blockquote>
<p>问题的核心是, <code>pause</code>函数前, 信号就到达且被处理. 那么<code>pause</code>函数已经失去等待的意义, 却一直在等. 程序无法继续运行</p>
</blockquote>
<p>解决该问题可以采用<code>sigsuspend</code>函数</p>
<blockquote>
<p>核心是让pause操作能等到信号. 信号应在pause后到达. 若在前到达, 需要先对其进行阻塞.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 临时解除sigmask对应的信号屏蔽, 然后挂起的等待</span></span><br><span class="line"><span class="comment">// 该函数结束后, 会恢复对应屏蔽</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *sigmask)</span></span>;</span><br></pre></td></tr></table></figure>
<p>基本步骤</p>
<ol>
<li>调用<code>sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</code>时屏蔽<code>SIGALRM</code>。</li>
<li>调用<code>sigsuspend(&amp;suspmask);</code>时解除对<code>SIGALRM</code>的屏蔽，然后挂起等待待。</li>
<li><code>SIGALRM</code>递达后<code>suspend</code>返回，自动恢复原来的屏蔽字，也就是再次屏蔽<code>SIGALRM</code>。</li>
<li>调用<code>sigprocmask(SIG_SETMASK, &amp;oldmask, NULL);</code>时再次解除对<code>SIGALRM</code>的屏蔽</li>
</ol>
<h2 id="作业控制"><a class="markdownIt-Anchor" href="#作业控制"></a> 作业控制</h2>
<ul>
<li>
<p>Shell分为前台和后台.</p>
</li>
<li>
<p>Shell是控制<code>作业Job</code>(又称<code>进程组</code>)而非单个进程.</p>
<blockquote>
<p>后台可能有多个作业组</p>
<p>前台仅能有一个作业组</p>
</blockquote>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> proc1和proc2属于同一个后台进程组</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &amp;表示后台执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> proc1 | proc2 &amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> proc3、proc4、proc5属于同一个前台进程组</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> proc3 | proc4 | proc5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20220331104223836-9343741.png?raw=true" alt="image-20220331104223836" style="zoom:50%;" />
<p>ctrl + c会向所有前台进程组发送SIGINT信号, 一般情况下所有前台进程都会被关闭.</p>
<blockquote>
<p>除非该前台进程重写SIGINT信号的处理函数</p>
</blockquote>
<h2 id="参考信息"><a class="markdownIt-Anchor" href="#参考信息"></a> 参考信息</h2>
<ul>
<li><a target="_blank" rel="noopener" href="http://akaedu.github.io/book/index.html"><strong>Linux C编程一站式学习</strong></a></li>
<li><a target="_blank" rel="noopener" href="https://wangchujiang.com/linux-command/">Linux命令搜索</a></li>
</ul>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:874579938@qq.com" target="_blank"><i class="fa fa-envelope-o"></i></a></div><div class="footer">© 2022 <a href="/" rel="nofollow">镇远</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>