<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>leetCode刷题笔记-1 | 笔记仓库</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">笔记仓库</a><span class="subtitle">知道为什么比知道怎么做更重要</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>leetCode刷题笔记-1</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2022-04-08</div><div class="post-tags"><a class="post-tag-none-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></div></div></div><article><div class="container post"><h4 id="41-缺失的第一个正数"><a class="markdownIt-Anchor" href="#41-缺失的第一个正数"></a> 41. <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-missing-positive/">缺失的第一个正数</a></h4>
<p>该题难在限制条件, 空间复杂度O(1). 时间复杂度是O(n)</p>
<p>首先时间复杂度是无法再下降, 因无论如何都要遍历一次数组, 才能确定答案. 但前提是需要记录信息, 才能保证时间复杂度是O(n).</p>
<ul>
<li>
<p>若能知道某个数字是否在该数组中出现, 那只要遍历一次数组不断询问, 在不考虑是如何实现知道的情况下, 时间复杂度能达到O(n)</p>
<blockquote>
<p>利用哈希表, 能在时间复杂度O(n)情况下, 知道某个数字在数组中出现. 但空间复杂度自然也是O(n).</p>
</blockquote>
</li>
</ul>
<p>再观察答案的输出范围</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, nums.length+ 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<p>为什么? 考虑极端情况, 当输出答案是nums.length + 1时, 意味着nums数组一定包含[1, nums.length]中所有数字. 不然输出答案不可能是这个.</p>
<p>基于上述情况, 可以将原数组作为哈希需要的空间. 哈希函数也很简单, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[nums[i] - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>, 即将数字对应的索引上的数字置为负数. 需要处理以下情况</p>
<ul>
<li>
<p>abs(数字) &gt; nums.length</p>
<p>那么该数字不会影响到答案, 直接无视</p>
</li>
<li>
<p>abs(数字) &lt; nums.length</p>
<p>将数字对应的索引上的数字置为负数</p>
</li>
</ul>
<blockquote>
<p>利用abs函数, 可以无视哈希函数对原数组的修改.</p>
<p>负数和0, 不会影响到答案, 先将其置为无穷大, 再考虑即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                nums[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(nums[i]) &lt;= nums.length) &#123;</span><br><span class="line">              <span class="comment">// 只打一次标记即可</span></span><br><span class="line">                <span class="keyword">if</span>(nums[Math.abs(nums[i]) - <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">                    nums[Math.abs(nums[i]) - <span class="number">1</span>] *= -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出答案, 那么原数组中只要数字&gt;0, 说明索引对应的数字没有出现过</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="76-最小覆盖子串"><a class="markdownIt-Anchor" href="#76-最小覆盖子串"></a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4>
<p>该题属于滑动窗口.</p>
<p>利用左指针和右指针确定一个子串.</p>
<ol>
<li>
<p>先将右指针移动到涵盖t所有字符的位置.</p>
</li>
<li>
<p>再移动左指针, 直到不符合条件.</p>
<blockquote>
<p>那么就能得到一个符合要求的子串的长度, 在比较其长度即可</p>
</blockquote>
</li>
</ol>
<h4 id="51-n-皇后"><a class="markdownIt-Anchor" href="#51-n-皇后"></a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h4>
<p>每一行必须要有一个皇后, 所以遍历每一行,并在其中选定一个位置.</p>
<p>时间复杂度计算: 第一行有n个选择, 而第二行有n-1个选择(当然要少于n-1), 第三行有n-2个选择…</p>
<p>使用的是回溯法, 那么遍历时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>=</mo><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n*(n-1)*(n-2)... =n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span></p>
<p>优化的步骤是:</p>
<p>利用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的时间知晓该格子能否放置.</p>
<p>左斜线可用row - col确定唯一一条左斜线</p>
<p>右斜线可用row + col确定唯一一条右斜线</p>
<p>遍历时维护左斜线和右斜线即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] map;</span><br><span class="line">    Set&lt;Integer&gt; colLine= <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; leftLine = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; rightLine = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !leftLine.contains(row - col) &amp;&amp; !colLine.contains(col) &amp;&amp; !rightLine.contains(row + col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; possible = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; ++i) &#123;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map[i].length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(map[i][j])</span><br><span class="line">                    builder.append(<span class="string">&#x27;Q&#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    builder.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            possible.add(builder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        output.add(possible);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == map.length) &#123;</span><br><span class="line">            addOutput();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; map.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(row, j)) &#123;</span><br><span class="line">                map[row][j] = <span class="keyword">true</span>;</span><br><span class="line">                leftLine.add(row - j);</span><br><span class="line">                rightLine.add(row + j);</span><br><span class="line">                colLine.add(j);</span><br><span class="line">                find(row + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                map[row][j] = <span class="keyword">false</span>;</span><br><span class="line">                leftLine.remove(row - j);</span><br><span class="line">                rightLine.remove(row + j);</span><br><span class="line">                colLine.remove(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        find(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="253-会议室-ii"><a class="markdownIt-Anchor" href="#253-会议室-ii"></a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/meeting-rooms-ii/">253. 会议室 II</a></h4>
<h5 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h5>
<p>问题可<mark>转为同一时刻中, 有多少个会议在进行</mark>, 求其最值为所求.</p>
<h5 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h5>
<p>模拟,</p>
<p>每遇见一个会议, 先检查有无空闲的会议室</p>
<ul>
<li>无, 则需要创建一间</li>
<li>有, 直接使用空闲的会议室</li>
</ul>
<p>可花费<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>时间寻找空闲会议室</p>
<blockquote>
<p>k为会议室个数. 最多为n</p>
<p>n为会议个数</p>
</blockquote>
<p>但可用优先队列(即最小堆), 维护最先被使用完的会议室.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        queue.add(intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.peek() &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="18-四数之和"><a class="markdownIt-Anchor" href="#18-四数之和"></a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4>
<p>解法很简单</p>
<p>枚举两个数, 然后剩余两个数用双指针完成.</p>
<p>但这道题要命的是, <mark>不重复的四元祖</mark>.</p>
<blockquote>
<p>而且与顺序无关!</p>
</blockquote>
<p>一般解决不重复的问题</p>
<ol>
<li>
<p>用set去重</p>
<blockquote>
<p>但该题与顺序无关 答案[0, 0, -1, 1] 与 [-1, 1, 0,0]放入set中不会去重. 而且set也不能放入数组!</p>
</blockquote>
</li>
<li>
<p>自定枚举顺序</p>
<p>该题只有四个位置可以枚举, 所以要求<mark>每一个位置每一种数字只能出现一次. 而且要从小到大枚举</mark></p>
<blockquote>
<p>0, 1, 2, 3</p>
<p>不能是</p>
<p>2, 1, 0, 3 (乱序)</p>
</blockquote>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">  			<span class="comment">// 排序也是为去重</span></span><br><span class="line">        Arrays.sort(nums, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; ++i) &#123;</span><br><span class="line">  					<span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">								<span class="comment">// 双指针解决后两个</span></span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">                LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">                <span class="keyword">long</span> tmp = target - nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[left] + (<span class="keyword">long</span>) nums[right] &gt; tmp) &#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[left] + (<span class="keyword">long</span>) nums[right] &lt; tmp) &#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        list.add(nums[left]);</span><br><span class="line">                        list.add(nums[right]);</span><br><span class="line">                        output.add((List&lt;Integer&gt;) list.clone());</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                        list.removeLast();</span><br><span class="line">                      	<span class="comment">// 去重</span></span><br><span class="line">                        <span class="keyword">int</span> val = nums[left];</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == val)</span><br><span class="line">                            ++left;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="31-下一个排列"><a class="markdownIt-Anchor" href="#31-下一个排列"></a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4>
<p>该题是求全排列的下一个.</p>
<p>要求是恰巧是下一个字典序更大的排列.  即求比该排序字典序中更大中的最小排列.</p>
<h4 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h4>
<p>基于给定的排列出发, 构建一个字典序更大的且最小的. 尽可能的修改后面的, 而不是前面</p>
<blockquote>
<p>如 1 3 2 4, 若修改首位, 虽然满足字典序更大, 但并不是其中最小的.</p>
</blockquote>
<p>从后面出发. 找到第一个可以被修改的数字.</p>
<p>可以修改的条件是</p>
<ul>
<li>
<p>只要后面存在一个比当前数字大的元素就可修改</p>
<blockquote>
<p>如 1 3 2 4中的 2, 由于后面存在4, 所以2可以被修改, 具体操作是跟4换位.</p>
<p>1 3 4 2.</p>
<p>是从右往左找第一个大于当前元素的位置, 若存在, 则可进行交换</p>
</blockquote>
</li>
</ul>
<p>当修改完后, 只要将修改位置的后面的元素进行升序排序, 就可得到所求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">          	<span class="comment">// 从后往前, 尝试寻找可以被修改的元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; i; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt;= nums[i] + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = tmp;</span><br><span class="line">                    pos = i + <span class="number">1</span>;</span><br><span class="line">                  	<span class="comment">// 进行升序排序</span></span><br><span class="line">                    Arrays.sort(nums, pos, nums.length);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums, pos, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步观察, <code>只要后面存在一个比当前数字大的元素就可修改</code>这个条件,  也意味着该位置到数组末尾的元素排列, 可看作是一座山.</p>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:11:43-image-20220408103732224.png?raw=true" alt="image-20220408103732224" style="zoom:50%;" />
<blockquote>
<p>其中5是可修改的元素. 其位置一定是山下降左边的第一个位置.</p>
<p>5要和6进行交换</p>
</blockquote>
<p>那么可修改的元素的位置和其要交换的位置可通过遍历两次山得到</p>
<p>而且, 该位置到数组末尾的元素. 除去该位置外, 一定是一个降序数组. 那么排序可以变为reverse操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = start;</span><br><span class="line">       <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">           <span class="keyword">int</span> tmp = nums[left];</span><br><span class="line">           nums[left] = nums[right];</span><br><span class="line">           nums[right] = tmp;</span><br><span class="line">           ++left;</span><br><span class="line">           --right;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length == <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> left = nums.length - <span class="number">2</span>;</span><br><span class="line">     	<span class="comment">// 找到山下降左边的第一个位置. 即可修改元素的位置, =是因为若山峰是一块平地不是尖的, 我们需要看山的边缘, 若不然, 得到的排列跟原来排列一样</span></span><br><span class="line">       <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; nums[left] &gt;= nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">           --left;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">     	<span class="comment">// 找到要交换的元素位置, 刚好大于可修改元素</span></span><br><span class="line">       <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] &gt;= nums[right]) &#123;</span><br><span class="line">           --right;</span><br><span class="line">       &#125;</span><br><span class="line">     	<span class="comment">// 交换</span></span><br><span class="line">       <span class="keyword">int</span> tmp = nums[left];</span><br><span class="line">       nums[left] = nums[right];</span><br><span class="line">       nums[right] = tmp;</span><br><span class="line">     </span><br><span class="line">       <span class="keyword">if</span>(left == right)</span><br><span class="line">           reverse(nums, left);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           reverse(nums, left + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="836-矩形重叠"><a class="markdownIt-Anchor" href="#836-矩形重叠"></a> <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rectangle-overlap/">836. 矩形重叠</a></h4>
<p>逆反思维的体现</p>
<p>只要一个矩形在另一个矩形的 左 或 上, 右, 下 方, 那么两个矩形一定是不重叠, 反之, 两个矩形一定重叠</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">Point</span>(<span class="keyword">int</span> _x, <span class="keyword">int</span> _y):<span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;;</span><br><span class="line">    &#125;Point;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; rec1, vector&lt;<span class="keyword">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 防止rec1与rec2矩形面积为0</span></span><br><span class="line">        <span class="keyword">if</span>(rec1[<span class="number">0</span>] == rec1[<span class="number">2</span>] &amp;&amp; rec1[<span class="number">1</span>] == rec1[<span class="number">3</span>] || rec2[<span class="number">0</span>] == rec2[<span class="number">2</span>] &amp;&amp; rec2[<span class="number">1</span>] == rec2[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 只要rec2在rec1的右下左上, 就不会重叠, 反之, 一定重叠</span></span><br><span class="line">        <span class="keyword">if</span>(rec1[<span class="number">2</span>] &lt;= rec2[<span class="number">0</span>] || rec1[<span class="number">1</span>] &gt;= rec2[<span class="number">3</span>] || rec1[<span class="number">0</span>] &gt;= rec2[<span class="number">2</span>] || rec1[<span class="number">3</span>] &lt;= rec2[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:874579938@qq.com" target="_blank"><i class="fa fa-envelope-o"></i></a></div><div class="footer">© 2022 <a href="/" rel="nofollow">镇远</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>