<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>设计竞赛笔记 | Charles chen's blogs</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Charles chen's blogs</a><span class="subtitle">冲冲冲</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>设计竞赛笔记</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2021-03-25</div><div class="post-tags"><a class="post-tag-none-link" href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" rel="tag">算法学习</a></div></div></div><article><div class="container post"><h1 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h1>
<h2 id="组合数学"><a class="markdownIt-Anchor" href="#组合数学"></a> 组合数学</h2>
<p>有m个空位中插入k棵树, 每棵树之间至少有一个空位.</p>
<p>由于树互不相邻，我们可以认为至少有m-1个空位</p>
<p>于是剩下n-m+1个位置放m个数</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mrow><mi>m</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><mi>k</mi></msubsup></mrow><annotation encoding="application/x-tex">A^k_{m-k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190547em;vertical-align:-0.34143899999999994em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.4168920000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34143899999999994em;"><span></span></span></span></span></span></span></span></span></span></p>
<h2 id="合并-二分与树结合"><a class="markdownIt-Anchor" href="#合并-二分与树结合"></a> 合并, 二分与树结合</h2>
<p>尝试将其画成<strong>树</strong>, 如果是<mark>要求每一次合并的值都是最小值</mark>, <mark>可以使用哈夫曼树</mark></p>
<h2 id="正反向思考-是拆解还是合成"><a class="markdownIt-Anchor" href="#正反向思考-是拆解还是合成"></a> 正反向思考  是拆解还是合成</h2>
<p>对于大部分题目对执行方向都是不做要求的, 即只要结果, 不管过程, 可以从初始条件出发—&gt;末尾条件 得到结果.也可以<mark>末尾条件–&gt;初始条件</mark></p>
<h2 id="等价交换结果"><a class="markdownIt-Anchor" href="#等价交换结果"></a> 等价交换结果</h2>
<p>结果可以进行适当的等价转化, 方便进一步的思考问题. 比如题目只要求求最大值, 至于这个最大值由哪里出发推出来并不用思考. 很多时候都是自己给自己添加约束.</p>
<h2 id="简化题目要求-左右可简化为考虑排序后-检查一边"><a class="markdownIt-Anchor" href="#简化题目要求-左右可简化为考虑排序后-检查一边"></a> 简化题目要求 左右可简化为考虑排序后, 检查一边</h2>
<p>比如题目要去是一个范围, 左右两边, 经过<strong>排序后</strong>对于起点而言, 没有左边, 那么只有从起点出发只考虑左边, 那么<mark>不用考虑右边</mark>这种情况.</p>
<h2 id="题目包含分隔"><a class="markdownIt-Anchor" href="#题目包含分隔"></a> 题目包含分隔</h2>
<p>一分为二, 可以尝试写成<mark>树</mark>来思考. 使用树相关算法, 求出值</p>
<h2 id="边界条件要考虑"><a class="markdownIt-Anchor" href="#边界条件要考虑"></a> 边界条件要考虑</h2>
<p>比如区间的左右两边是否可取, 特殊值,</p>
<h2 id="缩小穷举的范围"><a class="markdownIt-Anchor" href="#缩小穷举的范围"></a> 缩小穷举的范围</h2>
<h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解 /</h2>
<p>a / b 结果d表示:  a有 k 个b组成</p>
<h2 id="理解-2"><a class="markdownIt-Anchor" href="#理解-2"></a> 理解%</h2>
<p>a % b结果c表示:  a = k * b + c</p>
<p>在一个长度为n<mark>循环链表, 即有周期的操作</mark>里, <strong>走k % n步得到的结果 == 走k步得到的结果.</strong> 因为在<strong>循环</strong>中, 是周期性. 如果k中包含多个周期n ( 即链表的长度 ). 这些操作都是多余的. <mark>得到的结果都是相同的</mark></p>
<p>( 当前做的次数 + 一个周期的次数 )效果 == 当前做的次数的效果.</p>
<h1 id="常用算法思想"><a class="markdownIt-Anchor" href="#常用算法思想"></a> 常用算法思想</h1>
<h2 id="如何将问题分解成多个子问题"><a class="markdownIt-Anchor" href="#如何将问题分解成多个子问题"></a> 如何将问题分解成多个子问题</h2>
<p>解决其中一个问题, 再以<mark>重复的手段</mark>解决一个问题, 直到<mark>所有小问题都解决</mark>等同于<mark>主问题解决</mark>.</p>
<h2 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h2>
<p><mark>数据量太少 &lt;10000, 绝对不可能是贪心</mark></p>
<p>贪心算法, 先以一种简单方案去执行, 考虑特殊情况特殊处理, 完成题目.</p>
<p>一般而言, 我们可以构建出多种贪心方案, 很多时候需要自己<mark>构建反例</mark>, 去验证贪心是否能够正确处理所有情况. 如果不行考虑, 另一种方向贪心, 或者改用动态规划.</p>
<p><mark>只能依赖于先前的条件作出判断, 不能依赖之后的条件</mark></p>
<p>贪心的证明: 最好是用<mark>数学式子推出正确性</mark></p>
<p>这是一种重要的贪心证明方法，即只要计算假如相邻的两项交换位置，会对答案产生的影响，分析是交换更优还是不交换更优</p>
<h3 id="证明贪心算法的正确性"><a class="markdownIt-Anchor" href="#证明贪心算法的正确性"></a> 证明贪心算法的正确性</h3>
<ol>
<li>
<p>贪心选择性:</p>
<p>假设有一个最优解, 其最优解中的部分决策可以被替换而且仍是最优解, 说明贪心选择是可行的</p>
</li>
<li>
<p>最优子结构<br>
主问题可以被分解为<strong>规模更小且与主问题完全一样的问题</strong>. 所有的局部最优解构成全局最优解</p>
</li>
</ol>
<p>例子:</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P1080">国王游戏</a></p>
<p>要求<mark>所有排队顺序中获奖赏最多的大臣所获得的金币数最少</mark>.</p>
<p>可以列式子进行证明:</p>
<p>假设有两个大臣 + 一个国王</p>
<p>顺序一共有两组:</p>
<ol>
<li>
<p>左手: a,  b,  c</p>
<p>右手: A, B, C</p>
</li>
<li>
<p>左手: a, c, b<br>
右手: A. C, B</p>
</li>
</ol>
<p>答案就是 min(  max(  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">a/B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>,      <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi><mi mathvariant="normal">/</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">a*b/C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> ),  max(   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">/</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">a/C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>,     <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.162ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3165.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(751.2, 0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(1473.4, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1906.4, 0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(2406.4, 0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g></svg></mjx-container>  )    )</p>
<p>将式子简化为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>k</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>k</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>k</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">k_1, k_2, k_3, k_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别对应上方</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.452ex" xmlns="http://www.w3.org/2000/svg" width="44.427ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 19636.5 950"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g><g data-mml-node="mo" transform="translate(1202.3, 0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="msub" transform="translate(2258.1, 0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mstyle" transform="translate(3182.7, 0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(5460.4, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">因</text><text data-variant="normal" transform="translate(900, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">为</text></g><g data-mml-node="msub" transform="translate(7538.2, 0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(8740.5, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msub" transform="translate(9796.3, 0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(10943.1, 0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(11665.3, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mstyle" transform="translate(12098.3, 0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mo" transform="translate(14376.1, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">同</text><text data-variant="normal" transform="translate(900, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">理</text></g><g data-mml-node="msub" transform="translate(16453.9, 0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(17656.2, 0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="msub" transform="translate(18712, 0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g></svg></mjx-container></p>
<p>假设后面的  &gt; 前面的</p>
<p>min = 前面的</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">推</mi><mi mathvariant="normal">出</mi><msub><mi>k</mi><mn>4</mn></msub><mo>&gt;</mo><msub><mi>k</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><msub><mi>k</mi><mn>1</mn></msub><mo>&gt;</mo><msub><mi>k</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">那</mi><mi mathvariant="normal">么</mi><msub><mi>k</mi><mn>4</mn></msub><mo>&gt;</mo><msub><mi>k</mi><mn>1</mn></msub><mo>&gt;</mo><msub><mi>k</mi><mn>2</mn></msub><mo separator="true">,</mo><mspace width="2em"></mspace><mi mathvariant="normal">因</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">另</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">种</mi><mi mathvariant="normal">情</mi><mi mathvariant="normal">况</mi><mi mathvariant="normal">也</mi><mi mathvariant="normal">是</mi><msub><mi>k</mi><mn>4</mn></msub><mo>&gt;</mo><msub><mi>k</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><msub><mi>k</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">因</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">假</mi><mi mathvariant="normal">设</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">条</mi><mi mathvariant="normal">件</mi><mo separator="true">,</mo><msub><mi>k</mi><mn>3</mn></msub><mi mathvariant="normal">不</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">推出k_4 &gt; k_2. 如果k_1&gt;k_2, 那么k_4&gt;k_1&gt;k_2, \qquad 因为前面要小于后面的 所以另一种情况也是 k_4 &gt; k_2. k_3.因为假设的条件, k_3不可能为后面最大的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">推</span><span class="mord cjk_fallback">出</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">么</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:2em;"></span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">另</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">种</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span><span class="mord cjk_fallback">也</span><span class="mord cjk_fallback">是</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">假</span><span class="mord cjk_fallback">设</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">件</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">的</span></span></span></span></p>
<p>那么简化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>4</mn></msub><mo>&gt;</mo><msub><mi>k</mi><mn>2</mn></msub><mi mathvariant="normal">可</mi><mi mathvariant="normal">得</mi><mspace width="2em"></mspace><mi>b</mi><mo>∗</mo><mi>B</mi><mo>&lt;</mo><mi>C</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">k_4&gt;k_2可得\qquad b*B&lt;C*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">得</span><span class="mspace" style="margin-right:2em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>  那么反推当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>∗</mo><mi>B</mi><mo>&lt;</mo><mi>C</mi><mo>∗</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b*B&lt;C*c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>得到  min=前面的</p>
<p>所以，为了ans取到最小值，我们需要将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>∗</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a*A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>较小的放在前面</p>
<h2 id="穷举搜索"><a class="markdownIt-Anchor" href="#穷举搜索"></a> 穷举搜索</h2>
<p>将所有可能性罗列出来, 在其中寻找答案</p>
<h3 id="简化穷举搜索-即动态规化的一种"><a class="markdownIt-Anchor" href="#简化穷举搜索-即动态规化的一种"></a> 简化穷举搜索 ( 即<mark>动态规化的一种</mark> )</h3>
<p>将穷举的情况写着递归树, 检查是否有重复的检查发生, 记录下来, 避免不必要的穷举</p>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20201110183817287.png" class="" title="image-20201110183817287">
<p>–参考&lt;背包问题&gt;</p>
<p>需要反向思考, 一定要选择<mark>知道初始值的</mark>, 一般反向出发. 例子:有n个, <mark>从0个推到n个</mark></p>
<p><mark>dp[ i ] = min( dp[ i+1 ]  - a,  dp[ i+2] - b )</mark></p>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<h4 id="子问题重叠"><a class="markdownIt-Anchor" href="#子问题重叠"></a> 子问题重叠</h4>
<p>每一次解决<strong>相同子问题的解决方案</strong>, 需要使用动态编程. 而子问题的解决方案<strong>早已存储在表中</strong>.</p>
<p>有两种存储方案:</p>
<ol>
<li>记忆化搜索, 自上而下, 分解主问题, 在分解到初始状态时, 记忆其过程.</li>
<li>制表, 自下而上, 从初始状态开始往前推进</li>
</ol>
<h4 id="最优子结构"><a class="markdownIt-Anchor" href="#最优子结构"></a> 最优子结构</h4>
<p>是有<strong>子问题最优解</strong>来获取<strong>当前问题的最优解</strong></p>
<blockquote>
<p>例子: 在最短路径算法中, 起点u到目标节点v的最短路有节点x, 则u到v的最短路可以转化为<strong>u到x的最短路径组合 + x到v的最短路径组合</strong></p>
</blockquote>
<h4 id="解决动态规划步骤"><a class="markdownIt-Anchor" href="#解决动态规划步骤"></a> 解决动态规划步骤</h4>
<ol>
<li>确实是否为DP问题<br>
满足重叠子问题 + 最优子结构</li>
<li>确定带有<strong>最小参数</strong>的状态表达式<br>
一组参数, 可以<strong>唯一</strong>地标识给定问题中的<strong>某个位置或者状态, 或者一个子问题</strong>, 应该<mark>尽可能小</mark>, 减少状态空间</li>
<li>制定状态关系, 递推方程<br>
最难部分, 需要</li>
<li>进行制表或者记忆化</li>
</ol>
<h4 id="区间dp-dp更新从单个元素到单个区间"><a class="markdownIt-Anchor" href="#区间dp-dp更新从单个元素到单个区间"></a> 区间dp, dp更新从单个元素到单个区间</h4>
<p>区间 DP 的特点：</p>
<p><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</p>
<p><strong>特征</strong>：能将问题分解为能两两合并的形式；</p>
<p><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p>
<p>记忆化搜索属于动态规划的<mark>一种</mark>. 但并不是所有.</p>
<p>当前选择会影响<mark>未来的选择</mark>. 但只要<strong>每一次</strong>做出选择时, <mark>基于过去所有情况</mark>做出最好的判断, 那么当未来到来之时, <mark>输出的答案便是最好的</mark>. 动态规划的作用: 就是<strong>优化基于过去所有情况做出最好的判断</strong>这一步骤.</p>
<blockquote>
<p>在每一个阶段都需要作出决策，从而使整个过程达到最优。各个阶段决策的选取<strong>仅依赖当前状态</strong>. 比如有n台无人机规划路线, 第k台无人机的路线是在<strong>第k- 1, k- 2 …1台无人机的路线上</strong>做出决定的.</p>
</blockquote>
<p>类型有:</p>
<ul>
<li>一维dp数组</li>
<li>二维dp数组</li>
</ul>
<p>本质是遍历, 避免重复的寻找.</p>
<p>重点:</p>
<ul>
<li>
<p>动态数组的定义 <mark>二维[ i ] [ j ]  i 和 j 代表含义</mark></p>
</li>
<li>
<p>对于 dp [ i ][ j ] 有可能从哪些状态推出来? 在这些状态里选最值.<br>
一般为 ==dp [ i ][ j ]  与 dp [ i - 1 ][ j ] , dp [ i ][ j - 1 ]==等有一定关系,</p>
</li>
<li>
<p>dp [ i ][ j ] 数组中的值<mark>一般为题目所求</mark></p>
</li>
<li>
<p>还需要知道<mark>递推的规律</mark>, 是从<mark>哪里递推的哪里?</mark>, 递推的方向很重要.</p>
<p>例子: 01背包问题中:  dp [ i ][ j ] 即为当前情况下最大的价值<br>
字符串中问最小操作次数: dp [ i ][ j ] 即为字符串 i , j 时的最小操作次数.</p>
</li>
</ul>
<p>​</p>
<h2 id="暴力枚举"><a class="markdownIt-Anchor" href="#暴力枚举"></a> 暴力枚举</h2>
<p><mark>需要确定, 按照什么顺序去枚举, 位置还是数字?</mark></p>
<p>对于很多题目而言, 题目条件有规律, 除开找到其中玄学规律之外, 我们还可以将<mark>所有情况都列出</mark>然后在其中<strong>依照条件挑选正确答案</strong>.  可以<strong>观察题目数据</strong>, 判断是否适合使用暴力枚举.</p>
<p>题目中需要枚举的东西, 可以<mark>观察是否由枚举中其他量可以确定枚举中另一些变量</mark> 从而简化枚举量</p>
<ul>
<li>排列枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>A</mi><mi>m</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">A^n_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>, 组合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>m</mi><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">C^n_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>, 计算值可以使用 next_permutation, 或者固定一个式子.</li>
<li>循环枚举 一般为两重循环</li>
</ul>
<h2 id="递推方程"><a class="markdownIt-Anchor" href="#递推方程"></a> 递推方程</h2>
<p>递推与动态规划十分密切, 都是<mark>定义状态</mark>, 找到状态转移方程.</p>
<p>可以从从后往前推, F[N]已经完成, F[N] 是由F[ N - 1] or 其他 <mark>如何运算过来或者两者有什么相同的地方</mark>, <mark>不相同的地方可不可以进行特殊处理?</mark> .</p>
<p>先从<mark>最初始的情况分析或者最后的状态分析</mark>, 在看第二个, 或者导数第二个的状态与<strong>对应先前或者之后的状态有什么关联</strong></p>
<p><strong>从题目给的数据范围</strong>可以知道<mark>最初始</mark>状态和<mark>最后</mark>状态</p>
<p>如果最初始状态和第二个状态<mark>不一样</mark>, 比如有<strong>特殊点</strong>之类的, 可以尝试从最初始的状态<mark>添加一些特殊点</mark>, 使得第二个状态可以<mark>分治</mark>为多个第一个状态.</p>
<h2 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h2>
<p>作用:<mark>有序序列中, 根据条件寻找给定的值</mark></p>
<p>作用对应对象一般是<mark>答案</mark>, 而该答案相关的<mark>数值一定是单调的</mark>.</p>
<p>二分查找不单单用于查找, 还可以用于查找<strong>指定范围的最大值</strong>的.</p>
<p>二分搜索模型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = INF;<span class="comment">// 无穷大</span></span><br><span class="line"><span class="keyword">while</span>(right - left &gt; <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>( 满足自定条件Fun)</span><br><span class="line">  {</span><br><span class="line">    right = mid;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    left = mid;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; left;</span><br></pre></td></tr></table></figure>
<ul>
<li>满足自定条件Fun  这个要根据实际题目自定 一般就是翻译符合情况的条件再结合所求进行分析. 一般为模拟, 这个<mark>很重要</mark>, 需要<mark>慎重思考</mark>.</li>
</ul>
<h4 id="最大化最小值"><a class="markdownIt-Anchor" href="#最大化最小值"></a> 最大化最小值</h4>
<p>题目要求的答案范围<mark>需要满足单调性</mark></p>
<p>很多题目会给出条件, 找到满足该条件的<strong>最大值</strong>.</p>
<p>很多时候满足条件的参数有<strong>很多</strong>, 但要找到最大的参数. 这个时候二分搜索就起巨大作用了.</p>
<p>假定参数 x 的初始范围设置为0~INF, 我们要做的就是不断的<strong>缩小 x 的范围</strong>, 从而确定x. 不断从范围中选取<mark>中间值</mark>, 将其<mark>带入条件方程</mark>, 检查是否满足. 根据条件方程的<mark>结果</mark>对范围进行<mark>左或者右</mark>的缩小. 直至满足要求, 输出答案.</p>
<p>例题1 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2440#submit">P2440 木材加工</a>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_SIZE 1000030</span></span><br><span class="line"><span class="comment">// 记录每个木头的长度</span></span><br><span class="line"><span class="keyword">int</span> temper[MAX_SIZE];</span><br><span class="line"><span class="comment">// N是原木数, K是小段数目</span></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断函数 题目要求  木头切割成一些长度相同的小段木头 在所有木头段数一定的情况下, </span></span><br><span class="line"><span class="comment"> * 求出长度最大的解. 这里参数x 就是小木头的长度. 条件是: 每根木头都除以x, 就可知道</span></span><br><span class="line"><span class="comment"> * 这根木头能被分成多少段小木头, 再将其每个木头的求和. 如果 &gt;= 题目要求的段数K, 即满</span></span><br><span class="line"><span class="comment"> * 足要求. 剩下的木头都是剩余的, 题目允许有剩余. 那么在满足该条件下, 利用二分查找, 我们可以求出长度</span></span><br><span class="line"><span class="comment"> * 最大的x, 即题目所求.</span></span><br><span class="line"><span class="comment"> * 木头长度 [0, x] 肯定符合要求, 但是x是最大的, 这才是我们想要的,  (x, 1000000000]都是不符合要求的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// mid表示每一段的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_function</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    {</span><br><span class="line">        total += temper[i] / mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(total &gt;= K)</span><br><span class="line">        <span class="comment">// 按照mid的长度进行切分, 可以满足条件, mid太短了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 按照mid的长度进行切分, 不满足条件, 因为根本分不了 K 段小木头. mid太长了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        cin &gt;&gt; temper[i];</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 初始化 答案的范围  所求的答案x 一定在 left ~ right 之间, 还是有序的 符合二分条件. 小木头的长度不可能超过原木的最大长度 100000000</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; ++i) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        	 	<span class="comment">// 查询是否符合条件</span></span><br><span class="line">        		<span class="comment">// 按照mid的长度进行切分, 不满足条件, mid太长了, 缩小范围</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">my_function</span>(mid))</span><br><span class="line">            {</span><br><span class="line">                right = mid;</span><br><span class="line">            }</span><br><span class="line">          	<span class="comment">// 按照mid的长度进行切分, 满足条件, mid太短了, 扩大范围</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                left = mid;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>例题2<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2678">P2678 跳石头</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_SIZE 50030</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *		条件函数为:</span></span><br><span class="line"><span class="comment"> *				最小的跳跃距离x, 那么意味着所有的跳跃距离都要大于x, </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 距离</span></span><br><span class="line"><span class="keyword">int</span> dist[MAX_SIZE];</span><br><span class="line"><span class="comment">// L起点到终点距离, N是岩石数目, M是可以移走的</span></span><br><span class="line"><span class="keyword">int</span> L, N, M;</span><br><span class="line"><span class="comment">// mid表示最小跳跃距离</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_function</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 上一个石头的距离</span></span><br><span class="line">    <span class="keyword">int</span> last_dist = <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">// 移走的石头数目</span></span><br><span class="line">    <span class="keyword">int</span> move_rock = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历所有石头, 终点石头除外</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果该距离小于最小的跳跃距离, 那么可以选着将该石头移走, </span></span><br><span class="line">        <span class="keyword">while</span> (dist[i] - last_dist &lt; mid)</span><br><span class="line">        {</span><br><span class="line">            ++i;</span><br><span class="line">            ++move_rock;</span><br><span class="line">            <span class="comment">// 跳跃距离太大无法达成, 缩小跳跃距离</span></span><br><span class="line">            <span class="keyword">if</span>(move_rock &gt; M)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        last_dist = dist[i];</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 符合条件, 可增加跳跃距离</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; L &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) {</span><br><span class="line">        cin &gt;&gt; dist[i];</span><br><span class="line">    }</span><br><span class="line">   <span class="comment">// 终点也视为一个石头</span></span><br><span class="line">    dist[N] = L;</span><br><span class="line">   <span class="comment">// 跳跃距离范围 需注意 left = 1,因题目条件L &gt;= 1, right为L, 不可能跳跃距离要超过起点到终点的长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right - left &gt; <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">my_function</span>(mid))</span><br><span class="line">        {</span><br><span class="line">            right = mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            left = mid;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; left;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="前缀和技术-多用于静态"><a class="markdownIt-Anchor" href="#前缀和技术-多用于静态"></a> 前缀和技术 (多用于静态)</h2>
<h4 id="求平均数"><a class="markdownIt-Anchor" href="#求平均数"></a> 求平均数</h4>
<p>可以用数组存储<mark>前n项和</mark>, 那么计算平均数直接除编号</p>
<h4 id="查询连续子序列和"><a class="markdownIt-Anchor" href="#查询连续子序列和"></a> 查询连续子序列和</h4>
<p>下标从0开始</p>
<p>{5, 1, 3, 5, 10, 7, 4, 9, 2, 8}</p>
<p>先算出从0开始的和</p>
<p>sum[i] 表示 [0, i) 之和:</p>
<ul>
<li>sum[1] = 5,   sum[2] = 6,  sum[3] = 9, sum[4] = 14 …</li>
</ul>
<p>求[1, 4)的区间和  等于  <mark>sum[4] - sum[1]</mark> = 14 - 5 = 9 = 1 + 3 + 5</p>
<h2 id="尺取法-双指针法"><a class="markdownIt-Anchor" href="#尺取法-双指针法"></a> 尺取法 双指针法</h2>
<p>一种反复推进区间<mark>开头</mark>以及<mark>结尾</mark>的方法.</p>
<p>作用流程就像一支毛毛虫的爬行</p>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20201126160739998.png" class="" title="image-20201126160739998">
<p>作用范围:</p>
<ol>
<li>求<mark>连续</mark>区间之和</li>
</ol>
<p>例子:</p>
<p>​	{5, 1, 3, 5, 10, 7, 4, 9, 2, 8}</p>
<p>求出总和<mark>不小于</mark>15的<mark>连续</mark>子序列的长度的最小值</p>
<p>实现过程:</p>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20201126160822990.png" class="" title="image-20201126160822990">
<p>理由: 对于一个起点下标为 s, 终点下标为t - 1的序列 [ s, t ) 的总和值 一定小于 [ s, t + 1)的总和值, (在没有负数的情况下).</p>
<p>过程:</p>
<p>起点 s = 0, 终点 t = 0, 最小长度 m = 10 + 1 (数组总长 + 1)</p>
<p>s到t的序列之和sum = 0</p>
<ol>
<li>
<p>先不断的增加t, 直到 sum &gt;= 15; 对应上图第一列;</p>
</li>
<li>
<p>记录当前长度, 比较最小长度 m = min ( m,   t - s)</p>
</li>
<li>
<p>接着 s++, 对应上图第二列</p>
</li>
<li>
<p>重复第一步</p>
</li>
<li>
<p>当sum没办法 &gt; 15时, 结束函数, 如果 m还是 10 + 1. 那说明不存在结果, 否则有结果</p>
</li>
</ol>
<h3 id="开关反转问题"><a class="markdownIt-Anchor" href="#开关反转问题"></a> 开关反转问题</h3>
<p>有一个数列, 操作: 可以选择一个区间, 区间中的0会变成1, 1会变成0, 问<strong>至少</strong>操作几次使得数列全为0.</p>
<p>011100111</p>
<p>考虑暴力枚举或搜索:</p>
<p>状态: 每个数字可为0或者1, 那么状态数有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo separator="true">,</mo><mi>n</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">列</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi></mrow><annotation encoding="application/x-tex">2^n, n为数列长度</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.858832em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span></span></span></span>个, 搜索完成的时间不可接受. 其外<mark>对一个相同的区间反转两次是多余的</mark>( 翻转问题都有的规律 ). 且反转的顺序对结果无影响. 那么问题转化为求<strong>需要被反转的区间集合</strong>. 先考虑最左端的数字, 如果gaishu</p>
<h3 id="lca-二叉树找最近公共祖先"><a class="markdownIt-Anchor" href="#lca-二叉树找最近公共祖先"></a> LCA 二叉树找最近公共祖先</h3>
<p>输入: 两个节点A, B. 找到两者公共祖先</p>
<h4 id="作法1-比较根结点到a-和-到b的路径"><a class="markdownIt-Anchor" href="#作法1-比较根结点到a-和-到b的路径"></a> 作法1 比较根结点到A 和 到B的路径</h4>
<p>前提: 假设节点A, B在树中存在.</p>
<p>找到从根结点到A, B的路径PathA, PathB. 比较PathA, PathB. 返回路径中第一不相同的<strong>前一个</strong>相同的节点( 该节点为公共祖先 ) 时间复杂度, 寻找路径O(n), 比较O(n). 总复杂度O(n).</p>
<p>题目: <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 利用先序遍历查找根结点到节点tar的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findNode</span><span class="params">(TreeNode* node, TreeNode* tar, vector&lt;TreeNode*&gt;&amp;path, <span class="keyword">bool</span> &amp;flag)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        path.<span class="built_in">push_back</span>(node);</span><br><span class="line">        <span class="keyword">if</span>(node == tar){</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">            <span class="built_in">findNode</span>(node-&gt;left, tar, path, flag);</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            <span class="built_in">findNode</span>(node-&gt;right, tar, path, flag);</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">           </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == p &amp;&amp; root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        vector&lt;TreeNode*&gt; pathA, pathB;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">findNode</span>(root, p, pathA, flag);</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">findNode</span>(root, q, pathB, flag);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 比较pathA, pathB</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; pathA.<span class="built_in">size</span>() &amp;&amp; i &lt; pathB.<span class="built_in">size</span>() &amp;&amp; pathA[i] == pathB[i]){</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">// 返回第一个不相同的前一个相同的结点</span></span><br><span class="line">        <span class="keyword">return</span> pathA[i - <span class="number">1</span>];</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<h4 id="作法2-递归作法"><a class="markdownIt-Anchor" href="#作法2-递归作法"></a> 作法2 递归作法</h4>
<p>涉及到树的问题, 多半都可使用<strong>递归</strong>作法. 节点A. B的公共祖先C的<strong>左右子树或者本身</strong>一定包含节点A和节点B. 公共祖先C一定满足以下条件</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mi>l</mi><mi>s</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mi>r</mi><mi>l</mi><mi>s</mi><mi>o</mi><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>=</mo><mo>=</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo>=</mo><mo>=</mo><mi>B</mi><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><mi>f</mi><mi>l</mi><mi>s</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>f</mi><mi>r</mi><mi>s</mi><mi>o</mi><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(flson \&amp;\&amp; rlson)||((x==A||x==B)\&amp;\&amp;(flson||frson))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord">∣</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<blockquote>
<p>flson: true表示左子树中有节点A, 或者B</p>
<p>frson: true表示右子树中有节点A, 或者B</p>
<p>条件: flson &amp;&amp; rlson 表示A, B位于左右子树中</p>
<p>条件: ((x==A||x==B)&amp;&amp;(flson||frson)) 表示A. B可能是该节点 + 另一个节点在左或者右子树中出现.</p>
</blockquote>
<p>上述条件只要是A, B的祖先都满足, 但如果要求深度最大的公共祖先, 只需我们递归的顺序是自上而下就好了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">      	<span class="comment">// 空节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      	<span class="comment">// 如果当前节点为p 或者 q 返回当前节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// left, right的取值只能为 p, q, null. left, right表示左或者右子树中存在p 或者q.</span></span><br><span class="line">        TreeNode* left =  <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="comment">// 左边为空, 只能返回右, 至于右是否为空, 扔回上一层处理.</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">      	<span class="comment">// 确定左边不空的情况下返回左</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> left; </span><br><span class="line">     		<span class="comment">// p和q在两侧</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 必须有返回值</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="数论基础"><a class="markdownIt-Anchor" href="#数论基础"></a> 数论基础</h1>
<h2 id="axby-ga-bxy存在整数解"><a class="markdownIt-Anchor" href="#axby-ga-bxy存在整数解"></a> ax+by = g(a , b)，x,y存在整数解</h2>
<p><strong>gcd(a,b)=1时，存在ax+by=1，x,y存在整数解</strong></p>
<p>即a与b互质时, 方程 ax + by=1, x,y一定存在整数解.</p>
<p>一定存在整数对( x, y )使得 ax+by = gcd(a, b)     gcd(a, b) 为 a , b的最大公约数</p>
<p>比如 4 和 11</p>
<p>11  = 2 * 4 + 3</p>
<p>4 = 1 * 3 + 1</p>
<p>3 = 3 * 1</p>
<p>4 * x + 11 * y = 1</p>
<p>x = 3, y = -1</p>
<h2 id="素数检测"><a class="markdownIt-Anchor" href="#素数检测"></a> 素数检测</h2>
<p>只要检查 2 ~ <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.491ex" xmlns="http://www.w3.org/2000/svg" width="3.287ex" height="2.398ex" role="img" focusable="false" viewBox="0 -843 1453 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msqrt"><g transform="translate(853, 0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(0, -17)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="600" height="60" x="853" y="723"></rect></g></g></g></svg></mjx-container>中的所有整数能否整除n.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(n); i ++){</span><br><span class="line">    <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 1 不是素数</span></span><br><span class="line">  <span class="keyword">return</span> n!=<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="埃式筛法"><a class="markdownIt-Anchor" href="#埃式筛法"></a> 埃式筛法</h3>
<p>负责检查 2~n 以内的素数.</p>
<p>思路如下:</p>
<p>​			先将2 ~ n范围内的整数写出来, 然后最小数字是2, 除2之外, 将所有2的倍数从表中删去, 接着最小数字是3, 将表中所有3的倍数删除.当到达数组末尾时, 表中剩余的数字都是素数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录素数</span></span><br><span class="line"><span class="keyword">int</span> prime[N];</span><br><span class="line"><span class="comment">// 表格 false为未剔除, true为剔除对象</span></span><br><span class="line"><span class="keyword">bool</span> is_prime[N];</span><br><span class="line"><span class="comment">// 返回n以内的所有素数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 索引</span></span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>; i &lt;= n; i++ ){</span><br><span class="line">    <span class="keyword">if</span>(!is_prime[i])</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// 还在数组是素数</span></span><br><span class="line">      prime[p++] = i;</span><br><span class="line">      <span class="comment">// 将该数字的倍数全部删除</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i) is_prime[j] = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h2 id="基本模运算"><a class="markdownIt-Anchor" href="#基本模运算"></a> 基本模运算</h2>
<p>满足结合律</p>
<p>a % m = c</p>
<p>b % m = d</p>
<p>( a + b ) % m = c + d</p>
<p>( a - b ) % m = c - d</p>
<p>( a x b ) % m = c x d</p>
<h3 id="快速幂求法"><a class="markdownIt-Anchor" href="#快速幂求法"></a> 快速幂求法</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mn>22</mn></msup><mo>=</mo><msup><mi>x</mi><mn>16</mn></msup><mo>∗</mo><msup><mi>x</mi><mn>4</mn></msup><mo>∗</mo><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x^{22} = x^{16}*x^{4}*x^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>将 22 二进制化 10110, 利用左移加快运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 为 底数 , n 为指数, mod为取余</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// res表达最终结果</span></span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>){</span><br><span class="line">    <span class="comment">// 如果当前n的第0项为 1 表示 需要进行乘法</span></span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) res = res * x % mod;</span><br><span class="line">    x = x * x % mod;</span><br><span class="line">    <span class="comment">// n进行右移</span></span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当 x = 3, n = 22( 10110 )举例子, mod先不管</p>
<ol>
<li>n % 1 == 0; res = 1; 	x = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">3^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>;  10110 --&gt; 1011</li>
<li>n % 1 == 1; res = 1 * <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">3^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>;     x = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">3^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>; 1011–&gt; 101</li>
<li>n % 1 == 1; res =  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∗</mo><msup><mn>3</mn><mn>2</mn></msup><mo>∗</mo><msup><mn>3</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1*3^2*3^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> ;    x = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">3^{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>;  101–&gt; 10</li>
<li>n % 1 == 0; res = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∗</mo><msup><mn>3</mn><mn>2</mn></msup><mo>∗</mo><msup><mn>3</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">1*3^2*3^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> ;  x = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">3^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>; 10–&gt; 1</li>
<li>n % 1 == 1; res = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∗</mo><msup><mn>3</mn><mn>2</mn></msup><mo>∗</mo><msup><mn>3</mn><mn>4</mn></msup><mo>∗</mo><msup><mn>3</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">1*3^2*3^4*3^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> ;  x = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">3^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>; 1 --&gt; 0</li>
</ol>
<h1 id="常用算法"><a class="markdownIt-Anchor" href="#常用算法"></a> 常用算法</h1>
<h2 id="动态规划中的状态压缩"><a class="markdownIt-Anchor" href="#动态规划中的状态压缩"></a> 动态规划中的状态压缩</h2>
<p>假设列出的dp数组中</p>
<p>dp[ S ][ v ]: 从v出发访问剩余的所有顶点, 最终回到顶点的路径的<mark>权重总和</mark>的最小值.</p>
<blockquote>
<p>S: 已经访问过的顶点的集合.</p>
<p>v: 当前顶点</p>
</blockquote>
<p>S是一个集合, 并非一个整数, 所以不能直接使用常数去表示集合S, 但我们可以利用<mark>编码成一个整数</mark>, 用二进制位的0和1表示S集合中的边哪些已经被访问( 对应二进制位为1, 表示已经访问过 ), 无需使用bool数组.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示访问过</span></span><br><span class="line"><span class="comment">// S为已经访问过的顶点集合, u为当前访问的节点, 标记该位置已经被访问过</span></span><br><span class="line">S | <span class="number">1</span> &lt;&lt; u;</span><br><span class="line"><span class="comment">// 表示S中u对应的位置, 变成1.  1|1 = 1, 1|0 = 1, 0|0 = 0;</span></span><br><span class="line"><span class="comment">// 检测对应的u位, 是否为1, 为1表示访问过, 即对应u位为1. </span></span><br><span class="line">S &gt;&gt; u &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="dfs深度搜索"><a class="markdownIt-Anchor" href="#dfs深度搜索"></a> DFS深度搜索</h2>
<p>不一定用在图中, <mark>经常用于穷举</mark></p>
<p>定义: 从某个状态开始, <mark>不断的前进, 直到无法前进</mark>, 退回上一步, 换一个方向, 继续前进, 直到所有方向都走过</p>
<p>实现: 常用递归函数实现</p>
<h2 id="图"><a class="markdownIt-Anchor" href="#图"></a> 图</h2>
<h3 id="表示方法"><a class="markdownIt-Anchor" href="#表示方法"></a> 表示方法</h3>
<p>邻接矩阵太费内存, 不过操作简单高效( 不过如果图的点较多,而边少, 那么会因为访问太多无用的边导致花费大量时间).</p>
<p>多用邻接表表示: (一般是存出度)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edgs</span></span></span><br><span class="line"><span class="class">{</span> </span><br><span class="line">  <span class="comment">// 权重</span></span><br><span class="line">  <span class="keyword">int</span> weight;</span><br><span class="line">  <span class="comment">// 终点</span></span><br><span class="line">  <span class="keyword">int</span> node;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 构建一个vector数组    [i] 表示起点为结点i的边</span></span><br><span class="line">vector&lt;*edge&gt; G[MAX_V];</span><br><span class="line"></span><br><span class="line">cin &lt;&lt; start &lt;&lt; end &lt;&lt; weight;</span><br><span class="line"></span><br><span class="line">G[start].<span class="built_in">push_back</span>(t);</span><br><span class="line"><span class="comment">// 无向图需两边添加</span></span><br><span class="line">G[end].<span class="built_in">push_back</span>(start);</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>使用邻接表很难找到入度</p>
<p>所以在存储边集时, 同时存下逆邻接表, 存入度</p>
<h3 id="最短路径算法"><a class="markdownIt-Anchor" href="#最短路径算法"></a> 最短路径算法</h3>
<h4 id="两点间最短路径"><a class="markdownIt-Anchor" href="#两点间最短路径"></a> 两点间最短路径</h4>
<p>一般情况: 简单无向图(无环, 无重边), <mark>权值为正值</mark>.</p>
<h5 id="bellman_ford算法"><a class="markdownIt-Anchor" href="#bellman_ford算法"></a> Bellman_Ford算法</h5>
<p>适用范围</p>
<ul>
<li>从出发点到各个节点最短路径, 哪怕图中存在<mark>负权重</mark></li>
<li>图中是否有<mark>负环路</mark>( 如果存在负环路, 最短路径会变成负无穷, 每走一次负环路, 路径都有减少  )</li>
<li>A是否可到达各个节点</li>
</ul>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20201117200318813.png" class="" title="image-20201117200318813">
<p>时间复杂度是 O( E * V ) = O ( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> )</p>
<p>边数 * 点数</p>
<p>思路: <mark>动态规划范式</mark></p>
<p>n: 节点总数</p>
<p>v: 边总数</p>
<p>dist[v]:  s 到 v 点需要花费总权重</p>
<p>weight(ab): 表示 a-&gt;b 的权重</p>
<ol>
<li>
<p>dist数组设置<strong>全部初始化负无穷</strong>, 然后 dist( s -&gt; s) = 0,</p>
</li>
<li>
<p>最多n - 1次遍历</p>
<p>对每一条边进行遍历 ( 双重for ) ( 至于按照什么顺序边都ok )<br>
如果发现 <mark>dist[ a ] + weight(ab) &lt; dist[ b ]</mark>     ( 直接到达节点b所花费的权重, <strong>大于</strong>先到a点在到b点的总权重. )</p>
<p>则更新 dist[ b ] = dist[ a ] + weight[ b ]</p>
</li>
<li>
<p>如果发现上述操作中, 遍历并没有更新 dist 数组 表明已经达成最短路径而且没有负环路, 可直接退出.</p>
</li>
<li>
<p>完成对所有节点遍历后, 可以再进行上诉操作( 也是 n * v), 如果发现还能更新dist[ i ]数值,证明存在负环路.  为什么? <mark>我所有情况都枚举过一次, 如果dist值还可以变少, 说明dist可以无限的减少, 也说明存在负环路</mark></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_G 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>{</span></span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> in_start, <span class="keyword">int</span> in_end, <span class="keyword">int</span> in_weight){</span><br><span class="line">        start = in_start;</span><br><span class="line">        end = in_end;</span><br><span class="line">        weight = in_weight;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bellman_Ford算法, O(n^2)</span></span><br><span class="line"><span class="comment"> * @param start     起点</span></span><br><span class="line"><span class="comment"> * @param end       终点</span></span><br><span class="line"><span class="comment"> * @return          最短路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bellman_Ford</span><span class="params">(vector&lt;struct edge*&gt; G[], vector&lt;struct edge*&gt;&amp; edges, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> G_number)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 如果对所有边遍历一次 都没有发生数值交换则直接退出并且不存在负环路</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//  起点start 到 i 点需要花费最小总权重</span></span><br><span class="line">    <span class="keyword">int</span> dist[G_number + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化dist</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i: dist)</span><br><span class="line">        i = INT_MAX;</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 进行点遍历 只需遍历 n - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; G-&gt;<span class="built_in">size</span>(); ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 对边进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> item : edges)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果发现 对边 a--&gt;b </span></span><br><span class="line">           <span class="comment">//  发生 dist[a] + weight(ab) &lt; dist[b] 说明 直接到b的权重要大于先从a出发再到b的权重 dist[b]无非两种可能, 一种: start直接到b, 第二种: 从非start点再到b</span></span><br><span class="line">            <span class="keyword">if</span>(dist[item-&gt;start] + item-&gt;weight &lt; dist[item-&gt;end])</span><br><span class="line">            {</span><br><span class="line">                dist[item-&gt;end] = dist[item-&gt;start] + item-&gt;weight;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dist[end];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> number_Edges = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 图 邻接表实现</span></span><br><span class="line">    vector&lt;struct edge*&gt; G[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 边 记录</span></span><br><span class="line">    vector &lt;struct edge*&gt; E;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start, end, weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_Edges; ++i) {</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end &gt;&gt;weight;</span><br><span class="line">        <span class="comment">// 邻接表</span></span><br><span class="line">        G[start].<span class="built_in">push_back</span>(<span class="keyword">new</span> struct <span class="built_in">edge</span>(start, end, weight));</span><br><span class="line">        G[end].<span class="built_in">push_back</span>(<span class="keyword">new</span> struct <span class="built_in">edge</span>(start, end, weight));</span><br><span class="line">        <span class="comment">// 无向图 只需记录其中一条边</span></span><br><span class="line">        E.<span class="built_in">push_back</span>(<span class="keyword">new</span> struct <span class="built_in">edge</span>(start, end, weight));</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Bellman_Ford</span>(G, E, <span class="number">0</span>, <span class="number">4</span>, number_Edges);</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="dijkstra算法"><a class="markdownIt-Anchor" href="#dijkstra算法"></a> Dijkstra算法</h5>
<p>对每一个结点x 到 起点a的距离, 只有两种可能, 一种: a直接到达, 另一种: 其他结点o到起点a的距离 + o到x的距离.</p>
<p>dist[x] = min( a–&gt;x的距离, <strong>for(x的邻居<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>)</strong>:  dist[<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>] + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>–&gt;x的距离,  dist[x]  )</p>
<p>通常 a–&gt;x的距离 这一项, 会在初始化完成, 在以后的比较中无需考虑该项. 保证该式成立的条件是, <mark>x的邻居</mark>  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> <mark>的dist值 都已经确定</mark></p>
<p>递推式子: dist[x] = min(  <strong>for(x的邻居<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>)</strong>:  dist[<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>] + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">y_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>–&gt;x的距离,  dist[x]  )</p>
<p>松弛操作: dist初始化完成后, 由于有新的点c加入到 <mark>最短路径</mark>生成树中, 对于尚未在生成树中的结点, 新加需要考虑的边, 就是 关联 c 的所有边( 除开c连接到树中的边 ).</p>
<p>计算一个结点到其他结点的最短路径</p>
<p>核心思想: <mark>贪心算法, BFS</mark><br>
距离: 即到达起点的距离</p>
<p>将图的结点, 分成两部分, 一部分是最短距离已经确定的顶点集A, 一部分是不确定的B. 每一次都是从B中拿一个<mark>到起点A距离最小的路径</mark>的顶点c, 将其拉入到A中. 然后更新B中的值( 其实<strong>只需要更新c的邻居</strong>的距离 )</p>
<p>适用范围:</p>
<ul>
<li>权值不可为负数, 如果为负数, 大概率计算出错, 下面的版本会无限循环.</li>
</ul>
<p>声明两个数组</p>
<p>dist[ i ]: 记录 起点到 i 点的最短距离</p>
<p>visit[ i ]: 记录 i 是否已经确定最短路径( 记录i是否被当做扩展起点 是ture, 否false )</p>
<p>dijkstra算法默认：一个节点对另一个节点的单向边是肯定增加 / 不变权重的，这就是为什么算法会对已经【找过邻居】的节点，不再重复寻找</p>
<p>步骤:</p>
<ol>
<li>找到<strong>最短路径已经确定</strong>的顶点, 从它出发更新相邻顶点的最短距离</li>
<li>不需要再检查<strong>最短路径已经确定</strong>的顶点</li>
</ol>
<p><mark>最短距离已经确定的顶点一定是dist数组中最小的, 因为不存在负数, 如果dist[ i ]已经是最小的, 那么在之后更新不会变小</mark></p>
<blockquote>
<p>Dist[ i ] 只可能从 顶点 dist [ i 的邻居] + 到 i 的边的权重. 在非负数的情况下,  dist[ i ] + 一个非负数 可能会小于 dist[ i 的邻居 ] 吗? 不可能, 也就说<mark>如果dist[ i ]已经是最小的, 那么在之后更新不会变小</mark></p>
</blockquote>
<p>初始化:</p>
<ul>
<li>
<p>dist 全为<strong>无穷大</strong>, 并dist[ 起点 ] = 0;</p>
</li>
<li>
<p>visit数组初始化全为false</p>
</li>
</ul>
<p>例子: 以A为起点, G为终点</p>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20201118101857272.png" class="" title="image-20201118101857272">
<ol>
<li>
<p>第一轮:</p>
<p>第一个最短距离已经确定的顶点是起点**dist[ A ] = 0 **, 从A出发更新dist的值, 分别将dist[ B ] 从 无穷大 -&gt; 2 , dist[ C ] 从无穷大 -&gt; 5. 此时 visit[ A ] 已经true.</p>
</li>
<li>
<p>第二轮:<br>
当前dist数组中最小的是B, 以B结点出发访问 B的邻居 且 对应visit中为false. 如果dist[B] + weight [B] [n] &lt; dist[ n ], 更新dist[ n ]的值</p>
</li>
<li>
<p>第三轮:<br>
当前dist数组 (除去A, B)   dist[ C ] = 5, dist[ D ] = 8, …</p>
</li>
<li>
<p>直到visit数组全为true</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dijkstra最小路径算法, 时间复杂度O(E|log|v||)</span></span><br><span class="line"><span class="comment"> * @param G         图的id一定要连续, 而且权值一定为非负数</span></span><br><span class="line"><span class="comment"> * @param start</span></span><br><span class="line"><span class="comment"> * @param end</span></span><br><span class="line"><span class="comment"> * @param G_number  点的个数</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">(vector&lt;struct edge*&gt; G[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> G_number)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> dist[G_number + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先队列实现</span></span><br><span class="line">    priority_queue&lt;struct distance*, vector&lt;struct distance*&gt;, compare&gt;  que;</span><br><span class="line">    <span class="comment">// 初始化dist   memset赋值范围 == 无符号char</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, CHAR_MAX, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将起点推入堆中</span></span><br><span class="line">    que.<span class="built_in">push</span>(<span class="keyword">new</span> struct <span class="built_in">distance</span>(start, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 利用堆找到最短距离已经确定的顶点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">distance</span>* <span class="title">tmp</span> =</span> que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 如果从 堆中出现顶点的最短距离 比 dist数组中要大, 说明该顶点已经是被访问过而且最短路径已经确定, 省略visit数组, 如果有负数会陷入死循环</span></span><br><span class="line">        <span class="keyword">if</span>(dist[tmp-&gt;end] &lt; tmp-&gt;dist)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 以该顶点更新dist的值, 访问其邻居</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge: G[tmp-&gt;end])</span><br><span class="line">        {</span><br><span class="line">           <span class="comment">// 防止重复的插入</span></span><br><span class="line">           <span class="keyword">if</span>(dist[edge-&gt;end] &gt; dist[tmp-&gt;end] + edge-&gt;weight)</span><br><span class="line">           {</span><br><span class="line">               dist[edge-&gt;end] = dist[tmp-&gt;end] + edge-&gt;weight;</span><br><span class="line">               que.<span class="built_in">push</span>(<span class="keyword">new</span> struct  <span class="built_in">distance</span>(edge-&gt;end, dist[edge-&gt;end]));</span><br><span class="line">           }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dist[end];</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="comment">// 要初始化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_SIZE 1501</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">distance</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> point;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> len;</span><br><span class="line">}dist[MAX_SIZE];</span><br><span class="line"><span class="keyword">bool</span> is_visit[MAX_SIZE];</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; adj[MAX_SIZE];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(struct distance x, struct distance y)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> x.len &lt; y.len;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}cmp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用DJ算法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路 : 从起点出发, 利用dist数组, 从当前堆 提取出 dist 中最小值, 更新其邻居并放入堆中</span></span><br><span class="line"><span class="comment"> * 或者从 上一个dist中找最小值, 然后dist</span></span><br><span class="line"><span class="comment"> * @param now</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dj</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">        dist[i].len = INT_MAX;</span><br><span class="line">        dist[i].point = i;</span><br><span class="line">    }</span><br><span class="line">    priority_queue&lt;struct distance, vector&lt;struct distance&gt;, Cmp&gt; heap;</span><br><span class="line">    dist[<span class="number">1</span>].point = <span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">1</span>].len = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(dist[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">distance</span> <span class="title">tmp</span>{</span>};</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">        tmp = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 如果该点的距离已经确定则无需更新, 防循环</span></span><br><span class="line">        <span class="keyword">if</span>(is_visit[tmp.point])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            is_visit[tmp.point] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新邻居</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edg: adj[tmp.point])</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">// 三角形法则, 检查是直接到的距离短 还是 绕另一个结点的短</span></span><br><span class="line">            dist[edg.first].len = <span class="built_in">min</span>(dist[edg.first].len, edg.second + tmp.len);</span><br><span class="line">            heap.<span class="built_in">push</span>(dist[edg.first]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h4>
<p>拓扑排序: 我们需要先做一些事情, 才能做另一些事情, 要按照<mark>一定顺序</mark>进行.</p>
<p>求做事顺序.</p>
<p>使用范围: <strong>有向无环图</strong></p>
<h3 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h3>
<p>给定一幅<mark>权值图</mark>. 找出<mark>连通所有节点的边中权值之和最小</mark>的方案, 把图变成树.</p>
<h4 id="prim算法"><a class="markdownIt-Anchor" href="#prim算法"></a> Prim算法</h4>
<p>加点法.</p>
<p>与Dijkstra算法很相似:</p>
<p>从某个节点出发, 每次都从当前生成树中的所有顶点里, 观察其中最小的权值的边, 如果边的端点并不在树中, 将其并入生成树中. 否则看下一条边</p>
<p>任意选定一个节点, 将该节点的所有边都放入最小堆中. <mark>把该点放入生成树中( bool数组标记true ),  然后弹出堆顶, 查看该边的另一个节点是否在生成树中</mark>, 在就跳过, 不在, 就将其该结点代替上述结点重复操作. 直至所有边都在生成树中 ( 代替操作是二叉堆空, 但当二叉堆非空时, 可能生成树已经完成, 但因为bool数组中节点全为true, 出堆也不会改变树的结构 )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 输入: n 为节点数量, m为边的总数</span></span><br><span class="line"><span class="comment">// start end 权值 * m 行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否在生成树中</span></span><br><span class="line"><span class="keyword">bool</span> isVisit[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">// [i]: 表示第i个节点到生成树的最小距离</span></span><br><span class="line"><span class="keyword">int</span> minDist[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 图, 使用邻接表表示  pair.first = 值, pair,second = 节点</span></span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">matrix</span>(n+<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) {</span><br><span class="line">        <span class="keyword">int</span> dist, start, end;</span><br><span class="line">        cin &gt;&gt; start &gt;&gt; end &gt;&gt; dist;</span><br><span class="line">        matrix[start].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dist, end));</span><br><span class="line">        matrix[end].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dist, start));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">        minDist[i] = INT_MAX;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 以1为起点</span></span><br><span class="line">    minDist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    isVisit[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;item : matrix[<span class="number">1</span>]) {</span><br><span class="line">        minDist[item.first] = item.second;</span><br><span class="line">        heap.<span class="built_in">push</span>(item);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始遍历</span></span><br><span class="line">    <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>()){</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(isVisit[tmp.second])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 放入生成树中</span></span><br><span class="line">        isVisit[tmp.second] = <span class="literal">true</span>;</span><br><span class="line">        cost += tmp.first;</span><br><span class="line">        <span class="comment">// 更新tp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item: matrix[tmp.second]) {</span><br><span class="line">            <span class="keyword">if</span>(isVisit[item.second])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            minDist[item.second] = <span class="built_in">min</span>(minDist[item.second], item.first);</span><br><span class="line">            heap.<span class="built_in">push</span>(item);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">        <span class="keyword">if</span>(!isVisit[i]){</span><br><span class="line">            cout &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; cost;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="kruskal算法"><a class="markdownIt-Anchor" href="#kruskal算法"></a> Kruskal算法</h4>
<p>先将所有的边, 按照权重升序排序, 遍历边集数组, 如果当前边的端点不在生成树中, 将其合并. 直到边遍历完或者所有顶点已经并入到生成树中.</p>
<h2 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h2>
<h3 id="核心"><a class="markdownIt-Anchor" href="#核心"></a> 核心</h3>
<p>用区间来表示数, (夹逼 求数组array第4个数, 通过下标[4] 或者区间[4, 4]来找到目标内容)<br>
将大的区间分解为两个小的区间[a, b] <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, \frac{a+b}{2}], [\frac{a+b}{2}+1, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span></p>
<h3 id="适用范围"><a class="markdownIt-Anchor" href="#适用范围"></a> 适用范围</h3>
<p>一个数组连续的子数组操作.</p>
<blockquote>
<p>例子:索引	 [  1,   2,  3,  4,  5 ]<br>
内容	 [  1,   5,  4,  2,  3 ]</p>
<p>要求:</p>
<ol>
<li>求索引[2, 4]之间的数字之和   5 + 4 + 2 = 11</li>
<li>对索引[2, 3]之间的数字全部加2  内容[1, 7, 6,  2, 3]</li>
</ol>
</blockquote>
<p>朴素办法: 直接遍历数组进行操作. 求和的时间复杂度为O(n), 加也是O(n)<br>
线段树: 可以使上诉操作时间复杂度都变成O(logn)   <mark>树</mark>操作</p>
<p>线段树图示</p>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20210129103802932.png" class="" title="image-20210129103802932">
<h4 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质:</h4>
<ol>
<li>
<p>一定是一颗正则完全二叉树, 与哈夫曼树类似( 说明树的存储结构可以用数组存储)</p>
</li>
<li>
<p>叶子数目 = 数组长度</p>
</li>
<li>
<p>数组长度为n, 那么树的结点数目为 x = 2n - 1</p>
<blockquote>
<p>叶子有n个, 假设有x个结点, 根据握手定理: n + 3(x - n) - 1 [根结点度为2] = 2(x - 1)<br>
解得 x = 2n - 1</p>
</blockquote>
</li>
</ol>
<h4 id="建立"><a class="markdownIt-Anchor" href="#建立"></a> 建立</h4>
<p>将大的区间分解为两个小的区间[a, b] <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">⇒</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[a, \frac{a+b}{2}], [\frac{a+b}{2}+1, b]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">]</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用递归建立, 完全二叉树采用数组d存储, 数组a则是输入数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>{</span><br><span class="line">    <span class="comment">// 对 [s,t] 区间建立线段树,建立树的节点编号为 p</span></span><br><span class="line">    <span class="keyword">if</span> (s == t) {</span><br><span class="line">        d[p] = a[s];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> m = (s + t) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(s, m, p * <span class="number">2</span>), <span class="built_in">build</span>(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归对左右区间建树</span></span><br><span class="line">    d[p] = d[p * <span class="number">2</span>] + d[(p * <span class="number">2</span>) + <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="修改区间"><a class="markdownIt-Anchor" href="#修改区间"></a> 修改区间</h4>
<p>若要修改区间中值, 采用<strong>懒惰标记</strong>. 即不必修改所有关联的结点, 只修改需要访问的区间, 当要访问区间时, 才进行修改.</p>
<p>原图</p>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20210129152930460.png" class="" title="image-20210129152930460">
<p>进行修改</p>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20210129155102180.png" class="" title="image-20210129155102180">
<p>按照道理, 其余节点也要更改, 但因为此时尚未访问其他节点, 所以我们先不用更新, 只需要当访问父亲节点是, 根据父亲节点的<strong>懒惰标记( 对区间中所有数进行加减或乘除的数字 )</strong>, 更新节点的值.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [l,r] 为修改区间,c 为被修改的元素的变化量, [s,t]为当前节点包含的区间,</span></span><br><span class="line"><span class="comment">// p为当前节点的编号</span></span><br><span class="line"><span class="comment">// d[p]: 表示第p个区间的数字之和</span></span><br><span class="line"><span class="comment">// b[p]: 表示第p个区间的懒惰标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>{</span><br><span class="line">	<span class="comment">// 当当前区间包含修改区间时, 设立懒惰标记, 并修改区间之和的数值</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) {</span><br><span class="line">    d[p] += (t - s + <span class="number">1</span>) * c, b[p] += c;<span class="comment">// 注意是+= 懒惰标记即为被修改的元素变化量</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }  </span><br><span class="line">  <span class="comment">// 用于区分左孩子的区间, 右孩子的区间 </span></span><br><span class="line">  <span class="keyword">int</span> m = (s + t) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (b[p] &amp;&amp; s != t) {</span><br><span class="line">    <span class="comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">    d[p * <span class="number">2</span>] += b[p] * (m - s + <span class="number">1</span>);</span><br><span class="line">    d[p * <span class="number">2</span> + <span class="number">1</span>] += b[p] * (t - m);</span><br><span class="line">    <span class="comment">// 将标记下传给子节点 注意是+=, 防止覆盖先前的懒惰标签</span></span><br><span class="line">    b[p * <span class="number">2</span>] += b[p];</span><br><span class="line">    b[p * <span class="number">2</span> + <span class="number">1</span>] += b[p];  </span><br><span class="line">    <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">    b[p] = <span class="number">0</span>;                                </span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 递归修改自己的左右区间 当待修改的最小范围要大于左孩子的最大区间时, 便不用访问</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) <span class="built_in">update</span>(l, r, c, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) <span class="built_in">update</span>(l, r, c, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 由于左右孩子发生更新, 需要更新自身</span></span><br><span class="line">  d[p] = d[p * <span class="number">2</span>] + d[p * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="区间求和"><a class="markdownIt-Anchor" href="#区间求和"></a> 区间求和</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [l,r] 为查询区间,[s,t] 为当前节点包含的区间,p为当前节点的编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>{</span><br><span class="line">	<span class="comment">// 当前区间为询问区间的子集时直接返回当前区间的和</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">  <span class="keyword">int</span> m = (s + t) / <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据懒惰标记,进行更新</span></span><br><span class="line">  <span class="keyword">if</span> (b[p]) {</span><br><span class="line">    <span class="comment">// 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值</span></span><br><span class="line">    d[p * <span class="number">2</span>] += b[p] * (m - s + <span class="number">1</span>), d[p * <span class="number">2</span> + <span class="number">1</span>] += b[p] * (t - m);</span><br><span class="line">    <span class="comment">// 将标记下传给子节点</span></span><br><span class="line">    b[p * <span class="number">2</span>] += b[p], b[p * <span class="number">2</span> + <span class="number">1</span>] += b[p]; </span><br><span class="line">    <span class="comment">// 清空当前节点的标记</span></span><br><span class="line">    b[p] = <span class="number">0</span>;                                    </span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 记录区间之和 </span></span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= m) sum = <span class="built_in">getsum</span>(l, r, s, m, p * <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span>(l, r, m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="树状数组"><a class="markdownIt-Anchor" href="#树状数组"></a> 树状数组</h2>
<p>优化数组中<mark>区间查询</mark>和单次修改的时间复杂度</p>
<ul>
<li>
<p>修改一个数组中的数值:</p>
<p>一般作法: O(n) 需要遍历一遍, 才能进行修改</p>
<p>树状数组: O(logn) 优化遍历过程.( 顺便处理区间查询的保存的结果 )</p>
</li>
<li>
<p>区间查询:</p>
<p>一般作法: O(n) 找到区间的所有数字后进行操作</p>
<p>树状数组: O(logn) 事先存储区间的结果. 但是<mark>仅能查询[ 0, i ]的数值</mark></p>
</li>
</ul>
<p>作用: 在 时间复杂度O(nlogn)的情况下计算区间合值. 与线段树类似, 快速处理关于区间的数值<br>
长度: n原数组长度</p>
<p>原数组:<br>
[1, 2, 3, 4, 5, 6, 7, 8]</p>
<h4 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h4>
<p>树状数组[0, 0, 0, 0, 0, 0, 0, 0] tree</p>
<h4 id="求数字k二进制下第一出现1的数值-lowbit"><a class="markdownIt-Anchor" href="#求数字k二进制下第一出现1的数值-lowbit"></a> 求数字k二进制下第一出现1的数值 lowbit</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// 负数补码表示, 为反码+1, &amp;操作是仅有1&amp;1=1, 其余组合为0</span></span><br><span class="line">  <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="更新"><a class="markdownIt-Anchor" href="#更新"></a> 更新</h4>
<p>当第i个元素发生变化时, 需要修改树状数组 [ i ], [ i + lowbit( i ) ], [ k + lowbit( k ) ] (k = i + lowbit(i)) … 这些位置统统加上原数组[ i ]的数值</p>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20210131221201806.png" class="" title="image-20210131221201806">
<blockquote>
<p>例子: 更新第 1 个元素. 更新位置1,tree[1, 0, 0, 0, 0, 0, 0, 0]. 更新位置 2 = 0010 = 0001 + 0001 , tree[1, 1, 0, 0, 0, 0, 0, 0]. 更新位置4 = 0100 = 0010 + 0010.  tree[1, 1, 1, 0, 0, 0, 0, 0]. 以此类推.<br>
上图为下标从1到n 更新完毕的样子. (下标从1出发)</p>
</blockquote>
<table>
<thead>
<tr>
<th>十进制</th>
<th>1</th>
<th>2</th>
<th>4</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制</td>
<td>0001</td>
<td>0010</td>
<td>0100</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>特点: 每个节点的值 = 自身左右孩子值之和 (若不存在则为0)+ 当前数组索引的值</p>
<p>区间[0~3]的合值, 对应树状数组节点d的值. 但显然, 区间[0~2]的合值, 其对应节点的值不等于3, 应该为7. 所以求合值, 显然是需要经过一些处理的.</p>
<h4 id="询问合值"><a class="markdownIt-Anchor" href="#询问合值"></a> 询问合值</h4>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20210131220227060.png" class="" title="image-20210131220227060">
<blockquote>
<p>求区间[0~7]合值, 其对应节点的位置值为7. 但真实值应该 7 + 节点6的值 + 节点4的值 = 7 + 10 + 11 = 28.</p>
</blockquote>
<p>观察可得, 节点7 + 节点6 + 节点4的值 = [0, 7]的和</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>4</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制</td>
<td>0100</td>
<td>0110</td>
<td>0111</td>
</tr>
</tbody>
</table>
<p>节点6 = 节点7 - 节点7二进制第一次出现1的数值 = 0110 = 0111 - 0001</p>
<p>节点4 = 节点6 - 6二进制第一次出现1的数值 = 0100 = 0110 - 0010</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeNums 用于快速求解区间操作, 比如求区间最大值, 区间极值...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNums</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> numbers[<span class="number">100</span>]{};</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *tar;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> x &amp;( -x);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> indexes)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> tmp = indexes;</span><br><span class="line">        <span class="keyword">while</span>(indexes &lt;= len)</span><br><span class="line">        {</span><br><span class="line">            numbers[indexes] += tar[tmp];</span><br><span class="line">            indexes += <span class="built_in">lowBit</span>(indexes);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 返回[0, indexes]区间的合值 如何知晓(indexes, n]的合值呢? [0, n] - [0, indexes]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> indexes)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">int</span> tmp = indexes;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (indexes &gt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            sum += numbers[indexes];</span><br><span class="line">            indexes -= <span class="built_in">lowBit</span>(indexes);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// nums下标需从1开始</span></span><br><span class="line">    <span class="built_in">TreeNums</span>(<span class="keyword">const</span> <span class="keyword">int</span> *nums, <span class="keyword">int</span> n):<span class="built_in">tar</span>(nums),<span class="built_in">len</span>(n){</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) {</span><br><span class="line">            <span class="built_in">update</span>(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>树状数组是处理数组的区间问题,</p>
<h4 id="树状数组与线段树"><a class="markdownIt-Anchor" href="#树状数组与线段树"></a> 树状数组与线段树</h4>
<p>线段树: 在O( logn )区间查询, 区间修改. 较为复杂<br>
树状数组: 代码简单, 也能在O(logn)实现区间查询, 但区间修改依然要O(n).</p>
<h1 id="常见技巧"><a class="markdownIt-Anchor" href="#常见技巧"></a> 常见技巧</h1>
<h2 id="区间问题"><a class="markdownIt-Anchor" href="#区间问题"></a> 区间问题</h2>
<p>即当要考虑两端时, 不妨仅考虑一端, 或者将其统一一视同仁.</p>
<h2 id="比较"><a class="markdownIt-Anchor" href="#比较"></a> 比较</h2>
<p>在不破坏数据逻辑结构的情况下, 可以<strong>当做有两个数据</strong>, 用着两个数据比较相同和不同.</p>
<blockquote>
<p>比较一棵树中的各个节点值大小, 那就当做有两棵一模一样的树.</p>
</blockquote>
<h2 id="检查链表是否存在环并返回该环的起始点"><a class="markdownIt-Anchor" href="#检查链表是否存在环并返回该环的起始点"></a> 检查链表是否存在环并返回该环的起始点</h2>
<p>可以使用一个只走1步的指针, 以及一个只走2步的指针. 如果存在环, 这两个指针一定会相遇.</p>
<p>假设 2步指针位置为 x  + 2直接跨过 1步指针 位置为 x + 1. 那么上一个2步指针的位置为x, 上一个1步指针的位置为1. <strong>反证</strong>可得出如果有环. 两个指针一定会相遇.</p>
<p>现在<mark>假设 1走了k步后</mark>,  2走了2k步. 1位于<mark>环路起点</mark>. 现在2已经在环里走 k步了. 离环路起点( 即1步目前的节点 ) k % loop_size个<strong>节点</strong>.</p>
<p>由于2总是比1快1步, 所以2相对于1而言, 可以视作是1不动, 2走一步. 那么只需要再走 loop_size - k % loop_size步, 2与1就会相遇. 相遇的节点位置<mark>离环的起始点</mark> loop_size - k % loop_size个节点. 从遇见点再走 loop_size - ( loop_size - k % loop_size (即相遇点的距环起始点的距离)) = k % loop_size 就又走回起始点. <mark>其实相遇点走 k 步的结果 == 走 k % loop_size 的结果, 多走几圈罢了</mark>. 而这恰巧等于从<strong>链表出发点到环起始点的距离</strong>.</p>
<p>这时, 从链表的起始点m出发, 相遇点n出发,  当m与n相遇时, 便是环的起始点.</p>
<h2 id="栈的妙用"><a class="markdownIt-Anchor" href="#栈的妙用"></a> 栈的妙用</h2>
<h3 id="利用栈可以倒转访问顺序"><a class="markdownIt-Anchor" href="#利用栈可以倒转访问顺序"></a> 利用栈可以倒转访问顺序</h3>
<p>如果题目涉及倒转, 可以先将组内所有元素压入栈中, 逆序访问: 一次次的<mark>弹出栈顶</mark>即可</p>
<h3 id="带最小值的栈"><a class="markdownIt-Anchor" href="#带最小值的栈"></a> 带最小值的栈</h3>
<p>问题: 实现一个栈, 而且能够在O(1)的时间内找到栈中所有元素的<strong>最小值</strong> .<br>
解法:  只需当前入栈的节点都<mark>保存出基于当前栈里的最小值</mark>即可.<br>
原理: 对一个栈中任意位置的元素, 访问他的最小值, 只需考虑==[他~栈底] 之间的元素即可]==. 每次进栈, 如果当前入栈值要小于最小值, 就直接更换最小值即可. 那么当访问栈最小值时, 只需要访问<strong>栈顶记录的最小值</strong>即可</p>
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20201202092845198.png" class="" title="image-20201202092845198">
<img src="/2021/03/25/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E4%B9%A6%E6%9C%AC%E7%AC%94%E8%AE%B0/image-20201202092853394.png" class="" title="image-20201202092853394">
<h2 id="如果最后一个数据点出错"><a class="markdownIt-Anchor" href="#如果最后一个数据点出错"></a> 如果最后一个数据点出错</h2>
<p>毫无疑问, 一定是<strong>数据类型不匹配</strong>,  <mark>long long int 转 int</mark></p>
<h2 id="图论问题"><a class="markdownIt-Anchor" href="#图论问题"></a> 图论问题</h2>
<p>图论题, 如果使用最短路径算法, Dijkstra算法, 那么只要在该算法基础上. <mark>添加限制条件或者修改</mark>即可解决题目.</p>
<h2 id="一般题目都会涉及的问题"><a class="markdownIt-Anchor" href="#一般题目都会涉及的问题"></a> 一般题目都会涉及的问题</h2>
<ol>
<li>检查主逻辑问题</li>
<li>检查<mark>首情况和尾巴</mark></li>
<li>特殊数据</li>
</ol>
<h2 id="for循环之谜"><a class="markdownIt-Anchor" href="#for循环之谜"></a> for循环之谜</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">3</span>; ++k){}</span><br><span class="line">cout &lt;&lt; k&lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出 k = 3 </span></span><br><span class="line"><span class="comment">// 当 k = 3  时才会弹出 不满足循环条件 k &lt; 3</span></span><br><span class="line"><span class="comment">// !!!!!!弹出来不是 k = 2;</span></span><br><span class="line"> </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<h2 id="char数组的初始化"><a class="markdownIt-Anchor" href="#char数组的初始化"></a> char数组的初始化</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> tmp[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//如果是全局变量 tmp默认全为 \0</span></span><br><span class="line"><span class="comment">// \0为不可见字符</span></span><br></pre></td></tr></table></figure>
<h2 id="模拟"><a class="markdownIt-Anchor" href="#模拟"></a> 模拟</h2>
<p>数组的位置变化, 可以观察变化的规律, 即从哪里变换到哪里. 可以将二维变成一维处理, 也可以<mark>直接对二维</mark>进行处理. 视情况而定.</p>
<h2 id="连续子序列"><a class="markdownIt-Anchor" href="#连续子序列"></a> 连续子序列</h2>
<p>确定一个连续子序列, 只需知道对应<mark>开始的点</mark>以及<mark>结束的点</mark>即可</p>
<h1 id="复盘"><a class="markdownIt-Anchor" href="#复盘"></a> 复盘</h1>
<h2 id="cs"><a class="markdownIt-Anchor" href="#cs"></a> CS</h2>
<ol>
<li>
<p>与运算&amp;, 或运算|, 异或运算^,  取反运算~, 左移&lt;&lt;右移&gt;&gt;运算,</p>
<ul>
<li>
<p>与运算&amp;<br>
运算规则: 1&amp;1 = 1, 其余情况均为0</p>
<p>特性: A&amp;B &gt;= A&amp;B&amp;C.     A&amp;B &lt;= min(A , B).  ( 只有当A==B, 满足等号)</p>
</li>
</ul>
</li>
<li>
<p>数学中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>m</mi><mi>i</mi></msubsup></mrow><annotation encoding="application/x-tex">C^i_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.071664em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span> 从 m 个中取 i 个.</p>
</li>
<li>
<p>简化题目要求, <mark>发现规律</mark>, 有些问题可能是满足<mark>周期性</mark>, 答案只可能为小范围的有限值,</p>
</li>
</ol>
<h1 id="看题需知"><a class="markdownIt-Anchor" href="#看题需知"></a> 看题需知</h1>
<ol>
<li>
<p>题目要求的东西, 是从所有可能最大值中求最小值, 还是最大值, 花多点时间在读题和思考, 那么代码才写的快, 调试时间才小. 绝对不能抱着快速解题的思想. 要读懂题意, 不要一开始就想着套模板.</p>
</li>
<li>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="2.27ex" height="1.912ex" role="img" focusable="false" viewBox="0 -833.9 1003.6 844.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(600, 363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container>算法当数据量超过 10000, 不行</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>一定要用 long long int</p>
</li>
<li>
<p>题目如果包含<mark>负数</mark>, 如果有最小值的初始化, 一定要初始化为<mark>负数</mark></p>
</li>
</ol>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2021 <a href="/" rel="nofollow">chenyuanzhen</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>