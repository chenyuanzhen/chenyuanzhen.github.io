<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>鸟哥Linux私房菜第四版 笔记 | 笔记仓库</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">笔记仓库</a><span class="subtitle">知道为什么比知道怎么做更重要</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>鸟哥Linux私房菜第四版 笔记</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2021-07-24</div><div class="post-tags"><a class="post-tag-none-link" href="/tags/Linux/" rel="tag">Linux</a></div></div></div><article><div class="container post"><p><mark>Linux下无论什么都是一个文件</mark></p>
<h2 id="linux安装前提需知"><a class="markdownIt-Anchor" href="#linux安装前提需知"></a> Linux安装前提需知</h2>
<h3 id="硬件设备在linux中的文件名"><a class="markdownIt-Anchor" href="#硬件设备在linux中的文件名"></a> 硬件设备在linux中的文件名</h3>
<p>几乎所有的硬件设备文件都位于 /dev 目录下</p>
<blockquote>
<p>如SATA接口的硬盘的文件名为 /dev/sd[a-d]</p>
<p>但若是虚拟机则会使用 /dev/vd[a-p]</p>
</blockquote>
<h3 id="磁盘分区"><a class="markdownIt-Anchor" href="#磁盘分区"></a> 磁盘分区</h3>
<p>磁盘接口有两种SATA与SAS接口.  分区时, 单位是柱面</p>
<p>操作系统中的磁盘, 因容量过大, 需要分区管理. 而分区有两种格式</p>
<ul>
<li>
<p>MSDOS分区表格式<br>
<mark>开机管理程序记录区</mark>与<mark>分区表</mark>均放在磁盘第一扇区.</p>
<ul>
<li>
<p>主要开机记录区 安装开机管理程序的地方  446bytes</p>
</li>
<li>
<p>分区表 记录整颗磁盘分区的状态, 有64bytes</p>
<ul>
<li>
<p>能写入4组分区信息( 主要分区或延伸分区)</p>
</li>
<li>
<p>分区可在设备文件名中体现</p>
<blockquote>
<p>/dev/sda3 与 /dev/sda4 通常用于主要分区和延伸分区记录存储 不可见<br>
而1~4都会给与主分区+延伸分区. (加起来最多4个)</p>
</blockquote>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724152807685.png?raw=true" alt="image-20210724152807685"></p>
</li>
<li>
<p>最小单位通常为柱面.</p>
<blockquote>
<p>通过延伸分区所指向的磁盘空间, 记录其余分区情况, 使得磁盘可以分为多个区</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>若第一个扇区崩了, 整个磁盘都救不得</p>
</li>
<li>
<p>GUID GPT磁盘分区表</p>
<p>过去一个扇区大小为512Bytes, 而如今有更大的bytes扇区出现. 为统一, 将扇区用==逻辑区块位址(LBA)==进行管理. GPT便是以LBA(默认512Bytes)进行规划. LBA0, LBA1…</p>
<p>用34个LBA区块记录分区信息<br>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724153254882.png?raw=true" alt="image-20210724153254882" style="zoom:50%;"></p>
<ul>
<li>LBA0 相容区块, 存储第一阶段的开机管理程序. 并告知硬件管理程序, 是GPT格式</li>
<li>LBA1 GPT表头记录
<ul>
<li>备份用的GPT分区放置的位置. 前34个空余LBA可用于备份</li>
<li>分区表的检验机制码CRC32. 判断该GPT是否正确</li>
</ul>
</li>
<li>LBA2-33 实际记录分区信息
<ul>
<li>每个LBA可记录4个分区记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="开机流程中的bios与uefi开机检测程序"><a class="markdownIt-Anchor" href="#开机流程中的bios与uefi开机检测程序"></a> 开机流程中的BIOS与UEFI开机检测程序</h3>
<h4 id="bios-mbrgpt开机流程"><a class="markdownIt-Anchor" href="#bios-mbrgpt开机流程"></a> BIOS + MBR/GPT开机流程</h4>
<p>BIOS 一个写入到主板上的软件程序. (计算机系统主动执行的第一个程序)</p>
<p>该程序会读取MBR ( MSDOS分区第一个分区 )的信息, 执行最基本的开机管理程序.</p>
<p>流程:</p>
<ol>
<li>
<p>执行BIOS</p>
</li>
<li>
<p>读取MBR, 获取开机管理程序</p>
<blockquote>
<p>若为GPT格式从LBA0读取<br>
MBR的任务</p>
<ul>
<li>提供菜单</li>
<li>载入核心文件</li>
<li>将开机管理功能转交给其他分区的开机扇区负责.<br>
实现不同分区装载不同的系统, 而可以通过选择不同的开机扇区, 启动不同的系统</li>
</ul>
</blockquote>
</li>
<li>
<p>开机管理程序, 读取并执行核心文件</p>
</li>
<li>
<p>核心文件执行开始操作系统的功能</p>
</li>
</ol>
<h4 id="uefi-bios搭配gpt开机的流程"><a class="markdownIt-Anchor" href="#uefi-bios搭配gpt开机的流程"></a> UEFI BIOS搭配GPT开机的流程</h4>
<p>部分BIOS由于是16位程序, 而GPT是支持64bit寻址的. 为解决该问题, UEFI诞生了.</p>
<blockquote>
<p>UEFI BIOS 可以说是BIOS的升级版</p>
</blockquote>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724160820764.png?raw=true" alt="image-20210724160820764"></p>
<h3 id="linux安装中的磁盘分区选择"><a class="markdownIt-Anchor" href="#linux安装中的磁盘分区选择"></a> Linux安装中的磁盘分区选择</h3>
<p>windows将磁盘分区以C盘, D盘管理文件. 而Linux是以目录树管理文件.</p>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724161110732.png?raw=true" alt="image-20210724161110732" style="zoom:50%;">
<p>所有的文件都是有根目录 / 衍生出来</p>
<h4 id="挂载-解决将磁盘内的数据转化为目录树的架构"><a class="markdownIt-Anchor" href="#挂载-解决将磁盘内的数据转化为目录树的架构"></a> 挂载 解决将磁盘内的数据转化为目录树的架构</h4>
<p>进入到一个特定目录可以读取某个特定分区的信息. 这个动作叫挂载</p>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210724161334879.png?raw=true" alt="image-20210724161334879" style="zoom:50%;">
<blockquote>
<p>/home以下的目录数据都放置到分区2, 而非/home目录下的, 全放置到分区1</p>
</blockquote>
<p>安装linux时, 需考虑磁盘分区与目录树的挂载</p>
<h2 id="linux安装规划"><a class="markdownIt-Anchor" href="#linux安装规划"></a> Linux安装规划</h2>
<p>Linux有许多的发行版, 而核心都是一致的, 各有一些小差异.</p>
<h3 id="软件-软件选择"><a class="markdownIt-Anchor" href="#软件-软件选择"></a> 软件 软件选择</h3>
<ul>
<li>最小安装<br>
没有图形gui, 需要自己一步步搭建, 仅安装最简单的功能</li>
<li>含GUI的服务器</li>
<li>GNOME桌面环境 Linux常见的图形接口</li>
</ul>
<h3 id="系统-安装位置"><a class="markdownIt-Anchor" href="#系统-安装位置"></a> 系统 安装位置</h3>
<p>设备类型 管理分区方法</p>
<ul>
<li>标准分区  普通的分区, 与上面的相同</li>
<li>LVM          可弹性增加或削减文件系统容量的设备管理</li>
<li>LVM进阶版</li>
</ul>
<p>文件系统</p>
<ul>
<li>ext2/ext3/ext4 Linux早期适用的文件系统类型.</li>
<li>swap 磁盘仿真为内存, 不使用目录树的挂载, 无需指定挂载点</li>
<li>BIOS Boot GPT分区使用</li>
<li>xfs 默认CentOS文件系统, 用于大容量磁盘管理</li>
<li>vfat 同时被Linux与Windows支持</li>
</ul>
<h4 id="系统-kdump"><a class="markdownIt-Anchor" href="#系统-kdump"></a> 系统 KDUMP</h4>
<p>默认开启, 当核心机制崩溃时, 会记录当前系统信息</p>
<h4 id="系统-网络配置"><a class="markdownIt-Anchor" href="#系统-网络配置"></a> 系统 网络配置</h4>
<p>读取网卡配置,</p>
<h4 id="创建用户"><a class="markdownIt-Anchor" href="#创建用户"></a> 创建用户</h4>
<p>默认会创建一个root用户, 有最高权限.</p>
<p>而也可创建一个新用户, 若勾选将此用户作为管理员, 说明该用户可转变拥有最高权限</p>
<h2 id="linux系统常用"><a class="markdownIt-Anchor" href="#linux系统常用"></a> Linux系统常用</h2>
<p>终端编码查看</p>
<p>locale命令</p>
<blockquote>
<p>若是在linux的默认终端中,  哪怕编码正确, 也无法显示, 需要加入中文化接口软件</p>
</blockquote>
<ul>
<li>终端模式与GUI模式切换
<ul>
<li>GUI ctrl + alt + f1</li>
<li>终端 ctrl + alt + f2~f6 一共有5个默认终端</li>
</ul>
</li>
</ul>
<p>每一个GUI都是配备一个终端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启GUI, 确保该终端没有开其他GUI Xwindow</span></span><br><span class="line">startx</span><br></pre></td></tr></table></figure>
<h3 id="bash命令"><a class="markdownIt-Anchor" href="#bash命令"></a> bash命令</h3>
<h4 id="需知"><a class="markdownIt-Anchor" href="#需知"></a> 需知</h4>
<ul>
<li>Linux英文大小字母区分</li>
<li>换行用 \</li>
<li>多余空格都视为一格. 用于区分命令参数</li>
</ul>
<h3 id="基础命令"><a class="markdownIt-Anchor" href="#基础命令"></a> 基础命令</h3>
<ul>
<li>
<p>显示日期和时间 date</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 格式化输出 2015/05/29</span></span><br><span class="line">date +%Y/%m/%d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 时间</span></span><br><span class="line">date +%H:%M</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>日历 cal</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cal </span><br><span class="line">cal [年份]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>计算器 bc</p>
<p>quit退出</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scale=小数位数</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>man 命令<br>
操作说明</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man [命令名称]</span><br></pre></td></tr></table></figure>
<p>man后第一行会出现命令名称 + ([数字])</p>
<p>若数字为</p>
<ul>
<li>
<p>1 shell中可操作的指令或可执行  <mark>记住</mark></p>
</li>
<li>
<p>2 系统核心调用的函数与工具</p>
</li>
<li>
<p>3 常用函数或函数库</p>
</li>
<li>
<p>4 设备文件说明</p>
</li>
<li>
<p>5 配置文件或某些文件格式 <mark>记住</mark></p>
</li>
<li>
<p>6 游戏</p>
</li>
<li>
<p>7 协定与惯例</p>
</li>
<li>
<p>8 系统管理员可用的管理指令 <mark>记住</mark></p>
<p>查询 /string 向下查询  ?string向上查询<br>
n为向下查询,  N为往上查询</p>
</li>
</ul>
<p>其余说明的文件<br>
/usr/share/doc/软件名  该路径存储说明文件<br>
或者 命令名称 --help也可查询命令</p>
</li>
<li>
<p>info命令<br>
与man相同</p>
</li>
</ul>
<h4 id="nano-文本编辑器"><a class="markdownIt-Anchor" href="#nano-文本编辑器"></a> nano 文本编辑器</h4>
<p>比较简单</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano </span><br></pre></td></tr></table></figure>
<h3 id="常用热键"><a class="markdownIt-Anchor" href="#常用热键"></a> 常用热键</h3>
<ul>
<li>
<p>tab 自动补全</p>
<ul>
<li>
<p>接在一串指令的第一个字后, 命令补全</p>
</li>
<li>
<p>一串指令的第二个字以后, 为文件补全</p>
</li>
<li>
<p>连续按两次, 列出以当前输入字母为开头的所有命令</p>
</li>
<li>
<p>命令 --按tab两次, 列出所有全名参数    -按tab一次, 列出简写</p>
</li>
</ul>
</li>
<li>
<p>ctrl + c<br>
停止程序</p>
</li>
<li>
<p>ctrl + d<br>
表示键盘输入结束. 可视为输入exit</p>
</li>
<li>
<p>shift + 上下键 为翻页</p>
</li>
</ul>
<h4 id="关机方法"><a class="markdownIt-Anchor" href="#关机方法"></a> 关机方法</h4>
<p>需要关注有无网络用户在与主机发生交互  who 指令, netstat -a指令 看连线状态</p>
<p>shutdown( 关机 ) 与 reboot( 重启 ) 两个指令.  需要root才有权限执行, 若有GUI, 也可由普通用户执行</p>
<p>sync 数据同步写入磁盘</p>
<h3 id="linux的文件权限与目录配置"><a class="markdownIt-Anchor" href="#linux的文件权限与目录配置"></a> Linux的文件权限与目录配置</h3>
<p>任何一个文件都具有 User, Group, Others三种身份权限. root可随意访问任何文件</p>
<p>切换为root身份 su -  可使用exit返回原身份</p>
<h4 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h4>
<p>drwxr-xr-x+ 87 chenyuanzhen staff  2784 7 25 21:48 .</p>
<ul>
<li>
<p>d rwx rwx —</p>
<p>最前面的d表示为文件夹 目录  -为文件, l为连接文件, b为可存储设备, c为外设</p>
<ul>
<li>前三组 rwx 表示文件拥有者的权限
<ul>
<li>r 读</li>
<li>w 写</li>
<li>x 执行(进入目录也算执行动作) linux有x标记, 才可执行</li>
</ul>
</li>
<li>中间三组 表示与文件拥有者同一个group下</li>
<li>后三组 为others身份的权限</li>
</ul>
<p>无权限为 -</p>
</li>
<li>
<p>87 表示多少个文件名链接到此节点</p>
</li>
<li>
<p>chenyuanzhen 表示为文件拥有者</p>
</li>
<li>
<p>staff 为拥有者所属群组</p>
</li>
<li>
<p>2784 容量大小 默认单位为bytes</p>
</li>
<li>
<p>7 25 21:48 为最近修改日期</p>
</li>
</ul>
<p>root拥有所有文件的 rwx权限. 不受系统限制</p>
<h3 id="改变文件属性"><a class="markdownIt-Anchor" href="#改变文件属性"></a> 改变文件属性</h3>
<ul>
<li>
<p>chgrp 改变文件所属群组</p>
<p>要被改变的群组名称必须要在 /etc/group文件内存在才可</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp groupName filepath</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>chown 改变文件拥有者</p>
<p>必须有该用户才可变成为该用户, /etc/passwd 中文件有记录才能改变</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown userName filepath</span><br></pre></td></tr></table></figure>
<p>修改所属小组 用 : 区分 或 . 区分</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown userName:groupName filepat h</span><br><span class="line">chown .小组名 filepath </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>chmod 改变文件的权限</p>
<p><mark>只有文件所有者和超级用户可以修改文件或目录的权限</mark></p>
<p>rwx rwx rwx 分为三组,<br>
r: 4分   w: 2分  x: 1分. 单独计算分数</p>
<blockquote>
<p>如若要开启所有权限, 则对应分数为 777</p>
<p>而只想拥有者拥有所有权限为 700</p>
</blockquote>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 filepath</span><br><span class="line">chmod 700 filepath</span><br></pre></td></tr></table></figure>
<p>或者</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> u表示拥有者, 后跟着的为权限编号, go表示为所属群</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a表示所有人 chomd a+x filepath 令所有人都可执行</span></span><br><span class="line">chmod u=rwx,go=rx,o=r filepath</span><br><span class="line"><span class="meta">#</span><span class="bash"> = 号可替换为 + 附加, -为除去</span></span><br><span class="line">chmod u+rwx,go-rx,o-r filepath</span><br></pre></td></tr></table></figure>
<p>拥有rwx都不代表一定能删除该文件,  仅能修改其中的内容.<br>
rwx对于目录而言</p>
<ul>
<li>r  读取该目录下的文件名数据</li>
<li>w 可在新的目录下创建文件与目录, 可删除已经存在的文件与目录( 无视该文件权限), 改名, 移动文件与目录位置</li>
<li>x 可进入该目录同时可作为工作目录 最好能同时给与rx. 没有r也能取数据, 但无法补全名字</li>
</ul>
</li>
</ul>
<h3 id="linux文件种类与扩展名"><a class="markdownIt-Anchor" href="#linux文件种类与扩展名"></a> Linux文件种类与扩展名</h3>
<p>文件种类</p>
<ul>
<li>正规文件</li>
<li>纯文本文件</li>
<li>二进制档 binary</li>
<li>数据格式文件  data</li>
<li>目录</li>
<li>链接文件 link   快捷方程式</li>
<li>设备与设备文件   与系统周边与储存等相关的文件, 位于/dev目录下
<ul>
<li>区块设备文件 block  支持随机存储 如硬盘与软盘</li>
<li>字符设备文件  character  一次性读取, 不支持随机读取  如鼠标与键盘</li>
</ul>
</li>
<li>数据耳机口文件 sockets</li>
<li>数据输送档 FIFO    解决多个进程同时读写一个文件</li>
</ul>
<p>linux的后缀名仅用于让使用这了解文件的可能用途. x权限决定一个文件是否能被执行</p>
<h3 id="linux目录配置"><a class="markdownIt-Anchor" href="#linux目录配置"></a> Linux目录配置</h3>
<p>FHS Filesystem Hierarchy Standard. 规定每个特定的目录下应该要放置什么数据.</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210726150703393.png?raw=true" alt="image-20210726150703393"></p>
<p>不变的: 表示放置的文件不会经常变动, 函数库, 文件说明文档等</p>
<ul>
<li>
<p>/ (root, 根目录) 与开机系统有关</p>
<blockquote>
<p>根目录应该越小越好, 由于记录特定开机文件, 核心文件, 开机所需程序等</p>
</blockquote>
<ul>
<li>/bin      放置可执行文件的目录</li>
<li>/boot  开机会使用的文件</li>
<li>/dev   任何与外设有关的设备都以文件的形态放置到该文件夹中</li>
<li>/etc 系统主要的配置文件  如人员的账号密码档</li>
<li>/lib  仅放置开机会用到的函数库以及/bin或/sbin下指令会调用到的函数库</li>
<li>/media  可移除设备</li>
<li>/mnt 挂载某些额外的设备</li>
<li>/opt 第三方协力软件</li>
<li>/run 开机后产生的各项信息</li>
<li>/sbin 开机中所需的指令,
<ul>
<li>/usr/sibn 放置服务器软件程序</li>
<li>/usr/local/sbin 放置安装软件所产生的系统可执行文件</li>
</ul>
</li>
<li>/srv 网络服务文件</li>
<li>/tmp 暂时存储</li>
<li>/usr  Unix Software Resource. 操作系统软件资源  软件开发者将系统数据放置到该文件夹下. 所有系统默认软件到放置在/usr下面
<ul>
<li>/usr/bin/ 用户能使用的指令</li>
<li>/usr/lib/   与上/lib相同, 仅仅是链接</li>
<li>/usr/local  系统管理员在本机自行安装下载的软件</li>
<li>/usr/sbin  非系统正常运行所需的系统指令  也可链接</li>
<li>/usr/share 文字文件</li>
</ul>
</li>
<li>/var  放置经常变动的文件
<ul>
<li>/var/run 放置服务的PID 与/run相同, 链接</li>
</ul>
</li>
</ul>
<p>以上不同的发行版会有小改变</p>
</li>
</ul>
<h3 id="目录树"><a class="markdownIt-Anchor" href="#目录树"></a> 目录树</h3>
<p>绝对路径   /</p>
<p>相对路径  ./ 当前目录(等同于 . )   …上级目录</p>
<h2 id="linux文件与目录管理"><a class="markdownIt-Anchor" href="#linux文件与目录管理"></a> Linux文件与目录管理</h2>
<p>特殊目录: 可直接cd</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.  当前目录</span><br><span class="line">.. 上级目录</span><br><span class="line">~  目前使用者的主文件夹</span><br><span class="line">~account  account账户的主文件夹</span><br></pre></td></tr></table></figure>
<p>目录指令</p>
<ul>
<li>
<p>cd 变换当前目录</p>
</li>
<li>
<p>pwd 显示目前的目录</p>
</li>
<li>
<p>mkdir 创建一个新的目录</p>
</li>
<li>
<p>rmdir 删除一个<mark>空的</mark>目录</p>
<blockquote>
<p>可使用 rmdir -r 目录名 删除目录下所有文件</p>
</blockquote>
</li>
</ul>
<h4 id="可执行文件路径的变量-path"><a class="markdownIt-Anchor" href="#可执行文件路径的变量-path"></a> 可执行文件路径的变量 $PATH</h4>
<p>环境变量 PATH   echo $PATH</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由:区分</span></span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin:/usr/local/mysql/bin</span><br></pre></td></tr></table></figure>
<p>系统会根据PATH的设置, 在<mark>每个PATH定义的目录下搜寻指令名称的可执行文件</mark></p>
<h3 id="文件与目录管理"><a class="markdownIt-Anchor" href="#文件与目录管理"></a> 文件与目录管理</h3>
<ul>
<li>
<p>文件与目录的检视 ls</p>
</li>
<li>
<p>复制 cp</p>
<blockquote>
<p>默认cp文件, 会将文件的拥有者和所属群组修改为执行cp的使用者</p>
<p>cp -p  可将文件的属性一起复制过去,<br>
但没有rw权限与chmod执行权限的用户, 仍不可执行cp -p 操作</p>
<p>cp -a 等同于 -p -r  将目录下的所有文件保留文件属性.</p>
</blockquote>
</li>
<li>
<p>删除 rm</p>
<ul>
<li>
<p>rm -r 递归删除</p>
</li>
<li>
<p>rm -i 询问删除, 每删除都会显示文件名</p>
</li>
<li>
<p>若文件名有特殊字符, 可将其写为 ./ + 文件名</p>
</li>
</ul>
</li>
<li>
<p>移动( 更名 ) mv</p>
<p>若移动多个文件或目录, 则最后一个目标文件一定是目录</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv [options] source1, source2, source3 ... directory</span><br><span class="line">mv [options] source destination</span><br></pre></td></tr></table></figure>
<ul>
<li>-f 强制, 若文件已经存在, 会直接覆盖</li>
<li>-i 若文件已经存在, 则会询问是否覆盖</li>
<li>-u 若文件名已经存在, 较新的才会覆盖</li>
</ul>
</li>
<li>
<p>取得路径的文件名与目录名</p>
<ul>
<li>basename filePath   获取文件名 (去掉路径)</li>
<li>direname  dirPath 获取目录名 (去掉路径)</li>
</ul>
</li>
</ul>
<h3 id="文件内容查阅"><a class="markdownIt-Anchor" href="#文件内容查阅"></a> 文件内容查阅</h3>
<ul>
<li>cat 由第一行开始显示文件内容  -v 列出一些看不出的特殊字符</li>
<li>tac 从最后一行开始显示</li>
<li>nl 显示时 顺道输出行号</li>
<li>more 一页一页的显示文件内容</li>
<li>od 以二进制方式读取文件内容<br>
将二进制文件都以不同进制读取</li>
</ul>
<h4 id="读取部分内容"><a class="markdownIt-Anchor" href="#读取部分内容"></a> 读取部分内容</h4>
<ul>
<li>head 从头部取<br>
head filepath 默认10行, 可加head -n 数字 filepath</li>
<li>tail 从尾部读取</li>
</ul>
<h3 id="修改文件时间或创建新文件-touch"><a class="markdownIt-Anchor" href="#修改文件时间或创建新文件-touch"></a> 修改文件时间或创建新文件 touch</h3>
<p>mtime 最近一次修改内容的时间</p>
<p>atime 最近一次读取时间</p>
<h4 id="文件与目录的隐藏权限"><a class="markdownIt-Anchor" href="#文件与目录的隐藏权限"></a> 文件与目录的隐藏权限</h4>
<p>除了 3个rwx 外, 还有其他权限</p>
<p>传统的Ext2/Ext3/Ext4文件系统有隐藏属性, chattr 设置, lsattr查看. 可设置其不可修改的特性. 但xfs文件系统仅支持部分chattr参数.</p>
<table>
<thead>
<tr>
<th>属性名字</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>存取时间atime不会被修改</td>
</tr>
<tr>
<td>a</td>
<td>文件只能增加数据, 不能删除也不能修改 (root专属)</td>
</tr>
<tr>
<td>d</td>
<td>文件或目录不能被dump备份</td>
</tr>
<tr>
<td>i</td>
<td>文件不能更名, 删除, 无法写入或新增. (root专属)</td>
</tr>
<tr>
<td>s</td>
<td>文件被删除时, 会被完全的移除出磁盘空间</td>
</tr>
</tbody>
</table>
<p>哇, macos不支持. centos支持</p>
<h4 id="特殊权限"><a class="markdownIt-Anchor" href="#特殊权限"></a> 特殊权限</h4>
<ul>
<li>
<p>SUID</p>
<ul>
<li>仅对二进制程序 (命令) 有效</li>
<li>执行者对于该程序需要具有 x 的可执行权限；</li>
<li>本权限仅在执行该程序的过程中有效</li>
<li>执行这<mark>具有该程序拥有者的权限</mark></li>
</ul>
<p>常见, Linux系统的账号密码记录在 /etc/shadow文件中, 权限是仅有root可读和root强制写入</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210801160759274.png?raw=true" alt="image-20210801160759274"></p>
<p>但不同用户可执行passwd, 修改自己的密码,</p>
<p>步骤</p>
<ul>
<li>用户A对于 /usr/bin/passwd该命令有x权限, 表示A能执行passwd</li>
<li>passwd的拥有者是root</li>
<li>A执行passwd过程中, 会暂时获得root权限</li>
<li>/etc/shadow就可被A所执行的passwd所修改</li>
</ul>
</li>
</ul>
<h4 id="默认权限"><a class="markdownIt-Anchor" href="#默认权限"></a> 默认权限</h4>
<p>当创建一个新的文件或目录, 其默认权限与umask命令有关. 建议使用umask -s</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210801153941787.png?raw=true" alt="image-20210801153941787"></p>
<p>umask的二进制表示是 该rwx = 7 - umask的二进制表示.</p>
<p>如上</p>
<ul>
<li>u = rwx = 7 - 0 = 7</li>
<li>g = r-x = 5 = 7 - 2</li>
<li>o = r-x = 5 = 7 - 2</li>
</ul>
<p>umask可以设置默认权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 表示 g = --- 与 o = ---</span></span><br><span class="line">umask 077 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="观察文件类型file命令"><a class="markdownIt-Anchor" href="#观察文件类型file命令"></a> 观察文件类型file命令</h4>
<p>当一个文件属于ASCII文件或data文件, 或binary文件, 且没用到动态函数库, 可用file判断文件格式</p>
<h4 id="指令路径搜索-which"><a class="markdownIt-Anchor" href="#指令路径搜索-which"></a> 指令路径搜索 which</h4>
<p>which命令  寻找可执行文件</p>
<p>which + 命令名 输出该命令的完整文件名</p>
<h4 id="文件名搜寻"><a class="markdownIt-Anchor" href="#文件名搜寻"></a> 文件名搜寻</h4>
<p>whereis 从系统中一些特定的目录中寻找文件名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bmsu] 文件或目录名</span><br><span class="line">-b :只找binary格式文件</span><br><span class="line">-m : 只在说明文档manual路径下的文件</span><br><span class="line">-s :只找source来源文件</span><br></pre></td></tr></table></figure>
<p>locate指令</p>
<p>尽在已创建的数据库 /var/lib/mlocate/里面的数据中搜寻. 速度快</p>
<p>centos每一天更新一次, 可用updatedb强制刷新, 但花时较长</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> locate [-0Scims] [-l <span class="built_in">limit</span>] [-d database] pattern ...</span></span><br><span class="line">locate [-ir] keyword</span><br><span class="line">-i : 忽略大小写</span><br><span class="line">-c : 不输出文件名, 仅计算找到文件数量</span><br><span class="line">-l : 仅输出几行</span><br><span class="line">-S : 输出locate所使用的数据库文件的相关信息</span><br><span class="line">-r : 后面接正则表达式</span><br></pre></td></tr></table></figure>
<p>find指令</p>
<p>遍历硬盘查找</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find [PATH] [option] [action]</span><br><span class="line">在PATH目录下寻找</span><br></pre></td></tr></table></figure>
<p>有许多选项, 如 归属使用者, 更改日期, 文件大小, 文件特殊属性等限制</p>
<p>action</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-exec command : command为其他指令</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从path中找到py文件, 并执行 ls -l ..</span></span><br><span class="line">find path -name '*.py' -exec ls -l {} \;</span><br></pre></td></tr></table></figure>
<p>find的额外动作从 -exec 到 ; 结束  \是转义字符</p>
<h3 id="第七章-linux磁盘与文件系统管理"><a class="markdownIt-Anchor" href="#第七章-linux磁盘与文件系统管理"></a> 第七章 Linux磁盘与文件系统管理</h3>
<p>Centos7 默认使用xfs文件系统</p>
<p>往往一个磁盘分区只被格式化为一个文件系统. 而如今利用LVM与软件磁盘阵列技术, 使得一个分区可被格式化为多个文件系统. 当然, 多个分区可以合为一个文件系统.</p>
<p>一个文件系统通常有 (索引式文件系统)</p>
<ul>
<li>superblock 记录文件系统的整体信息</li>
<li>inode 记录文件属性, 一个文件占用一个inode, 同时记录该文件所在block号码</li>
<li>block 记录文件的内容</li>
</ul>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210801225436151.png?raw=true" alt="image-20210801225436151" style="zoom:50%;">
<p><mark>通常inode和block是提前规划好的, 不变动的</mark></p>
<blockquote>
<p>Ext2 在block大小有 1K, 2K, 4K三种.</p>
</blockquote>
<p>FAT格式是链表式文件系统</p>
<p>无inode, block等</p>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210801225446441.png?raw=true" alt="image-20210801225446441" style="zoom:50%;">
<h4 id="ext2"><a class="markdownIt-Anchor" href="#ext2"></a> EXT2</h4>
<p>采用索引式文件系统. 不过若文件系统容量高达数百GB. 将所有indoe和block管理是困难的. 所以格式化会将分成多个区块群组. 每个群组有独立的inode/superblock/block系统.</p>
<p>Ext2的block有如下限制</p>
<ul>
<li>block的大小与数量在格式化后不会再变动</li>
<li>每一个block内最多放置一个文件的数据 (会有碎片产生)</li>
<li>一个文件若过大, 会占用多个block</li>
</ul>
<blockquote>
<p>若一块block的大小越小, 那么indoe会变多, 文件系统性能也会下降. 通常, 是设置到4K</p>
</blockquote>
<p>EXt2的inode信息</p>
<ul>
<li>文件的存取模式</li>
<li>文件拥有者与群组</li>
<li>文件容量</li>
<li>占用block号</li>
</ul>
<p>特点</p>
<ul>
<li>
<p>一个文件仅占用一个inode,</p>
</li>
<li>
<p>每个inode固定128Bytes (Ext2)</p>
</li>
</ul>
<p>superblock超级区块</p>
<p>记录整个filesystem</p>
<p>记录信息</p>
<ul>
<li>block与inode总量</li>
<li>未使用block与inode数量</li>
<li>文件系统挂载时间等</li>
</ul>
<p>block bitmap 与 inode bitmap</p>
<p>记录剩余的block号与inode号.</p>
<h4 id="与目录树的关系"><a class="markdownIt-Anchor" href="#与目录树的关系"></a> 与目录树的关系</h4>
<ul>
<li>目录<br>
在Linux下的文件系统创建一个目录, 文件系统会分配一个inode与至少一块block给目录</li>
<li>文件<br>
ext2会分配一个inode与相对于该文件大小的block数量给文件</li>
</ul>
<p>目录里的block会记录文件的inode.</p>
<h4 id="新增步骤"><a class="markdownIt-Anchor" href="#新增步骤"></a> 新增步骤</h4>
<ol>
<li>确定是否有w + x权限</li>
<li>根据inode bitmap找到没有使用inode号码, 写入权限</li>
<li>根据block bitmap找到没有使用的block号码, 写入block中, 并更新inode里的block指向</li>
<li>将写入的inode与block同步更新到inode bitmap与blockmap中, 更新superblock</li>
</ol>
<h4 id="日志式文件系统"><a class="markdownIt-Anchor" href="#日志式文件系统"></a> 日志式文件系统</h4>
<p>避免不一致问题</p>
<blockquote>
<p>登记某个block已经被分配, 但实际因为某些原因, 并没有分配</p>
</blockquote>
<p>一个区块, 用于记录写入或修改文件时的步骤</p>
<ol>
<li>预备                     准备写入</li>
<li>实际写入             开始写入文件的权限与数据</li>
<li>结束                     文件完成在区块的记录</li>
</ol>
<h3 id="linux文件系统的运行"><a class="markdownIt-Anchor" href="#linux文件系统的运行"></a> Linux文件系统的运行</h3>
<p>所有数据要写入到内存后, CPU才能进行处理. 而磁盘读写速度太慢, 效率过低. Linux的解决方法是 <mark>非同步处理</mark></p>
<p>若内存中的文件没有被修改过, 无需写入. 若文件被修改, 则会一段时间后, 统一写回磁盘 (sync命令强制写回磁盘 ).</p>
<h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h4>
<ul>
<li>Linux的实体内存一般而言会被用完, 加速系统性能.</li>
<li>若不正常关机, 某些在内存里修改的文件但没写回到磁盘中, 会丢失修改.</li>
</ul>
<h3 id="挂载点的意义"><a class="markdownIt-Anchor" href="#挂载点的意义"></a> 挂载点的意义</h3>
<p>每个文件系统都有独立 inode / block / superblock信息, 但需要链接到目录树才能被使用.</p>
<p><mark>文件系统与目录树结合的动作为挂载</mark>.</p>
<h3 id="其余linux支持的文件系统与vfs"><a class="markdownIt-Anchor" href="#其余linux支持的文件系统与vfs"></a> 其余Linux支持的文件系统与VFS</h3>
<p>Linux支持 ext2 /ext3 /ext4文件系统格式. NFS/ SMBFS/ FAT ( Windows支持 ) 等也支持</p>
<p>VFS管理文件系统. 对于不同的文件系统, VFS可以抽象一个统一的接口.</p>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:13-image-20210802094729046.png?raw=true" alt="image-20210802094729046" style="zoom:50%;">
<h3 id="xfs文件系统简介"><a class="markdownIt-Anchor" href="#xfs文件系统简介"></a> XFS文件系统简介</h3>
<p>EXT系列支持度最广, 但格式化慢. 由于事先规划处所有的inode/block/metadata等数据. 硬盘越大, 划分所花费时间越多.</p>
<h4 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h4>
<p>数据区 + 文件系统活动登录区 + 实时运行区</p>
<ul>
<li>
<p>数据区<br>
包含 inode/ data block/ super block等数据, 当系统要用时, 才会动态生成</p>
</li>
<li>
<p>文件系统活动登录区<br>
记录文件系统的变化, 日志区. 文件变化会被记录在此地.</p>
</li>
<li>
<p>实时运行区</p>
<p>extent区块的大小在格式化时需要制定, 4K ~ 1G. 当文件被创建时, xfs会在该区段寻找extent区块, 将文件放置在内. 当分配完, 再写入到data section ( 数据区 )的inode与block.</p>
<p>与实体磁盘性能相关.</p>
</li>
</ul>
<h3 id="文件系统简单操作"><a class="markdownIt-Anchor" href="#文件系统简单操作"></a> 文件系统简单操作</h3>
<h4 id="查看磁盘与目录的容量"><a class="markdownIt-Anchor" href="#查看磁盘与目录的容量"></a> 查看磁盘与目录的容量</h4>
<p>查看superblock区块与inode的数据</p>
<ul>
<li>df: 列出文件系统的整体使用量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df [-ahikHTm] [目录或文件名]</span><br><span class="line">-a : 列出所有文件系统</span><br><span class="line">-k : 以KBytes的容量显示各个文件系统</span><br><span class="line">-m : 以MBytes的容量显示各个文件系统</span><br></pre></td></tr></table></figure>
<p>Mounted on 挂载点</p>
<ul>
<li>du: 评估文件系统的磁盘使用量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du [-ahskm] 文件或目录path</span><br><span class="line">-a 列出所有文件与目录容量</span><br><span class="line">-s 仅列出总量</span><br></pre></td></tr></table></figure>
<h4 id="实体链接与符号链接-ln"><a class="markdownIt-Anchor" href="#实体链接与符号链接-ln"></a> 实体链接与符号链接 ln</h4>
<p>种类</p>
<ul>
<li>
<p>Windows的捷径功能 符号链接</p>
<p>新建一个独立文件, 而该文件会让数据的读取指向link的文件名. 当源文件被删除, 那么符号链接会无法打开文件.</p>
</li>
<li>
<p>inode链接  实体链接</p>
<p>允许多个文件占用同一个inode号码. 只是<mark>在某一个目录下新增一笔文件名链接到某inode号码的管理记录</mark>而已.</p>
<p>好处</p>
<ul>
<li>安全, 当将链接中任一个文件名删除, inode与block仍是存在</li>
<li>耗费小</li>
</ul>
<p>限制</p>
<ul>
<li>不能跨文件系统</li>
<li>不能link目录<br>
过于复杂, link一个目录, 还需要link目录下的所有文件 (还有新建的文件)</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803150716163.png?raw=true" alt="image-20210803150716163"></p>
<blockquote>
<p>实体链接可以说与fileSave权限是相同的, 但符号链接不是, 对所有人都是rwx</p>
<p>第二列的数字是该文件所拥有的链接数目</p>
</blockquote>
<p>创建命令 ln</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> centos中默认创建实体链接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认是实体链接</span></span><br><span class="line">ln 文件path link的path</span><br></pre></td></tr></table></figure>
<h3 id="磁盘的分区-格式化-检验与挂载"><a class="markdownIt-Anchor" href="#磁盘的分区-格式化-检验与挂载"></a> 磁盘的分区, 格式化, 检验与挂载</h3>
<p>新增一个硬盘的动作</p>
<ol>
<li>对磁盘进行分区, 创建可用分区</li>
<li>对分区格式化, 创建 文件系统</li>
<li>可对文件系统进行检验</li>
<li>进行挂载</li>
</ol>
<h4 id="观察磁盘分区状态"><a class="markdownIt-Anchor" href="#观察磁盘分区状态"></a> 观察磁盘分区状态</h4>
<p>磁盘分区有 MBR与GPT格式. 所用的分区工具也不同</p>
<h4 id="lsblk-列出所有储备设备"><a class="markdownIt-Anchor" href="#lsblk-列出所有储备设备"></a> lsblk  列出所有储备设备</h4>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803153244395.png?raw=true" alt="image-20210803153244395"></p>
<ul>
<li>
<p>MAJ:MIN 主要:次要设备代码</p>
</li>
<li>
<p>RM: 0为不可卸载设备</p>
</li>
<li>
<p>RO: 1为只读设备</p>
</li>
<li>
<p>TYPE:</p>
<ul>
<li>disk 磁盘</li>
<li>part 分区</li>
<li>rom 只读</li>
</ul>
</li>
</ul>
<h4 id="lsblk-f"><a class="markdownIt-Anchor" href="#lsblk-f"></a> lsblk -f</h4>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803153518944.png?raw=true" alt="image-20210803153518944"></p>
<p>UUID 全域单一识别码</p>
<p>直接使用blkid找出设备的UUID. 用于挂载或者使用这个设备使用</p>
<h4 id="blkid"><a class="markdownIt-Anchor" href="#blkid"></a> blkid</h4>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803154536125.png?raw=true" alt="image-20210803154536125"></p>
<p>列出设备的UUID等参数, 也<mark>包括设备名称device_name, 文件系统类型</mark></p>
<h4 id="parted-device_name-print"><a class="markdownIt-Anchor" href="#parted-device_name-print"></a> parted device_name print</h4>
<p>列出磁盘的相关数据</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803154852801.png?raw=true" alt="image-20210803154852801"></p>
<ul>
<li>
<p>Model 磁盘的模块名称</p>
</li>
<li>
<p>Disk 磁盘总容量</p>
</li>
<li>
<p>Sector size 扇区容量</p>
</li>
<li>
<p>Partition Table 分区表格式  MBR/ GPT / loop</p>
<blockquote>
<p>loop (循环) 表示, 在另一个文件系统中包含虚拟文件系统的文件。</p>
</blockquote>
</li>
</ul>
<h4 id="磁盘分区-2"><a class="markdownIt-Anchor" href="#磁盘分区-2"></a> 磁盘分区</h4>
<p>磁盘分区命令</p>
<ul>
<li>gdisk      GPT分区</li>
<li>fdisk       MBR分区</li>
</ul>
<h4 id="gdisk"><a class="markdownIt-Anchor" href="#gdisk"></a> gdisk</h4>
<h4 id="新增分区"><a class="markdownIt-Anchor" href="#新增分区"></a> 新增分区</h4>
<p>进行GPT分区.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 后面为对应磁盘总目录名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不要加数字, 加数字表示分区, 而gdisk操作的单位是整块硬盘</span></span><br><span class="line">gdisk /dev/sda</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803160641615.png?raw=true" alt="image-20210803160641615"></p>
<ul>
<li>
<p>? 可获得所用的可用命令</p>
</li>
<li>
<p>p输出当前磁盘的信息</p>
</li>
</ul>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803160439083.png?raw=true" alt="image-20210803160439083"></p>
<p>Logical sector size 扇区大小</p>
<ul>
<li>n为创建新的GPT分区<br>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803161129787.png?raw=true" alt="image-20210803161129787">
<ul>
<li>partition number 分区号</li>
<li>First sector 首扇区号</li>
<li>Last sector 尾扇区号 可以使用 +1G自动算出所需扇区 +500M</li>
<li>Hex code or GUID  选择未来这个分区预计使用的文件系统</li>
</ul>
</li>
</ul>
<p>完成</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803161708306.png?raw=true" alt="image-20210803161708306"></p>
<p>按 w写入</p>
<p>需要更新分区表 partprobe指令</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803161919501.png?raw=true" alt="image-20210803161919501"></p>
<p>新增 sda4, sda5, sda6分区</p>
<h4 id="删除分区"><a class="markdownIt-Anchor" href="#删除分区"></a> 删除分区</h4>
<ol>
<li>
<p>使用gdisk + 硬盘文件</p>
</li>
<li>
<p>输入 d</p>
</li>
<li>
<p>再输入 p 检查</p>
</li>
<li>
<p>w退出</p>
</li>
<li>
<p>partprobe 更新分区表</p>
</li>
</ol>
<p><mark>不要删除一个使用中的分区</mark>, 需要先卸载</p>
<h3 id="磁盘格式化"><a class="markdownIt-Anchor" href="#磁盘格式化"></a> 磁盘格式化</h3>
<p>创建文件系统, 分区完毕, 需要对该分区进行文件系统格式化</p>
<p>mkfs [tab][tab] 会列出支持的文件系统</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210803165924333.png?raw=true" alt="image-20210803165924333"></p>
<h4 id="xfs系统-mkfsxfs"><a class="markdownIt-Anchor" href="#xfs系统-mkfsxfs"></a> xfs系统 mkfs.xfs</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 后面为分区文件路径</span></span><br><span class="line">mkfs.xfs /dev/sda3</span><br></pre></td></tr></table></figure>
<p>可使用默认配置, 也可有额外参数可选</p>
<h3 id="文件系统挂载与卸载"><a class="markdownIt-Anchor" href="#文件系统挂载与卸载"></a> 文件系统挂载与卸载</h3>
<p>当分区完毕 + 文件系统格式化. 最后一步是挂载目录.</p>
<p>首先需确定</p>
<ul>
<li>
<p>单一文件系统不应该被重复挂载在不同的挂载点中</p>
</li>
<li>
<p>单一目录不应该重复挂载多个文件系统</p>
</li>
<li>
<p>挂载点的目录应该为空目录</p>
<blockquote>
<p>若挂载的目录不空, 那么挂载后, 原目录下的文件会被隐藏, 当新分区被卸载后, 文件才会显现</p>
</blockquote>
</li>
</ul>
<h4 id="mount"><a class="markdownIt-Anchor" href="#mount"></a> mount</h4>
<p><mark>重启系统后, 需要自己重新挂载, 除非设置开机自挂载</mark></p>
<p>Linux系统自动分析文件系统驱动, 也可-t指定文件系统.</p>
<blockquote>
<p>通过分析superblock打在Linux自动的驱动程序测试挂载. 获取文件系统类型</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找对应的UUID</span></span><br><span class="line">blkid 分区文件路径 /dev/sda3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载到path上</span></span><br><span class="line">mount UUID="...." path</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看</span></span><br><span class="line">df path --block-size=1M path</span><br></pre></td></tr></table></figure>
<p>同样方法可以挂载CD或DVD等</p>
<h4 id="重新挂载"><a class="markdownIt-Anchor" href="#重新挂载"></a> 重新挂载</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 / 即根目录重新挂载, 并设为读写</span></span><br><span class="line">mount -o remount,rw,auto /</span><br></pre></td></tr></table></figure>
<p>可利用mount暂时额外的挂载到另一个目录</p>
<p>功能与符号链接类似</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将var暂时挂载在/data/var上</span></span><br><span class="line">mount --bind /var /data/var</span><br></pre></td></tr></table></figure>
<h4 id="卸载"><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h4>
<p>卸载umount 将设备文件卸载. 要推出U盘, 也要先卸载再推出. 需要没有使用的情况下, 才可卸载. -f 除外</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看挂载点</span></span><br><span class="line">mount</span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载</span></span><br><span class="line">umount 挂载点(或设备文件名)</span><br></pre></td></tr></table></figure>
<h3 id="磁盘文件系统参数修订"><a class="markdownIt-Anchor" href="#磁盘文件系统参数修订"></a> 磁盘/文件系统参数修订</h3>
<p>一切皆文件, 那么一个文件需要满足什么条件才能代表是一个设备呢?</p>
<p>通过文件的major与minor数值</p>
<blockquote>
<p>主要设备代码major</p>
<p>次要设备代码minor</p>
</blockquote>
<p>手动处理设备文件</p>
<p>mknod指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mknod 设备文件名 [bcp] [Major] [Minor]</span><br><span class="line">b : 磁盘, 储存设备文件</span><br><span class="line">c : 输入设备文件</span><br><span class="line">p : FIFO文件</span><br></pre></td></tr></table></figure>
<p>ll命令查看 major与minor</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210804152451197.png?raw=true" alt="image-20210804152451197"></p>
<p>8为major</p>
<p>0为minor</p>
<p>修改UUID与labelname</p>
<p>xfs_admin命令 修改xfs文件系统的UUID</p>
<p>uuidgen 生成新的UUID</p>
<h3 id="开机自动挂载"><a class="markdownIt-Anchor" href="#开机自动挂载"></a> 开机自动挂载</h3>
<p>限制</p>
<ul>
<li>根目录必须挂载, 且第一个被挂载</li>
<li>其余挂载点必须创建</li>
<li>所有分区和挂载点同一个时刻只能挂载一次</li>
<li><mark>卸载时, 必须将工作目录移除到 挂载点之外 (也不能再其子目录)</mark></li>
</ul>
<p>修改 /etc/fstab文件 即可.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设备名称或文件            <span class="comment"># 挂载点               #文件系统  # 文件参数    # 1为dump备份 # 1为fsck文件系统检验</span></span></span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=5ad4d814-4c9a-4f94-a561-b8101bf35f28 /boot xfs     defaults        0 0</span><br><span class="line">UUID=DF5A-5CE3          /boot/efi               vfat    umask=0077,shortname=winnt 0 0</span><br><span class="line">/dev/mapper/centos-home /home                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>文件系统参数</p>
<img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210804153920573.png?raw=true" alt="image-20210804153920573" style="zoom:50%;">
<p>fsck检查扇区默认不开启, 因为xfs会自动检验</p>
<h4 id="特殊设备挂载-loop"><a class="markdownIt-Anchor" href="#特殊设备挂载-loop"></a> 特殊设备挂载 loop</h4>
<p>镜像文件不烧录直接挂载使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop .iso路径 挂载目录</span><br></pre></td></tr></table></figure>
<h3 id="内存交换空间swap"><a class="markdownIt-Anchor" href="#内存交换空间swap"></a> 内存交换空间swap</h3>
<p>虚拟内存, 用磁盘空间模拟内存. 即创建 swap分区</p>
<p>步骤</p>
<ol>
<li>分区 gdisk 分区</li>
<li>格式化 mkswap 设备文件名</li>
<li>使用 swapon 设备文件名</li>
<li>检查 free 与swapon -s 观察内存的容量</li>
</ol>
<h2 id="vim使用"><a class="markdownIt-Anchor" href="#vim使用"></a> vim使用</h2>
<p>三种模式</p>
<ol>
<li>
<p>一般指令模式<br>
打开文件直接进入一般指令模式, 上下左右移动光标,</p>
<ul>
<li>dd 删除一整列</li>
<li>u 撤销</li>
<li>[ctrl] + r 重做</li>
</ul>
</li>
<li>
<p>编辑模式<br>
<mark>按 “i, I, o, O, a, A, r, R”, 左下方出现INSERT字样</mark>, 进行编辑 按ESC退回一般模式</p>
</li>
<li>
<p>命令行命令模式<br>
在一般模式下, <mark>输入 “: / ?” 三个中的任何一个按钮</mark>, 将光标移动到最下面一列, 可提供搜寻数据的动作. 离开vi, 显示行号等功能</p>
<ul>
<li>
<p>退出<br>
在一般指令下, 输入: 后, 输入wq 回车即可. 可加 wq! 强制写入</p>
</li>
<li>
<p>搜寻<br>
/word 在光标之下寻找一个word字串</p>
<p>?word 在光标之上寻找</p>
</li>
</ul>
</li>
</ol>
<h2 id="bash"><a class="markdownIt-Anchor" href="#bash"></a> BASH</h2>
<p>kernel 核心 是不允许直接访问的, 需要通过shell进行沟通. bash是shell的一种</p>
<p>位于 /bin/bash</p>
<h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3>
<ul>
<li>
<p>记录执行命令历史</p>
<p>在文件~/.bash_history内, 每关闭一次终端, 都会将写过的命令记录到该文件内.</p>
</li>
<li>
<p>命令补全<br>
一个字母 + tab 是补全命令<br>
第二个字母及以后 + tab 是补全文件</p>
</li>
<li>
<p>别名设置 alias<br>
用别名代替其他命令名 alias name=command<br>
使用时 无需$</p>
</li>
<li>
<p>工作控制</p>
</li>
<li>
<p>程序化脚本<br>
shell scripts</p>
</li>
<li>
<p>万用字符<br>
*</p>
</li>
</ul>
<h4 id="type指令"><a class="markdownIt-Anchor" href="#type指令"></a> type指令</h4>
<p>用于区分一个指令到底是否为bash内置</p>
<h4 id="换行"><a class="markdownIt-Anchor" href="#换行"></a> 换行</h4>
<p>\ + [enter]键</p>
<h4 id="变量功能"><a class="markdownIt-Anchor" href="#变量功能"></a> 变量功能</h4>
<ul>
<li>
<p>取用echo</p>
<p>变量被使用时必须 + $</p>
<ul>
<li>双引号含特殊字符会进行变量对变量值的转化</li>
<li>单引号含特殊字符会被视为一般字符</li>
<li>可用转移字符 \ 将其一般化</li>
</ul>
</li>
<li>
<p>变量设置</p>
<p>varName=varVal</p>
<ul>
<li>不能有空白字符</li>
<li>只能是英文字符, 数字, 但开头字符不能是数字</li>
</ul>
</li>
<li>
<p>变量 -&gt; 环境变量 (全局变量) 子程序也能使用</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>unset 取消变量</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset valName</span><br></pre></td></tr></table></figure>
<p>下载网站:</p>
</li>
</ul>
<h3 id="环境变量的功能"><a class="markdownIt-Anchor" href="#环境变量的功能"></a> 环境变量的功能</h3>
<p>查看</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前shell环境下的所有环境变量与其内容</span></span><br><span class="line">env</span><br><span class="line"><span class="meta">#</span><span class="bash"> 观察环境变量与自订变量</span></span><br><span class="line">set</span><br></pre></td></tr></table></figure>
<h4 id="特殊变量"><a class="markdownIt-Anchor" href="#特殊变量"></a> 特殊变量</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回上一执行命令的返回的错误码, 0为正常, 其余为错误代码</span></span><br><span class="line">echo $? </span><br></pre></td></tr></table></figure>
<h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4>
<h3 id="bash-shell的操作环境"><a class="markdownIt-Anchor" href="#bash-shell的操作环境"></a> bash shell的操作环境</h3>
<p>路径与指令搜索顺序</p>
<ol>
<li>以相对或绝对路径执行指令</li>
<li>由alias找到对应指令执行</li>
<li>bash内置指令</li>
<li>通过$PATH这个变量的顺序搜索到的第一个指令来执行</li>
</ol>
<h4 id="进站与欢迎讯息"><a class="markdownIt-Anchor" href="#进站与欢迎讯息"></a> 进站与欢迎讯息</h4>
<p>/etc/issue</p>
<p>修改/etc/issue文件</p>
<p>在 issue文件中 \ + 英文字符会有特殊函数</p>
<ul>
<li>\d 本地端时间的日期</li>
<li>\l 显示第几个终端机接口</li>
<li>\n 显示主机网络名称</li>
<li>\O 显示域名</li>
</ul>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210806174700947.png?raw=true" alt="image-20210806174700947"></p>
<p>而 <a target="_blank" rel="noopener" href="http://issue.net">issue.net</a> 用于远程访问</p>
<p>/etc/motd文件</p>
<p>用于让使用者登录后获取信息</p>
<h3 id="bash的环境配置文件"><a class="markdownIt-Anchor" href="#bash的环境配置文件"></a> bash的环境配置文件</h3>
<h4 id="无登录shell-与-有登录shell"><a class="markdownIt-Anchor" href="#无登录shell-与-有登录shell"></a> 无登录shell 与 有登录shell</h4>
<p>无登录shell</p>
<p>是基于图形化接口启动终端, 无需输入密码,</p>
<p>读取 ~/.bashrc文件</p>
<p>有登录shell</p>
<p>是开机时即打开shell, 需要密码才可使用</p>
<p>有登录shell 会读取 /etc/profile (系统整体设置) 与 ~/.bash_profile 使用者个人设置</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:30-image-20210806175218878.png?raw=true" alt="image-20210806175218878"></p>
<p>login_shell的读取流程</p>
<p>可用source命令读取配置文件内容</p>
<h3 id="数据流重导向"><a class="markdownIt-Anchor" href="#数据流重导向"></a> 数据流重导向</h3>
<p>standard output标准输入</p>
<p>将原本需要由键盘输入的数据，该由文件内容来代替</p>
<p>&lt; 输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 file.txt文件, 内容由anotherFile.txt输入</span></span><br><span class="line">cat &gt; file.txt &lt; anotherFile.txt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;&lt; 表示接受的输入字符串。当一行中包含该字符串时, 意味结束, 不包含这一行内容</span></span><br><span class="line">cat &gt; file.txt &lt;&lt; </span><br></pre></td></tr></table></figure>
<h4 id="standard-error-output标准输出"><a class="markdownIt-Anchor" href="#standard-error-output标准输出"></a> standard error output标准输出</h4>
<p>默认都为屏幕</p>
<p>标准输出 stdout &gt; (覆盖) 或者 &gt;&gt; (追加)</p>
<p>标准错误输出 stderr 2&gt; (覆盖) 或 2&gt;&gt;(追加)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将命令ll重定向输出为 save.txt</span></span><br><span class="line">ll &gt;&gt; save.txt</span><br></pre></td></tr></table></figure>
<p>/dev/null 垃圾桶黑洞设备 不显示信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name .bashrc 2&gt; /dev/null</span><br></pre></td></tr></table></figure>
<h4 id="命令执行的判断依据"><a class="markdownIt-Anchor" href="#命令执行的判断依据"></a> 命令执行的判断依据 ; , &amp;&amp; ||</h4>
<p>与C++相同, 每一个函数都有回传值, 0为正常执行</p>
<p>cmd1 &amp;&amp; cmd2<br>
cmd1执行完毕, 执行cmd2. 若cmd1执行错误,  cmd2不会执行</p>
<p>cmd1 || cmd2<br>
cmd1执行完毕不执行cmd2</p>
<h3 id="管道命令pipe"><a class="markdownIt-Anchor" href="#管道命令pipe"></a> 管道命令pipe |</h3>
<p>bash命令执行的有输出数据, 可用pipe | 将输出数据当为其他指令的输入.</p>
<blockquote>
<p>其他指令必须能接受标准输入的数据 ( 又称管道指令 ), 错误输出不会处理. 可用 2&gt;&amp;1将错误输出转化为标准输出</p>
</blockquote>
<h3 id="截取指令-cut-grep"><a class="markdownIt-Anchor" href="#截取指令-cut-grep"></a> 截取指令 cut, grep</h3>
<p>cut 对子串进行分割</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cut -d '分割字符' -f fields</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将PATH以:进行分割, 并只显示第5, 6个</span></span><br><span class="line">echo ${PATH} | cut -d ':' -f 5, 6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只显示  每一行[12, end)的字符串</span></span><br><span class="line">export | cut -c 12-</span><br></pre></td></tr></table></figure>
<ul>
<li>d后面解分割字符</li>
<li>f 依据-d的分割, 将信息分区成数段, 用-f取出第几段</li>
<li>-c 字符区间, 以字符为单位</li>
</ul>
<p>grep匹配数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grep [-acinv] [--color=auto] '搜索的字符串' filename</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grep [-A] [-B] [--color='auto'] '关键词' filename</span><br><span class="line"></span><br><span class="line">-A：后面可以加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来</span><br><span class="line">-B：后面可以加数字，为 befer 的意思，处理列出该行外，前面的 n 行也列出来</span><br><span class="line">--colort=auto：可将正确的哪个截取数据列出颜色</span><br></pre></td></tr></table></figure>
<h2 id="shell脚本"><a class="markdownIt-Anchor" href="#shell脚本"></a> SHELL脚本</h2>
<p><mark>需要注意变量设置不得有空格, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="36.053ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 15935.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(822, 0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1307, 0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2185, 0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(3063, 0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(3592, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(4192, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(4712, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5378.8, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">为</text><text data-variant="normal" transform="translate(900, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">获</text><text data-variant="normal" transform="translate(1800, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">取</text></g><g data-mml-node="mi" transform="translate(8356.6, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(8789.6, 0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(9274.6, 0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(10152.6, 0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(11030.6, 0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(11559.6, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(12159.6, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(12957.3, 0)"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">的</text><text data-variant="normal" transform="translate(900, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">输</text><text data-variant="normal" transform="translate(1800, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">出</text></g><g data-mml-node="mo" transform="translate(15657.3, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g></g></svg></mjx-container>{变量名}为获取变量名的内容</mark></p>
<p>用于自动执行某些固定的任务</p>
<p>建议将脚本放置到$PATH中, 那么可以直接使用, 而不是用绝对路径执行. 需要有 rx权限</p>
<p>注释 #</p>
<p>使用vim写会有语法 检查与标亮</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 建议格式</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash    宣告该script使用的shell名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Program:     声明该脚本的作用</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">	User inputs his firstname and last name. It will output the full name</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> History:     修改历史</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2015/07/16 authorName First release   日期 作者 版本号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 主要环境变量的宣告</span></span><br><span class="line">PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin</span><br><span class="line">export PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 程序部分</span></span><br><span class="line">read -p "Please input your name: " firstname </span><br><span class="line">echo -e "\n Your name is ${firstname}" </span><br><span class="line"><span class="meta">#</span><span class="bash"> 可自订推出号 对应 $?</span> </span><br><span class="line">exit 0 </span><br></pre></td></tr></table></figure>
<p>启用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在父程序执行, 声明的变量会影响父bash</span></span><br><span class="line">source bashPath</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者 在子程序bash中执行, 声明的变量以及结果, 是不会影响父程序</span></span><br><span class="line">chmod a+x bashPath;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要注意工作目录位于该脚本的所在目录</span></span><br><span class="line">./bashPath</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可将该脚本放置到<span class="variable">$PATH</span>指定的目录中, 可直接输入shell文件名(要加后缀.sh,如源文件有)即可</span></span><br></pre></td></tr></table></figure>
<p>可利用其他指令的输出为变量赋值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取前两天的日期</span></span><br><span class="line">date1 = ${date --date='2 days ago' + '%Y%m%d'}</span><br><span class="line"><span class="meta">#</span><span class="bash">字符串拼接</span></span><br><span class="line">file1 = ${filename}${date1} </span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建</span></span><br><span class="line">touch "${date1}"</span><br></pre></td></tr></table></figure>
<h3 id="判断式"><a class="markdownIt-Anchor" href="#判断式"></a> 判断式</h3>
<h4 id="test指令"><a class="markdownIt-Anchor" href="#test指令"></a> test指令</h4>
<p>test指令的测试功能, 可用于测试文件或文件夹是否存在, 如存在则返回0, 不存在返回非0</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 文件是否存在, 存在返回0, 配合&amp;&amp; 触发<span class="built_in">echo</span> <span class="string">"exist"</span></span></span><br><span class="line">test -e filename &amp;&amp; echo "exist" || echo "no exist"</span><br><span class="line">-e 文件名是否存在</span><br><span class="line">-f 文件名是否存在且是否为文件</span><br><span class="line">-d 文件名是否为目录</span><br><span class="line">-b 文件名是否为一个block device设备</span><br><span class="line"></span><br><span class="line">两个文件的比较</span><br><span class="line">test file1 -nt file2</span><br><span class="line">-nt file1是否比file2新</span><br><span class="line">-ot file1是否比file2旧</span><br><span class="line">-ef 是否为同一文件, 若指向同一个inode,则是</span><br><span class="line"></span><br><span class="line">整数之间的判定</span><br><span class="line">test n1 -eq n2</span><br><span class="line">-eq 两数值相等</span><br><span class="line">-ne 不等</span><br><span class="line">-gt 大于</span><br><span class="line">-lt 小于</span><br><span class="line">-ge 大于等于</span><br><span class="line">-le 小于等于</span><br><span class="line"></span><br><span class="line">字符串</span><br><span class="line">test -z string 字串是否为空, 空返回0</span><br><span class="line">-n 非空 为0</span><br><span class="line">test str1 == str2 是否等于</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="判断符号"><a class="markdownIt-Anchor" href="#判断符号"></a> 判断符号 []</h4>
<p>主义中括号两端须有空白字符分隔</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 判断 HOME变量是否为空</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -选项与 <span class="built_in">test</span>中相同</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [ -z <span class="string">"<span class="variable">${HOME}</span>"</span> ];</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回上一个表单式的返回值</span></span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>
<h4 id="if判断"><a class="markdownIt-Anchor" href="#if判断"></a> if判断</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件表达式 ]; then</span><br><span class="line">	做点啥</span><br><span class="line">elif [ 条件表达式 ]; then</span><br><span class="line">	做点啥</span><br><span class="line">else</span><br><span class="line">	做点啥</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span></span><br><span class="line">if [ "${yn}" == "Y" ] || [ "${yn}" == "y" ]; then</span><br><span class="line">        echo "Ok，continue"</span><br><span class="line">        exit 0</span><br><span class="line">else</span><br><span class="line">        echo "Oh，interrupt！"</span><br><span class="line">        exit 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 结尾用 <span class="keyword">if</span>倒着写表示</span></span><br><span class="line">fi</span><br><span class="line">echo "I don't know what your choice is" &amp;&amp; exit 0</span><br></pre></td></tr></table></figure>
<h3 id="case-esac判断"><a class="markdownIt-Anchor" href="#case-esac判断"></a> case esac判断</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关键词为 <span class="keyword">case</span> 还有 变量前的 $ 符号</span></span><br><span class="line">case $变量名称 in		</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 每个变量内容建议用双引号括起来，关键词则为小括号</span></span><br><span class="line">	“变量内容 1”)		</span><br><span class="line">	 	程序段</span><br><span class="line">	 	;;				 </span><br><span class="line"><span class="meta">  #</span><span class="bash"> 使用两个连续的分号来结尾</span></span><br><span class="line">	“变量内容 2”)</span><br><span class="line">	 	程序段</span><br><span class="line">	 ;;</span><br><span class="line"><span class="meta">	 #</span><span class="bash"> 最后一个变量内容需要用 * 来代表所有其他值</span></span><br><span class="line">	*)			 	  </span><br><span class="line">		程序段</span><br><span class="line">	 ;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最终的 <span class="keyword">case</span> 结尾，就是反过来拼写的字符 <span class="keyword">esac</span></span></span><br><span class="line">esac				  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case "$1" in</span><br><span class="line">    stop) stop ;;</span><br><span class="line">    status) status ;;</span><br><span class="line">    start|restart|reload|force-reload) restart ;;</span><br><span class="line">    condrestart) condrestart ;;</span><br><span class="line">    *) usage ;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="shell-script自带参数"><a class="markdownIt-Anchor" href="#shell-script自带参数"></a> shell script自带参数</h3>
<ul>
<li>$# 参数个数</li>
<li>$@ 全部参数内容</li>
<li>$0 程序文件名</li>
<li>$1 第一个参数</li>
<li>$2 第二个参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shift</span>	1<span class="comment"># 偏移指令, 参数列表首往后移一个</span></span><br><span class="line"><span class="built_in">shift</span> 10 <span class="comment"># 后移10个, 剩余参数列表长度&gt;10 才有效</span></span><br></pre></td></tr></table></figure>
<h3 id="shell-function"><a class="markdownIt-Anchor" href="#shell-function"></a> shell function</h3>
<p>一定要现在程序最前面, 执行方式是从上到下, 从左到右</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fucName(){</span><br><span class="line">	程序段</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><mark>function的自带参数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 778 860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(500, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g></g></svg></mjx-container>2与程序的参数 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 778 860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(500, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g></g></g></svg></mjx-container>2 是不同的, 是独立的</mark></p>
<h3 id="循环loop"><a class="markdownIt-Anchor" href="#循环loop"></a> 循环loop</h3>
<h4 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> while循环</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [condition]</span><br><span class="line">do </span><br><span class="line">	程度段</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h4 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> for循环</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 循环con1, con2, con3</span></span><br><span class="line">for var in con1 con2 con3...</span><br><span class="line">do</span><br><span class="line">	循环体</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数值处理</span></span><br><span class="line">for ((初始值;限制值;执行步骤))</span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">total=0</span><br><span class="line">for((i=1; i&lt;=5;i++))</span><br><span class="line">do</span><br><span class="line">	total = $((${total} + ${i}))</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先定义一个网域的前部分</span></span><br><span class="line">network="192.168.0"		</span><br><span class="line"><span class="meta">#</span><span class="bash"> seq 为 sequence 连续的意思</span></span><br><span class="line">for sitenu in $(seq 1 100)	</span><br><span class="line">do</span><br><span class="line"><span class="meta">	#</span><span class="bash"> ping -c 1 -w 1 192.168.0.101 &amp;&gt; /dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">"1"</span> || <span class="built_in">echo</span> <span class="string">"0"</span></span></span><br><span class="line"><span class="meta">	#</span><span class="bash"> &amp;&gt; /dev/null 将标准错误流重定向到黑洞 即不显示执行结果，并获取命令是否执行成功</span></span><br><span class="line">	ping -c 1 -w 1 ${network}.${sitenu} &amp;&gt; /dev/null &amp;&amp; result=0 || result=1</span><br><span class="line">	if [ "${result}" == 0 ]; then</span><br><span class="line">		echo "${network}.${sitenu} is up"</span><br><span class="line">	else</span><br><span class="line">		echo "${network}.${sitenu} is down"</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h3 id="shell-script的debug"><a class="markdownIt-Anchor" href="#shell-script的debug"></a> Shell Script的DEBUG</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh [-nvx] scripts.sh</span><br><span class="line">-n 不执行script, 仅检查语法问题</span><br><span class="line">-v: 将script内容输出屏幕后, 执行</span><br><span class="line">-x: 将执行到script内容显示到屏幕上</span><br></pre></td></tr></table></figure>
<h2 id="程序与进程"><a class="markdownIt-Anchor" href="#程序与进程"></a> 程序与进程</h2>
<p>查看命令 ps -l</p>
<p>触发任何一个事件, 系统都会将他定义为一个程序, 并给与该程序一个ID, PID</p>
<p>program 一般为 二进制文件 binary file</p>
<p>不同用户执行程序有不同的权限, 对应同一个程序的不同进程的PID也不同</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:44-image-20210813214305166.png?raw=true" alt="image-20210813214305166"></p>
<ul>
<li>
<p>程序program: 二进制文件, 放置到存储媒介中</p>
</li>
<li>
<p>进程process: program被触发后, 根据执行者的权限与属性, 所需数据等载入内存, 并获得PID</p>
</li>
<li>
<p>子进程与父进程</p>
<p>通过PPID判断, 子进程可以获取父进程的环境比那辆</p>
</li>
</ul>
<h3 id="fork-and-exec-进程呼叫的流程"><a class="markdownIt-Anchor" href="#fork-and-exec-进程呼叫的流程"></a> fork and exec 进程呼叫的流程</h3>
<p>由父进程复制fork的方式产生一个一模一样的子进程A, 子进程A在以exec方式执行要进行的程序</p>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:44-image-20210814091059094.png?raw=true" alt="image-20210814091059094"></p>
<h3 id="常驻在内存的进程"><a class="markdownIt-Anchor" href="#常驻在内存的进程"></a> 常驻在内存的进程</h3>
<p>系统或网络服务. 一直运行的程序. 这些常驻程序被称为服务</p>
<h3 id="进程与程序"><a class="markdownIt-Anchor" href="#进程与程序"></a> 进程与程序</h3>
<p>执行一个程序或指令,</p>
<h2 id="工作管理"><a class="markdownIt-Anchor" href="#工作管理"></a> 工作管理</h2>
<p>终端机接口分为前台与后台, 放入前台执行的进程会出现提示字符与人交互, 而放入后台执行的进程, 不能与人交互.</p>
<h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意:</h4>
<ul>
<li>这些工作所触发的进程必须来自于你的 shell 的子进程（只管理自己的 bash）</li>
<li>前景 foreground：你可以控制与下达指令的环境</li>
<li>背景：可以自动运行的工作，你无法使用 ctrl + c 终止它，可以使用 bg、fg 呼叫该工作</li>
<li>背景中<strong>执行</strong>的进程不能等待 terminal/shell 的输入（input）</li>
</ul>
<p>在执行命令时, 可在后面 + &amp; 表示在后台运行</p>
<p>将 目前的工作丢到背景中_暂停_：ctrl+z</p>
<h3 id="观察目前的背景工作状态jobs"><a class="markdownIt-Anchor" href="#观察目前的背景工作状态jobs"></a> 观察目前的背景工作状态：jobs</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs [-lrs]</span><br><span class="line">-l 列出PID</span><br><span class="line">-r 仅列出背景run的工作</span><br><span class="line">-s 仅列出正在背景中暂停的工作</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/chenyuanzhen/chenyuanzhen.github.io/blob/image/image/2022-04-13_10:08:44-image-20210814092530116.png?raw=true" alt="image-20210814092530116"></p>
<p>+表示最近被放到前台工作</p>
<p>-最后第二个被放置到前台工作</p>
<p>最左边为[1]为工作号码</p>
<h4 id="fg将背景工作放置到前景处理"><a class="markdownIt-Anchor" href="#fg将背景工作放置到前景处理"></a> fg将背景工作放置到前景处理</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg 工作号码</span><br></pre></td></tr></table></figure>
<h4 id="bg让工作在背景下的状态变成运行中"><a class="markdownIt-Anchor" href="#bg让工作在背景下的状态变成运行中"></a> bg让工作在背景下的状态变成运行中</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg 工作号码</span><br></pre></td></tr></table></figure>
<h3 id="kill移除工作"><a class="markdownIt-Anchor" href="#kill移除工作"></a> kill移除工作</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kill -signal $jobnumber</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出<span class="built_in">kill</span>能使用的信号</span></span><br><span class="line">kill -l </span><br><span class="line">-1：重新读取一次参数的配置文件（类似 reload）</span><br><span class="line">-2：代表与由键盘输入 ctrl+c 同样的动作</span><br><span class="line">-9：立刻强制删除一个工作</span><br><span class="line">-15：已正常的进程方式终止一项工作。与  -9 是不一样的</span><br></pre></td></tr></table></figure>
<p>使用vim会暂时产生一个 .filename.swp文件, 完整结束后会被移除. 若以-9结束, 那么.filename.swp不会被移除.</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>名称</th>
<th>名义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>启动被终止的进程, 重新启动</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>等同于ctrl + c 终止一个进程</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>强制终止一个进程的运行</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>以正常的方式终止进程, 对已经发生问题的进程无效</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>等同于ctrl - z暂停一个进程</td>
</tr>
</tbody>
</table>
<h3 id="脱机管理问题"><a class="markdownIt-Anchor" href="#脱机管理问题"></a> 脱机管理问题</h3>
<p>上面介绍的前台和后台, 仅局限于bash, 而不是整个系统, 若bash关闭, 那么无论前台还是后台, 工作都会被终止.</p>
<h2 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ps aux		# 观察系统所有的进程数据</span><br><span class="line">ps -l 		# 观察与当前终端机相关的进程</span><br><span class="line">ps -lA 		# 观察系统所有的进程数据（显示内容项同 ps -l 的项一样，只不过是系统所有进程）</span><br><span class="line">ps axjf		# 连同部分进程树状态</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-A：所有的 process 都显示出来，与 -e 具有同样的效果</span><br><span class="line">	-a：不与 terminal 有关的所有 process</span><br><span class="line">	-u：有效使用者（effective user）相关的 process</span><br><span class="line">	x：通常与 a 一起使用，可列出完整信息</span><br><span class="line">输出格式规划：</span><br><span class="line">	l：较长、较详细的将该 PID 的信息列出</span><br><span class="line">	j：工作的格式（jobs format）</span><br><span class="line">	-f：做一个更为完整的输出</span><br></pre></td></tr></table></figure>
<p>一般常用</p>
<p>ps -l     仅查询自己bash的进程</p>
<p>ps aux  查询系统所有运行的进程</p>
<ul>
<li>
<p>USER<br>
用户</p>
</li>
<li>
<p>PID<br>
进程识别符</p>
</li>
<li>
<p>%CPU<br>
占用CPU率</p>
</li>
<li>
<p>%MEM<br>
占用内存率</p>
</li>
<li>
<p>VSZ</p>
</li>
<li>
<p>RSS</p>
</li>
<li>
<p>TTY<br>
用户的终端机位置</p>
</li>
<li>
<p>STAT<br>
目前状态</p>
<ul>
<li>R 运行中</li>
<li>S 睡眠状态, 可被唤醒</li>
<li>D 不可被唤醒</li>
<li>T 停止状态</li>
<li>Z 僵尸状态, 进程已经终止但无法移除出内存</li>
</ul>
</li>
<li>
<p>STARTED</p>
</li>
<li>
<p>TIME<br>
进程实际花费CPU运行的时间</p>
</li>
<li>
<p>COMMAND</p>
</li>
</ul>
<h4 id="僵尸进程"><a class="markdownIt-Anchor" href="#僵尸进程"></a> 僵尸进程</h4>
<p>进程中的表示后面有 &lt;defunct&gt;标识</p>
<p>该进程的父进程无法完整的结束该进程, 而一直在内存中, 一般僵尸进程都会交给systemd程序负责, 而systemd是所有程序的父进程, 无法杀死该进程. 只能通过重启解决.</p>
<h3 id="top动态观察进程变化"><a class="markdownIt-Anchor" href="#top动态观察进程变化"></a> top动态观察进程变化</h3>
<p>top可以持续侦测进程运行状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">top [-d 数字] | top [-bnp]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-d：后面可以接秒数，整个进程画面更新的秒数，预设是 5 秒更新一次</span><br><span class="line">	-b：以批次的方式执行 top，还有更多的参数可以使用（莫名其妙啊，啥参数？），通常会搭配数据流重导向来将批次的结果输出为文件</span><br><span class="line">	-n：与 -b 搭配，需要进行几次 top 的输出</span><br><span class="line">	-p：指定某些 PID 来进行观察</span><br><span class="line"></span><br><span class="line">在 top 执行过程中可以使用的按键指令：</span><br><span class="line">	？：显示在 top 中可以输入的按键指令</span><br><span class="line">	P：以 CPU 的使用资源排序显示</span><br><span class="line">	M：以 Memory 的使用资源排序显示</span><br><span class="line">	N：以 PID 排序</span><br><span class="line">	T：由该进程使用 CPU 时间累积（TIME+）排序</span><br><span class="line">	k：给予某个 PID 一个信号（signal）</span><br><span class="line">	r：给予某个 PID 重新制定一个 nice 值</span><br><span class="line">	q：离开 top 软件的按键</span><br><span class="line">	E：切换单位显示，比如从 KB 切换为 G 显示</span><br><span class="line">	c：切换 COMMAND 的信息，name/完成指令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="kill杀死进程"><a class="markdownIt-Anchor" href="#kill杀死进程"></a> kill杀死进程</h3>
<table>
<thead>
<tr>
<th>代号</th>
<th>名称</th>
<th>名义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>启动被终止的进程, 重新启动</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>等同于ctrl + c 终止一个进程</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>强制终止一个进程的运行</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>以正常的方式终止进程, 对已经发生问题的进程无效</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>等同于ctrl - z暂停一个进程</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用ps + grep找到对应PID</span></span><br><span class="line">kill -SIGHUP $(ps aux|grep 'processName'|grep -v 'grep'|awk '{print $2}')</span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否重启, 需要看日记</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅看后五行</span></span><br><span class="line"> tail -5 /var/log/messages</span><br></pre></td></tr></table></figure>
<h3 id="进程的执行顺序"><a class="markdownIt-Anchor" href="#进程的执行顺序"></a> 进程的执行顺序</h3>
<p>哪个进程被优先执行, 取决于优先级 priority与CPU排程. PRI值由系统动态调整</p>
<p>PRI值低优先级高,  用户不可调整pri值(优先级), 但可通过NI值干涉, PRI(new) = PRI(old) + nice (NI值)</p>
<h4 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h4>
<ul>
<li>nice 值范围是 -20~19</li>
<li>root 可随意调整自己或他人进程的 Nice 值，且范围为 -20~19</li>
<li>一般使用者仅可调整自己进程的 Nice 值，且范围仅为 0~19（避免一般用户抢占系统资源）</li>
<li>一般使用者仅可将 nice 值越调越高；比如 nice 为 5，则未来仅能调整到大于 5；</li>
</ul>
<h4 id="调整ni值"><a class="markdownIt-Anchor" href="#调整ni值"></a> 调整ni值</h4>
<ul>
<li>启动时给与nice值, 用nice指令</li>
<li>调整某个已经存在的PID的nice值, renice指令</li>
</ul>
<h3 id="free内存查看指令"><a class="markdownIt-Anchor" href="#free内存查看指令"></a> free内存查看指令</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">free [-b|-k|-m|-g|-h] [-t] [-s N -c N]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-b：单位参数；默认是用 k，其他单位对应 bytes、Mbytes、Kbytes、Gbytes</span><br><span class="line">	-t: 输出的最终结果，显示物理内存与 swap 的总量</span><br><span class="line">	-s：可以让系统每几秒输出一次，不间断输出；</span><br><span class="line">	-c：与 -s 同时处理，让 free 列出几次</span><br></pre></td></tr></table></figure>
<p>系统会把空闲内存拿来做缓冲区之用，所以你系统没有那么繁忙的时候，也会显示内存被用的多的原因，这个是正常的，需要注意的是 swap，swap 最好不要被使用，而且使用超过 20% 以上, 表示物理内存不够.</p>
<h3 id="查询系统与核心相关信息"><a class="markdownIt-Anchor" href="#查询系统与核心相关信息"></a> 查询系统与核心相关信息</h3>
<p>uname指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uname [-asrmpi]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-a：所有系统相关的，都列出来</span><br><span class="line">	-s：系统核心名称</span><br><span class="line">	-r：核心的版本</span><br><span class="line">	-m：本系统的硬件名称，例如 i686 或 x86_64</span><br><span class="line">	-p：CPU 的类型，与 -m 类似</span><br><span class="line">	-i：硬件的平台（ix86）</span><br></pre></td></tr></table></figure>
<p>其余指令<br>
<a target="_blank" rel="noopener" href="https://zq99299.github.io/linux-tutorial/tutorial-basis/16/03.html#">介绍</a></p>
<ul>
<li>netstat 追踪网络有关的进程或数据</li>
<li>vmstat：侦测系统资源变化</li>
</ul>
<h3 id="特殊文件与进程"><a class="markdownIt-Anchor" href="#特殊文件与进程"></a> 特殊文件与进程</h3>
<p>具有SUID, SGID权限的指令执行状态</p>
<p>SUID权限仅对二进制查程序有效.</p>
<blockquote>
<p>SUID可以让执行者可以具有程序拥有者的权限, 在程序变成进程时</p>
</blockquote>
<p>fuser: 由文件找出正在使用该文件的进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fuser [-umv] [-k [i] [signal]] file/dir</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">	-u：除了进程的 PID 之外，同时列出该进程的拥有者</span><br><span class="line">	-m：后面接的文件名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效</span><br><span class="line">	-v：可以列出每个文件与进程还有指令的完整相关性</span><br><span class="line">	-k：找出使用该文件/目录的 PID，并试图以 SIGKILL 这个信号给予该 PID</span><br><span class="line">	-i：必须与 -k 配合使用，在删除 PID 之前会先询问使用者</span><br><span class="line">	-signal：例如 -1 -15 等，若不加的话，预设是 -9：SIGKILL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>lsof 查询进程开启或使用的文件与装置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br><span class="line">COMMAND     PID         USER   FD      TYPE             DEVICE   SIZE/OFF                NODE NAME</span><br><span class="line">loginwind   135 chenyuanzhen  cwd       DIR                1,4        640                   2 /</span><br><span class="line">loginwind   135 chenyuanzhen  txt       REG                1,4    2672336 1152921500312203831 /System/Library/CoreServices/loginwindow.app/Contents/MacOS/login</span><br></pre></td></tr></table></figure>
<h3 id="selinux"><a class="markdownIt-Anchor" href="#selinux"></a> SELinux</h3>
<p>非常完备的核心模块</p>
<p>安全强化的Linux.</p>
<p>DAC自主式访问控制, 根据用户的权限决定进程的权限.</p>
<p>避免root被窃取, 导致所有资源丢失, 委任式访问控制 MAC避免DAC的缺点.</p>
<p><mark>针对特定的进程与特定的文件资源来进行权限的控制</mark>. 使得黑客哪怕黑进网站, 而网站被限定只能读取某个目录下的文件, 那黑客能访问的范围也只有该目录</p>
<h2 id="例行性工作调度"><a class="markdownIt-Anchor" href="#例行性工作调度"></a> 例行性工作调度</h2>
<p>能在指定时间执行任务(一次 或 多次)</p>
<h4 id="工作调度种类"><a class="markdownIt-Anchor" href="#工作调度种类"></a> 工作调度种类</h4>
<ul>
<li>例行性, 每隔一定的周期要来办的事项</li>
<li>突发性 做完一次就没有</li>
</ul>
<p>对应命令</p>
<h4 id="at"><a class="markdownIt-Anchor" href="#at"></a> at</h4>
<p>处理仅执行一次就结束调度</p>
<blockquote>
<p>需要开启atd服务</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重新启动std这个服务</span></span><br><span class="line">systemctl restart atd;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启</span></span><br><span class="line">systemctl enable atd;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查阅atd状态</span></span><br><span class="line">systemctl status atd;</span><br></pre></td></tr></table></figure>
<p>执行步骤</p>
<ol>
<li>使用at指令产生所要执行的工作</li>
<li>将工作也文本方式写入 /var/spool/at/目录内 即可</li>
<li>atd服务,取用和执行</li>
</ol>
<h4 id="at使用限制"><a class="markdownIt-Anchor" href="#at使用限制"></a> at使用限制</h4>
<ol>
<li>/etc/at.allow 写在该文件中的使用者才可使用at</li>
<li>/etc/at.allow不在, 则看 /etc/at.deny/ 在deny文件内则不能使用</li>
<li>若两个文件不存在, 仅有root才可使用</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">at [-mldv] TIME</span><br><span class="line">-m: 当at完成工作后, 即时没输出讯息, 也使用email方式通知使用者</span><br><span class="line">-l: 列出该使用者的at调度</span><br><span class="line"></span><br><span class="line">at -c 工作号码</span><br><span class="line"></span><br><span class="line">TIME：时间格式，定义什么时候要进行 at 工作的时间，格式有：</span><br><span class="line">		HH:MM	如 4:00，在今日 4 点执行，若该时刻已过，则在明天的 4 点执行</span><br><span class="line">		HH:MM YYYY-MM-DD	如 4:00 2020-03-06 ，就在该时间点执行</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">at now + 5 minutes		# 按回车后，输入要执行的指令</span><br><span class="line"><span class="meta">at&gt;</span><span class="bash"> /bin/mail -s <span class="string">"testing at job"</span> root &lt; /root/.bashrc</span>		</span><br><span class="line"><span class="meta">at&gt;</span><span class="bash"> &lt;EOT&gt;		<span class="comment"># 需要使用 ctrl + d 结束输入</span></span></span><br></pre></td></tr></table></figure>
<h4 id="crontab"><a class="markdownIt-Anchor" href="#crontab"></a> crontab</h4>
<p>设置的工作将会循环的一直进行下去</p>
<blockquote>
<p>需要开启crond服务</p>
</blockquote>
<h4 id="linux系统常见例行化任务"><a class="markdownIt-Anchor" href="#linux系统常见例行化任务"></a> Linux系统常见例行化任务</h4>
<ul>
<li>进行登录文件的轮替<br>
将旧的登录数据放置到其他地方</li>
<li>系统分析logwatch文件, 用于分析软件问题, 硬件错误等</li>
<li>创建locate数据库</li>
<li>man page查询数据库创建</li>
</ul>
<h2 id="linux系统服务"><a class="markdownIt-Anchor" href="#linux系统服务"></a> Linux系统服务</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">systemctl [option] {command}</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动单一服务</span></span><br><span class="line">systemctl start [unit]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭服务</span></span><br><span class="line">systemctl stop [unit]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启</span></span><br><span class="line">systemctl enable [unit]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 状态查看</span></span><br><span class="line">systemctl status [unit]</span><br><span class="line"></span><br><span class="line">Loaded状态</span><br><span class="line">- enabled 开机自启</span><br><span class="line">- disabled 非开机自启</span><br><span class="line"></span><br><span class="line">Active状态</span><br><span class="line">- active(running) 启动</span><br><span class="line">- active(exited) 仅执行一次就正常结束</span><br><span class="line"></span><br><span class="line">- static 这个服务不能自己启动, 仅能被其他服务调用</span><br><span class="line">- mask 该服务无论如何都不可启动 systemctl unmask 恢复</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出正在运行的服务</span></span><br><span class="line">systemctl list-units</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有的服务</span> </span><br><span class="line">systemctl list-units -all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据 /usr/lib/systemd/system/ 内文件列出所有安装的unit</span></span><br><span class="line">systemctl list-unit-files</span><br></pre></td></tr></table></figure>
<p>每一个unit, 都会有一个unit文件, 用于告知系统如何启动该unit.</p>
<p>存放目录</p>
<ul>
<li>/usr/lib/systemd/system:</li>
<li>/run/systemd/system:  系统执行过程中所产生的服务脚本，比上面目录优先运行</li>
<li>/etc/systemd/system  （优先级别最高）:</li>
</ul>
<h4 id="enable话语disable"><a class="markdownIt-Anchor" href="#enable话语disable"></a> enable话语disable</h4>
<p>是否开机自启是基于<mark>软连接和文件夹</mark>的方式实现</p>
<ol>
<li>
<p>开机会读取开机文件夹中的unit文件 /etc/systemd/system</p>
</li>
<li>
<p><mark>开机文件夹其实存放一个软连接</mark>, 真正存放unit文件的地方是在/usr/lib/systemd/system或/run/sy…,</p>
</li>
</ol>
<p>例子:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable sshd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除软连接</span></span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/sshd.service.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启开机自启</span></span><br><span class="line">systemctl enable sshd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建软连接</span></span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/sshd.service to /usr/lib/systemd/system/sshd.service.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><!-- comment system--><div class="container"><hr></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="mailto:874579938@qq.com" target="_blank"><i class="fa fa-envelope-o"></i></a></div><div class="footer">© 2022 <a href="/" rel="nofollow">镇远</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>